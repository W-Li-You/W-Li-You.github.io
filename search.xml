<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小红的构造数组</title>
      <link href="/2023/12/21/xiao-hong-de-gou-zao-shu-zu/"/>
      <url>/2023/12/21/xiao-hong-de-gou-zao-shu-zu/</url>
      
        <content type="html"><![CDATA[<p>当时看到这个题只想到了分解质因数和判断什么时候输出-1，忘记输出的时候打乱他们的顺序了。</p><p><strong>思路：</strong></p><p>第一步：找出当前数的所有质因数和他们出现的次数，我将他们放入了一个存储long[]类型的Arraylist中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">long</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2L</span>; i &lt;= x / i ; i++) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">  </span><br><span class="line">    x = x / i;</span><br><span class="line">  </span><br><span class="line">    nums++;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(nums != <span class="number">0</span>) &#123;</span><br><span class="line">  </span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;i, nums&#125;);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">1</span>) list.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;x, <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>第二步：排序判断-1的情况，因为当最大的数中间的间隙不能被填满，那么两个数就相邻，输出-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">long</span>[] longs : list) &#123;</span><br><span class="line"></span><br><span class="line">   sum += longs[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> list.sort(Comparator.comparing(o -&gt; (-o[<span class="number">1</span>])));</span><br><span class="line"></span><br><span class="line"> <span class="type">long</span> <span class="variable">val</span> <span class="operator">=</span> list.get(<span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"> <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> list.get(<span class="number">0</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//System.out.println(val);</span></span><br><span class="line"></span><br><span class="line"> list.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(sum - max &lt; max - <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">   System.out.println(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>第三步：将出现次数最多的质数分成若干份，每份依次插入到后面的质数中间，除了第一份和出现次数第二多的质数多1，剩下的依次和出现其他次数的质数的数量相等，知道出现次数最多的质数被分完。然后依次输出遍历质因数，每输出一次将该质因数的个数减一。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(list.size() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> list.get(<span class="number">0</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(temp &lt; max) &#123;</span><br><span class="line"></span><br><span class="line">       list.add(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;val, temp + <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">       max = max - temp - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">       list.add(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;val, temp&#125;);</span><br><span class="line"></span><br><span class="line">       max = max - temp;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; ; i = i + <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(i &gt;= list.size() || max &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> list.get(i)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">     <span class="comment">//System.out.println(temp);</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(max &lt;= temp) &#123;</span><br><span class="line"></span><br><span class="line">       list.add(i, <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;val, max&#125;);</span><br><span class="line"></span><br><span class="line">       max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     max -= temp;</span><br><span class="line"></span><br><span class="line">     list.add(i,<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;val, temp&#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(max != <span class="number">0</span>) list.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;val, max&#125;);</span><br><span class="line"></span><br><span class="line">   n = list.size();</span><br><span class="line"></span><br><span class="line">   System.out.println(sum);</span><br><span class="line"></span><br><span class="line">   max = list.get(<span class="number">0</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(list.get(j)[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">         bw.write(list.get(j)[<span class="number">0</span>] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">         list.get(j)[<span class="number">1</span>] = list.get(j)[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><em><strong>*AC代码：*</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> scan.nextLong();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">      System.out.println(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="type">long</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2L</span>; i &lt;= x / i ; i++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        x = x / i;</span><br><span class="line"></span><br><span class="line">        nums++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(nums != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;i, nums&#125;);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) list.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;x, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.size();</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span>[] longs : list) &#123;</span><br><span class="line"></span><br><span class="line">      sum += longs[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list.sort(Comparator.comparing(o -&gt; (-o[<span class="number">1</span>])));</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">val</span> <span class="operator">=</span> list.get(<span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> list.get(<span class="number">0</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//System.out.println(val);</span></span><br><span class="line"></span><br><span class="line">    list.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sum - max &lt; max - <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">      System.out.println(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(list.size() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> list.get(<span class="number">0</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(temp &lt; max) &#123;</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;val, temp + <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">        max = max - temp - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;val, temp&#125;);</span><br><span class="line"></span><br><span class="line">        max = max - temp;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; ; i = i + <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(i &gt;= list.size() || max &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> list.get(i)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//System.out.println(temp);</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(max &lt;= temp) &#123;</span><br><span class="line"></span><br><span class="line">        list.add(i, <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;val, max&#125;);</span><br><span class="line"></span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      max -= temp;</span><br><span class="line"></span><br><span class="line">      list.add(i,<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;val, temp&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(max != <span class="number">0</span>) list.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;val, max&#125;);</span><br><span class="line"></span><br><span class="line">    n = list.size();</span><br><span class="line"></span><br><span class="line">    System.out.println(sum);</span><br><span class="line"></span><br><span class="line">    max = list.get(<span class="number">0</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list.get(j)[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">          bw.write(list.get(j)[<span class="number">0</span>] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">          list.get(j)[<span class="number">1</span>] = list.get(j)[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bw.flush();</span><br><span class="line"></span><br><span class="line">    bw.close();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛补题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2023/11/23/hua-dong-chuang-kou/"/>
      <url>/2023/11/23/hua-dong-chuang-kou/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>定长滑动窗口：窗口的大小是固定不变的。如果要求一个定长窗口内某一些数据的最大值或者最小值，可以通过维护单调递增或者递减的队列来解答。</p><p>不定长滑动窗口：窗口的大小是不定的，可以更改。这时候经常会配合双指针来解答。</p><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><h3 id="Problem-F-Art-for-Last"><a href="#Problem-F-Art-for-Last" class="headerlink" title="Problem F. Art for Last"></a><a href="https://codeforces.com/gym/104354/attachments">Problem F. Art for Last</a></h3><p><strong>思路：</strong></p><p>​    这是定长的一维滑动窗口。因为可以随机从序列中取值，所以可以对序列的顺序进行操作。要求长度为k的序列最大差值和最小差值乘积的最小值。</p><p>​    可以先对序列进行排序操作，这样子在取序列差值最大值的时候就可以用长度为k的序列两侧的元素进行相减操作。</p><p>​    然后维护一个双端队列，存储元素的下标，保证队列中下标对应元素和他的下一位元素相减的差值从前向后递增，并且后面元素的下标一定大于前面的元素：依次遍历元素下标，当元素下标小于k时，这时序列的长度小于k，所以只往双端队列中添加元素。当时元素下标大于k时，需要判断双端队列最前面的元素是否还在队列中，如果没有存在则去掉，。</p><p><strong>AC代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] = scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast() + <span class="number">1</span>] - nums[deque.peekLast()] &gt;= val) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> (nums[deque.peekFirst() + <span class="number">1</span>] - nums[deque.peekFirst()]) * (<span class="type">long</span>) (nums[count - <span class="number">1</span>] - nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> count - <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> - count == deque.peekFirst()) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast() + <span class="number">1</span>] - nums[deque.peekLast()] &gt;= val) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            res = Math.min(res, (nums[deque.peekFirst() + <span class="number">1</span>] - nums[deque.peekFirst()]) * (<span class="type">long</span>) (nums[i + <span class="number">1</span>] - nums[i - count + <span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MC0225银河贸易市场"><a href="#MC0225银河贸易市场" class="headerlink" title="MC0225银河贸易市场"></a><a href="https://www.matiji.net/exam/brushquestion/25/4446/16A92C42378232DEB56179D9C70DC45C">MC0225银河贸易市场</a></h3><p><strong>思路：</strong></p><p>​    这是定长的二维滑动窗口。要求n乘n矩阵内最大值和最小值之差最小，可以对每一行的元素进行操作，再对每一列的元素进行操作。</p><p>​    先对每一行的元素求长度为n的窗口内最大值和最小值：因为要求最大和最小，所以开了两个双端队列，进行和上一个题差不多的操作，开了一个三维数组来存储每一行的最大值和最小值，最后一维下标为0时是最大值，为1时是最小值。</p><p>​    再对每一列的元素求三维数组中长度为n的窗口的最大值和最小值。因为三维数组存储的是每一行长度为n的窗口最大值和最小值，所以这个操作就相当于求一个个nxn矩阵的最大值和最小值，直接相减取最小。</p><p><strong>AC代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] nums = <span class="keyword">new</span> <span class="title class_">int</span>[a][b];</span><br><span class="line">        <span class="type">int</span>[][][] p = <span class="keyword">new</span> <span class="title class_">int</span>[a][b - n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; b; j++) &#123;</span><br><span class="line">                nums[i][j] = scan.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; big = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; small = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">            big.clear();</span><br><span class="line">            small.clear();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!big.isEmpty() &amp;&amp; nums[i][big.peekLast()] &lt;= nums[i][j]) &#123;</span><br><span class="line">                    big.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                big.offerLast(j);</span><br><span class="line">                <span class="keyword">while</span> (!small.isEmpty() &amp;&amp; nums[i][small.peekLast()] &gt;= nums[i][j]) &#123;</span><br><span class="line">                    small.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                small.offerLast(j);</span><br><span class="line">            &#125;</span><br><span class="line">            p[i][<span class="number">0</span>][<span class="number">0</span>] = nums[i][small.peekFirst()];</span><br><span class="line">            p[i][<span class="number">0</span>][<span class="number">1</span>] = nums[i][big.peekFirst()];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n; j &lt; b; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(big.peekFirst() == j - n) &#123;</span><br><span class="line">                    big.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!big.isEmpty() &amp;&amp; nums[i][big.peekLast()] &lt;= nums[i][j]) &#123;</span><br><span class="line">                    big.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                big.offerLast(j);</span><br><span class="line">                <span class="keyword">if</span>(small.peekFirst() == j - n) &#123;</span><br><span class="line">                    small.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!small.isEmpty() &amp;&amp; nums[i][small.peekLast()] &gt;= nums[i][j]) &#123;</span><br><span class="line">                    small.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                small.offerLast(j);</span><br><span class="line">                p[i][j - n + <span class="number">1</span>][<span class="number">0</span>] = nums[i][small.peekFirst()];</span><br><span class="line">                p[i][j - n + <span class="number">1</span>][<span class="number">1</span>] = nums[i][big.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b - n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            big.clear();</span><br><span class="line">            small.clear();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!big.isEmpty() &amp;&amp; p[big.peekLast()][i][<span class="number">1</span>] &lt;= p[j][i][<span class="number">1</span>]) &#123;</span><br><span class="line">                    big.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                big.offerLast(j);</span><br><span class="line">                <span class="keyword">while</span> (!small.isEmpty() &amp;&amp; p[small.peekLast()][i][<span class="number">0</span>] &gt;= p[j][i][<span class="number">0</span>]) &#123;</span><br><span class="line">                    small.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                small.offerLast(j);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.min(p[big.peekFirst()][i][<span class="number">1</span>] - p[small.peekFirst()][i][<span class="number">0</span>], res);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n; j &lt; a; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(big.peekFirst() == j - n) &#123;</span><br><span class="line">                    big.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!big.isEmpty() &amp;&amp; p[big.peekLast()][i][<span class="number">1</span>] &lt;= p[j][i][<span class="number">1</span>]) &#123;</span><br><span class="line">                    big.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                big.offerLast(j);</span><br><span class="line">                <span class="keyword">if</span>(small.peekFirst() == j - n) &#123;</span><br><span class="line">                    small.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!small.isEmpty() &amp;&amp; p[small.peekLast()][i][<span class="number">0</span>] &gt;= p[j][i][<span class="number">0</span>]) &#123;</span><br><span class="line">                    small.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                small.offerLast(j);</span><br><span class="line">                res = Math.min(p[big.peekFirst()][i][<span class="number">1</span>] - p[small.peekFirst()][i][<span class="number">0</span>], res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完美立方体"><a href="#完美立方体" class="headerlink" title="完美立方体"></a><a href="https://ac.nowcoder.com/acm/contest/70637/G">完美立方体</a></h3><p><strong>思路：</strong></p><p>​    这是定长的三维滑动窗口，和上面两个题思路相似。分别对长、宽、高进行操作，第一次相当于求长度为n的线性序列最大值和最小值，第二次操作相当于是一个个nxn的矩阵最大值和最小值，第三次操作相当于nxnxn的立方体最大值和最小值。和上个题不同的是这次我开了两个三维数组分别存最大值和最小值，方便区分。</p><p><strong>AC代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span>[][][] nums = <span class="keyword">new</span> <span class="title class_">int</span>[a][b][c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; b; k++) &#123;</span><br><span class="line">                    nums[j][k][i] = scan.nextInt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][][] max1 = <span class="keyword">new</span> <span class="title class_">int</span>[a][b][c - n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[][][] min1 = <span class="keyword">new</span> <span class="title class_">int</span>[a][b][c - n + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; max = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; min = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; b; j++) &#123;</span><br><span class="line">                max.clear();</span><br><span class="line">                min.clear();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; c; k++) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!max.isEmpty() &amp;&amp; nums[i][j][max.getLast()] &lt;= nums[i][j][k]) &#123;</span><br><span class="line">                        max.pollLast();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (!min.isEmpty() &amp;&amp; nums[i][j][min.getLast()] &gt;= nums[i][j][k]) &#123;</span><br><span class="line">                        min.pollLast();</span><br><span class="line">                    &#125;</span><br><span class="line">                    max.offerLast(k);</span><br><span class="line">                    min.offerLast(k);</span><br><span class="line">                    <span class="keyword">if</span>(k &gt;= n) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(k - n == max.peekFirst()) &#123;</span><br><span class="line">                            max.pollFirst();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(k - n == min.peekFirst()) &#123;</span><br><span class="line">                            min.pollFirst();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(k &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                        max1[i][j][k - n + <span class="number">1</span>] = nums[i][j][max.peekFirst()];</span><br><span class="line">                        min1[i][j][k - n + <span class="number">1</span>] = nums[i][j][min.peekFirst()];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c = c - n + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][][] max2 = <span class="keyword">new</span> <span class="title class_">int</span>[a][b - n + <span class="number">1</span>][c];</span><br><span class="line">        <span class="type">int</span>[][][] min2 = <span class="keyword">new</span> <span class="title class_">int</span>[a][b - n + <span class="number">1</span>][c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; c; k++) &#123;</span><br><span class="line">                max.clear();</span><br><span class="line">                min.clear();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; b; j++) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!max.isEmpty() &amp;&amp; max1[i][max.getLast()][k] &lt;= max1[i][j][k]) &#123;</span><br><span class="line">                        max.pollLast();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (!min.isEmpty() &amp;&amp; min1[i][min.getLast()][k] &gt;= min1[i][j][k]) &#123;</span><br><span class="line">                        min.pollLast();</span><br><span class="line">                    &#125;</span><br><span class="line">                    max.offerLast(j);</span><br><span class="line">                    min.offerLast(j);</span><br><span class="line">                    <span class="keyword">if</span>(j &gt;= n) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(j - n == max.peekFirst()) &#123;</span><br><span class="line">                            max.pollFirst();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(j - n == min.peekFirst()) &#123;</span><br><span class="line">                            min.pollFirst();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                        max2[i][j - n + <span class="number">1</span>][k] = max1[i][max.peekFirst()][k];</span><br><span class="line">                        min2[i][j - n + <span class="number">1</span>][k] = min1[i][min.peekFirst()][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        b = b - n + <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">M</span> <span class="operator">=</span> (<span class="type">long</span>) (<span class="number">1e9</span>) + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; b; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; c; k++) &#123;</span><br><span class="line">                max.clear();</span><br><span class="line">                min.clear();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!max.isEmpty() &amp;&amp; max2[max.getLast()][j][k] &lt;= max2[i][j][k]) &#123;</span><br><span class="line">                        max.pollLast();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (!min.isEmpty() &amp;&amp; min2[min.getLast()][j][k] &gt;= min2[i][j][k]) &#123;</span><br><span class="line">                        min.pollLast();</span><br><span class="line">                    &#125;</span><br><span class="line">                    max.offerLast(i);</span><br><span class="line">                    min.offerLast(i);</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;= n) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(i - n == max.peekFirst()) &#123;</span><br><span class="line">                            max.pollFirst();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(i - n == min.peekFirst()) &#123;</span><br><span class="line">                            min.pollFirst();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                        res = (res + (min2[min.peekFirst()][j][k]) - max2[max.peekFirst()][j][k]  + M ) % M;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可口蛋糕"><a href="#可口蛋糕" class="headerlink" title="可口蛋糕"></a><a href="https://ac.nowcoder.com/acm/contest/73450/E">可口蛋糕</a></h3><p><strong>思路：</strong></p><p>​    这是一个不定长的滑动窗口。和上面不同的是，这次加了双指针的方法。</p><p>​    首先对w数组和d数组求前缀和。这样子w[i] - w[j]就相当于i到j后面一个元素内所有元素之和。</p><p>​    开两个指针，i和j，不断移动i指针，当存在j指针可以使w[i] - w[j]大于等于W时，不断移动j指针，同时存储0到j指针内的最小前缀和，i指针在的位置到0的前缀和减去j指针内的最小前缀和相当于以i为结尾的序列内能达到饱和的最大得分。</p><p><strong>AC代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        String[] s = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">long</span>[] w = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">long</span>[] d = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">        w[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        String[] s1 = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            w[i] = Long.parseLong(s1[i - <span class="number">1</span>]);</span><br><span class="line">            w[i] += w[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        String[] s2 = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            d[i] = Long.parseLong(s2[i - <span class="number">1</span>]);</span><br><span class="line">            d[i] += d[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (w[i] - w[j] &gt;= k) &#123;</span><br><span class="line">                min = Math.min(min, d[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min != Long.MAX_VALUE) &#123;</span><br><span class="line">                res = Math.max(d[i] - min, res);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2023/10/10/dan-li-mo-shi/"/>
      <url>/2023/10/10/dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>单例模式（Singleton）是一种创建对象的设计模式，确保在应用程序中只有一个实例。</p><p> 优点： </p><p>1、确保一个类只有一个实例，避免了重复创建对象的开销。</p><p>2、提供全局访问点，方便在整个程序中访问该实例。</p><p>3、可以控制对象的数量和生命周期，确保对象的一致性和可靠性。</p><p>4、可以避免多线程冲突问题，在多线程环境下保证对象的唯一性。</p><p> 缺点： </p><p>1、单例模式可能导致紧耦合，使得程序的扩展性和可维护性变差。</p><p>2、单例模式不适合需要多个相互独立的实例的情况，违背了单一职责原则。</p><p>3、单例模式的实现需要考虑线程安全，增加了实现的复杂性。</p><p> 五种实现方式： </p><p>饿汉式：没有实现懒加载，在类加载时初始化，即在运行之前只是将打包的代码加载到内存的时候就初始化，会造成内存浪费，但是它线程安全，并且执行效率高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>懒汉式：单例对象被使用的时候才初始化，避免了内存浪费。占用空间小，效率有问题，线程不安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; <span class="comment">//私有构造</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当多个对象进入getInstance（）方法中的if时被判断为空，可能创建多个实例对象。</p><p>解决办法：</p><p>可以在方法上加上synchronized同步锁，但是运行效率低下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>双重检查锁：提高了同步锁的效率，使用双重检查锁进一步进行优化，可以避免整个方法被锁，只对需要锁的代码部分进行加锁，可以提高执行效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>静态内部类：引入一个静态内部类，静态内部类只有在调用的时候才会加载，保证了Singleton实例的延迟初始化，又保证了实例的唯一性。</p><p>静态内部类虽然保证了单例在多线程并发下的线程安全性，但是在遇到序列化对象时吗，默认的方式运行得到的结果就是多例的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerObject</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InnerObject.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内部枚举类：防止了反射和序列化攻击。通过Java反射机制可以实例化构造方法为private的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonFactory</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">        SINGLETON;</span><br><span class="line">        <span class="keyword">private</span> Singleton singleton;</span><br><span class="line">        <span class="comment">//枚举类的构造方法在类加载被实例化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">EnumSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EnumSingleton.SINGLETON.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jsp内置对象</title>
      <link href="/2023/09/13/jsp-nei-zhi-dui-xiang/"/>
      <url>/2023/09/13/jsp-nei-zhi-dui-xiang/</url>
      
        <content type="html"><![CDATA[<p>MVC是一种软件设计模式，Model-View-Controller（模型-视图-控制器），最早出现在Smalltalk语言中，后被Sun公司推荐为JavaEE平台的设计模式。</p><p>MVC将应用程序分为了3个核心模块，这3个模块可以被称为业务层-视图层-控制层。</p><p><strong>业务层：</strong>负责实现应用程序的业务逻辑，封装各种对数据的处理方法。它不会关心它回如何被视图层显示或者被控制器调用，它只接收数据并处理，然后返回一个结果。</p><p><strong>视图层：</strong>负责应用程序对用户的显示，它从用户那里获取输入数据并通过控制层传给业务层处理，然后通过控制层获取业务层返回的结果并显示给用户。</p><p><strong>控制层：</strong>负责控制应用程序的流程，它接收从视图层传过来的数据，然后选择业务层中的某个业务来处理，接收业务层返回的结果并选择视图层中的某个视图来显示结果。</p><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>*<strong>DispatcherServlet前端控制器：</strong>SpringMVC的核心组件之一，充当请求的入口。通过前端控制器来接收前端用户发送的请求并交给各个组件来处理，DispatcherServlet还处理全局配置、异常处理和视图渲染等。</p><p>*<strong>HandlerMapper处理映射器：</strong>前端处理器接收了用户的请求后，将用户的请求交给处理映射器来进行处理。HandLerMapper根据请求的URL、请求方法等信息，确定应该由哪个处理器来处理该请求。它维护一个处理映射表，将URL映射到相应的处理器。</p><p><strong>HandlerExecutionChain处理执行链：</strong>表示请求处理的执行链，包括处理器和拦截器的顺序。</p><p>*<strong>HandlerAdapter处理适配器：</strong>当处理映射器将请求处理之后，将处理好的Handler返回给前端控制器，前端控制器将Handler交给处理适配器来进行进一步的处理，处理适配器负责根据处理的类型调用具体的Controller（处理器）进行处理。</p><p>*<strong>Controller处理器：</strong>Controller是接收请求并根据业务逻辑进行处理。Controller处理请求后，将请求结果封装到ModelAndView对象中并进行返回。</p><p><strong>ModelAndView：</strong>ModelAndView是一个包含处理结构的模型数据和要渲染的视图信息的对象，它将处理结果数据以及要展示的视图名称封装在一起，供视图解析器进行处理。</p><p>*<strong>ViewResolver视图解析器：</strong>当处理适配器将Handler处理成ModelAndView逻辑视图以后，将ModelAndView返回给前端控制器，前端控制器将ModelAndView交给视图解析器进一步进行解析，ViewResolver根据配置和规则，将逻辑视图名称解析为实际的视图对象。</p><p><strong>View视图对象：</strong>它是将模型数据渲染到客户端的关键组件，当视图解析器将ModelAndView进行解析成View之后，视图需要进行渲染才能真正被用户看到。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC相关组件</title>
      <link href="/2023/08/21/mvc-zu-jian/"/>
      <url>/2023/08/21/mvc-zu-jian/</url>
      
        <content type="html"><![CDATA[<p>MVC是一种软件设计模式，Model-View-Controller（模型-视图-控制器），最早出现在Smalltalk语言中，后被Sun公司推荐为JavaEE平台的设计模式。</p><p>MVC将应用程序分为了3个核心模块，这3个模块可以被称为业务层-视图层-控制层。</p><p><strong>业务层：</strong>负责实现应用程序的业务逻辑，封装各种对数据的处理方法。它不会关心它回如何被视图层显示或者被控制器调用，它只接收数据并处理，然后返回一个结果。</p><p><strong>视图层：</strong>负责应用程序对用户的显示，它从用户那里获取输入数据并通过控制层传给业务层处理，然后通过控制层获取业务层返回的结果并显示给用户。</p><p><strong>控制层：</strong>负责控制应用程序的流程，它接收从视图层传过来的数据，然后选择业务层中的某个业务来处理，接收业务层返回的结果并选择视图层中的某个视图来显示结果。</p><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>*<strong>DispatcherServlet前端控制器：</strong>SpringMVC的核心组件之一，充当请求的入口。通过前端控制器来接收前端用户发送的请求并交给各个组件来处理，DispatcherServlet还处理全局配置、异常处理和视图渲染等。</p><p>*<strong>HandlerMapper处理映射器：</strong>前端处理器接收了用户的请求后，将用户的请求交给处理映射器来进行处理。HandLerMapper根据请求的URL、请求方法等信息，确定应该由哪个处理器来处理该请求。它维护一个处理映射表，将URL映射到相应的处理器。</p><p><strong>HandlerExecutionChain处理执行链：</strong>表示请求处理的执行链，包括处理器和拦截器的顺序。</p><p>*<strong>HandlerAdapter处理适配器：</strong>当处理映射器将请求处理之后，将处理好的Handler返回给前端控制器，前端控制器将Handler交给处理适配器来进行进一步的处理，处理适配器负责根据处理的类型调用具体的Controller（处理器）进行处理。</p><p>*<strong>Controller处理器：</strong>Controller是接收请求并根据业务逻辑进行处理。Controller处理请求后，将请求结果封装到ModelAndView对象中并进行返回。</p><p><strong>ModelAndView：</strong>ModelAndView是一个包含处理结构的模型数据和要渲染的视图信息的对象，它将处理结果数据以及要展示的视图名称封装在一起，供视图解析器进行处理。</p><p>*<strong>ViewResolver视图解析器：</strong>当处理适配器将Handler处理成ModelAndView逻辑视图以后，将ModelAndView返回给前端控制器，前端控制器将ModelAndView交给视图解析器进一步进行解析，ViewResolver根据配置和规则，将逻辑视图名称解析为实际的视图对象。</p><p><strong>View视图对象：</strong>它是将模型数据渲染到客户端的关键组件，当视图解析器将ModelAndView进行解析成View之后，视图需要进行渲染才能真正被用户看到。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML解析</title>
      <link href="/2023/07/15/xml-jie-xi/"/>
      <url>/2023/07/15/xml-jie-xi/</url>
      
        <content type="html"><![CDATA[<p>xml是一种可扩展标记语言，是用来定义其他语言的一种元语言，使用自定义的标签对文档进行描述。</p><p>xml解析是指将xml文件转化为程序可以处理数据结构的过程。</p><p>JAVA自身原生的解析方式：DOM解析和SAX解析</p><h4 id="DOM解析"><a href="#DOM解析" class="headerlink" title="DOM解析"></a>DOM解析</h4><p>首先在内存中创建一个Document对象，然后把XML文档读取进来赋值给这个dom对象。由于dom对象是基于树结构的，所以对dom对象进行遍历即可。对内存中的dom对象可以进行查询、修改、删除操作，还可以写回原XML文档保存修改。</p><p><strong>优点：</strong></p><p>1、由于整棵树在内存中，因此可以对xml文档随机访问。</p><p>2、可以对xml文档进行修改操作。</p><p><strong>缺点：</strong></p><p>1、整个文档必须一次性解析完。</p><p>2、由于整个文档都要载入内存，对于大文档成本高。</p><p><strong>过程：</strong></p><p>1、创建DocumentBuilderFactory，由newInstance()方法获取工厂实例。</p><p>2、由工厂创建DocumentBuilder。</p><p>3、通过Document dom = builder.parse(file)读取xml文档创建dom对象。</p><p>4、通过dom对象的一系列方法获取某个节点。</p><p>5、通过NodeList对象获取节点列表中的某个节点。</p><p>6、通过Node对象读取节点属性。</p><p>7、获取结点的子节点列表。</p><p>8、获取结点值。</p><p>DOM解析XML文档，把元素、元素属性、元素值都看作Node类型，通过node.getNodeName()获取元素名、属性名，通过getNodeValue()获取属性值、元素值，通过getChildNodes()获取子节点们，通过item(i)获取第i个属性或者第i个子节点。</p><h4 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h4><p>通过parse(file, listener)函数用一个listener对xml文档进行查找，按顺序读取文档，遍历每个标签，当发现目标标签时，读取标签的属性、结点值并返回。</p><p><strong>优点：</strong></p><p>1、无需将整个xml文档载入内存，因此消耗内存少。</p><p>2、可以继承ContentHandler创建多个执行不同查询的listener进行解析操作。</p><p><strong>缺点：</strong></p><p>1、不能随机的访问xml中的节点。</p><p>2、不能修改文档。</p><p>3、查询一次就要对xml文档从头到尾遍历一次。</p><p><strong>过程：</strong></p><p>1、创建解析工厂：SAXParserFactory factory = SAXParserFactory.newInstance();</p><p>2、由工厂创建解析器：SAXParser parser = factory.newSAXParser();</p><p>3、通过解析器的parse()方法，对指定xml文档以指定handler之类进行解析查询：parser.parse(xmlFile, new MySaxListener());</p><p>通过SAX解析xml文档是没有dom对象出现的，所以不会有node，不会有getNodeName()、getNodeValue()获取节点名、值。SAX解析XML文档的节点名是通过事件函数的参数qName获取的，属性是通过参数attributes的getValue(“属性名”)获取的，结点值是通过当前事件函数发生时，characters(char[] ch, int start, int length)方法中的内容获取的。</p><h4 id="JDOM解析"><a href="#JDOM解析" class="headerlink" title="JDOM解析"></a>JDOM解析</h4><p>JDOM方法是根据DOM方法的众多繁琐操作进行包装得到的。DOM方法解析XML文档其实是很繁琐的，而且很混乱，标签、属性、换行空格都当作节点类型来处理。JDOM方法定义了一系列通俗、好记的方法来解析XML，方法的底层封装了一系列DOM操作，但是我们不必亲自进行这些繁琐的操作。</p><p><strong>优点：</strong></p><p>查找方便，可以修改。</p><p><strong>缺点：</strong></p><p>装载整个文档，对内存容量要求高。</p><h4 id="DOM4J解析"><a href="#DOM4J解析" class="headerlink" title="DOM4J解析"></a>DOM4J解析</h4><p>最初它是JDOM的一种智能分支，它合并了许多超出基本XML文档表示的功能，还提供了构建文档表示的选项，通过DOM4J API和标准DOM接口具有并行访问功能。DOM4J是一个非常优秀的Java XML API，具有性能优异、功能强大和极端易用使用的特点，同时它也是一个开放源代码的软件。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贴吧管理系统</title>
      <link href="/2023/06/11/tie-ba-guan-li-xi-tong/"/>
      <url>/2023/06/11/tie-ba-guan-li-xi-tong/</url>
      
        <content type="html"><![CDATA[<p>  这星期我们在实训，周六要去比赛，实训结束后我又要去集训，所以这星期没学多少东西。不过在实训的时候，因为老师对用框架的同学要求比较严，提了好多附加条件，所以在写实训项目的时候也有学到一点东西吧。</p><p>​    老师给用框架的同学其中一个限制条件是图形验证码和邮箱验证。因为以前写项目我们全都是用的邮箱验证，也没想过去实现一下图形验证码，所以在实训的时候我就去学了一下图形验证码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageCodeUtil</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RANDOMCODEKEY</span> <span class="operator">=</span> <span class="string">&quot;RANDOMVALIDATECODEKEY&quot;</span>;<span class="comment">//放到session中的key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ImageCodeUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">randString</span> <span class="operator">=</span> <span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;<span class="comment">//随机产生数字与字母组合的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">95</span>;<span class="comment">// 图片宽</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">25</span>;<span class="comment">// 图片高</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">lineSize</span> <span class="operator">=</span> <span class="number">40</span>;<span class="comment">// 干扰线数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stringNum</span> <span class="operator">=</span> <span class="number">4</span>;<span class="comment">// 随机产生字符数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Font <span class="title function_">getFont</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;Fixedsys&quot;</span>, Font.CENTER_BASELINE, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Color <span class="title function_">getRandColor</span><span class="params">(<span class="type">int</span> fc, <span class="type">int</span> bc)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fc &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            fc = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bc &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            bc = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> fc + random.nextInt(bc - fc - <span class="number">16</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> fc + random.nextInt(bc - fc - <span class="number">14</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> fc + random.nextInt(bc - fc - <span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Color</span>(r, g, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getRandomCode</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedImage</span>(width, height, BufferedImage.TYPE_INT_BGR);</span><br><span class="line">        <span class="type">Graphics</span> <span class="variable">g</span> <span class="operator">=</span> image.getGraphics();</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        g.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;Times New Roman&quot;</span>, Font.ROMAN_BASELINE, <span class="number">18</span>));</span><br><span class="line">        g.setColor(getRandColor(<span class="number">110</span>, <span class="number">133</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= lineSize; i++) &#123;</span><br><span class="line">            drawLine(g);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">randomString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= stringNum; i++) &#123;</span><br><span class="line">            randomString = drawString(g, randomString, i);</span><br><span class="line">        &#125;</span><br><span class="line">        session.removeAttribute(RANDOMCODEKEY);</span><br><span class="line">        session.setAttribute(RANDOMCODEKEY, randomString);</span><br><span class="line">        g.dispose();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ImageIO.write(image, <span class="string">&quot;JPEG&quot;</span>, response.getOutputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;将内存中的图片通过流动形式输出到客户端失败&gt;&gt;&gt;&gt;   &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">drawString</span><span class="params">(Graphics g, String randomString, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        g.setFont(getFont());</span><br><span class="line">        g.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(random.nextInt(<span class="number">101</span>), random.nextInt(<span class="number">111</span>), random</span><br><span class="line">                .nextInt(<span class="number">121</span>)));</span><br><span class="line">        <span class="type">String</span> <span class="variable">rand</span> <span class="operator">=</span> String.valueOf(getRandomString(random.nextInt(randString</span><br><span class="line">                .length())));</span><br><span class="line">        randomString += rand;</span><br><span class="line">        g.translate(random.nextInt(<span class="number">3</span>), random.nextInt(<span class="number">3</span>));</span><br><span class="line">        g.drawString(rand, <span class="number">13</span> * i, <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> randomString;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawLine</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> random.nextInt(width);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> random.nextInt(height);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">xl</span> <span class="operator">=</span> random.nextInt(<span class="number">13</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">yl</span> <span class="operator">=</span> random.nextInt(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        g.drawLine(x, y, x + xl, y + yl);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRandomString</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(randString.charAt(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/f0839cc0e6274010b8d5ae28f9cffe54.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/f0839cc0e6274010b8d5ae28f9cffe54.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> BufferedImage:是抽象类Image类的实现类，主要作用是将图片加载到内存中。BufferedImage生成的图片在内存里有一个图像缓冲区，利用这个缓冲区我们可以很方便的操作这个图片。</p><p>Fond：用于设置图形界面上字体样式。 </p><p>Graphics 类：是所有图形上下文的抽象基类，允许应用程序在组件（已经在各种设备上实现）以及闭屏图像上进行绘制。 （类似于画笔）</p><p><img src="https://img-blog.csdnimg.cn/41080af4e8974f68bd5c79fac16dec78.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/41080af4e8974f68bd5c79fac16dec78.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>​    不过 这个图形验证码不能在静态的页面测试，要在程序运行之后打开的页面测试 。</p><p>​    因为写的是贴吧管理系统，所以我的项目里面有发布帖子的功能，所以我也上网了解了一下富文本，用到了我的项目里面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">demo-nav</span> <span class="attr">title</span>=<span class="string">&quot;wangEditor default mode&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">demo-nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-container&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;editor-toolbar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;editor-text-area&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #fff3f3; color: #333333; line-height: 40px;padding-left: 20px&quot;</span>&gt;</span></span><br><span class="line">     总字数: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;total-length&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     选择字数: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;selected-length&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> E = <span class="variable language_">window</span>.<span class="property">wangEditor</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 切换语言</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="variable constant_">LANG</span> = location.<span class="property">href</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;lang=en&#x27;</span>) &gt; <span class="number">0</span> ? <span class="string">&#x27;en&#x27;</span> : <span class="string">&#x27;zh-CN&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        E.<span class="title function_">i18nChangeLanguage</span>(<span class="variable constant_">LANG</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">editor</span> = E.<span class="title function_">createEditor</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">selector</span>: <span class="string">&#x27;#editor-text-area&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">html</span>: <span class="string">&#x27;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">config</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">scroll</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">placeholder</span>: <span class="string">&#x27;请输入你的帖子内容&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">MENU_CONF</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">uploadImage</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">fieldName</span>: <span class="string">&#x27;your-fileName&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">base64LimitSize</span>: <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span> <span class="comment">// 10M 以下插入 base64</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">onChange</span>(<span class="params">editor</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(editor.<span class="title function_">getHtml</span>())</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 选中文字</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">const</span> selectionText = editor.<span class="title function_">getSelectionText</span>()</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;selected-length&#x27;</span>).<span class="property">innerHTML</span> = selectionText.<span class="property">length</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 全部文字</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">const</span> text = editor.<span class="title function_">getText</span>().<span class="title function_">replace</span>(<span class="regexp">/\n|\r/mg</span>, <span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;total-length&#x27;</span>).<span class="property">innerHTML</span> = text.<span class="property">length</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">toolbar</span> = E.<span class="title function_">createToolbar</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                editor,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">selector</span>: <span class="string">&#x27;#editor-toolbar&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">config</span>: &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/5d00085d2cf9410d801522968abab51c.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/5d00085d2cf9410d801522968abab51c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>​    这个有一些地方没做好，其中一个就是文件上传部分的类型判断，我没有把文件上传换成我自己的接口去对他进行类型判断，不过在下面写的上传封面里面我做了类型判断。</p><p>​    这次实训项目整体来说写的还行，就是时间有点紧，不过也耗费了我挺多精力的。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql日志</title>
      <link href="/2023/05/23/mysql-ri-zhi/"/>
      <url>/2023/05/23/mysql-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、日志"><a href="#一、日志" class="headerlink" title="一、日志"></a>一、日志</h1><h2 id="（1）错误日志"><a href="#（1）错误日志" class="headerlink" title="（1）错误日志"></a>（1）错误日志</h2><p>错误日志时MySQL中最重要的日志之一，它记录了mysqld启动和停止时，以及服务器再运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</p><p>该日志时默认开启的，默认存放目录/var/log/，默认的日志文件名为mysqld.log。查看日志位置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span> </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="（2）二进制日志"><a href="#（2）二进制日志" class="headerlink" title="（2）二进制日志"></a>（2）二进制日志</h2><p>二进制日志（BINLOG）记录了所有的DDL语句和DML语句，但不包括数据查询语句（SELECT、SHOW）。</p><p>作用：</p><p>（1）灾难时的数据恢复</p><p>（2）MySQL的主从复制</p><p>在MySQL8版本中，默认二进制日志时开启着的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><table><thead><tr><th>日志格式</th><th>含义</th></tr></thead><tbody><tr><td>STATEMENT</td><td>基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。</td></tr><tr><td>ROW</td><td>基于行的日志记录，记录的是每一行的数据变更。（默认）</td></tr><tr><td>MIXED</td><td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_format%&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>日志查看</strong></p><p>由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具mysqlbinlog来查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [参数选项] logfilename</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>参数选项：</p><p>-d 指定数据库名称，只列除指定的数据库相关操作。</p><p>-o 忽略掉日志中的前n行命令。</p><p>-v 将行事件（数据变更）重构为SQL语句。</p><p>-w 将行事件（数据变更）重构为SQL语句，并输出注释信息。</p><p><strong>日志删除</strong></p><p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>reset master</td><td>删除全部binlog日志，删除之后，日志编号，将从binlog.000001重新开始</td></tr><tr><td>purge master logs to ‘binlog.xxxxxx’</td><td>删除xxxxxx编号之前的所有日志</td></tr><tr><td>purge master logs before ‘yyyy-mm-dd hh24:mi:ss’</td><td>删除日志为”yyyy-mm-dd hh24:mi:ss”之前产生的所有日志</td></tr></tbody></table><p>可以在mysql的配置文件中配置二进制日志的过期时间，设置之后，二进制日志过期会自动删除（默认30天）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_expire_logs_seconds%&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="（3）查询日志"><a href="#（3）查询日志" class="headerlink" title="（3）查询日志"></a>（3）查询日志</h2><p>查询日志中记录了客户端的所有操作，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是不开启的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>修改配置文件开启查询日志：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#修改MySQL的配置文件<span class="operator">/</span>ect<span class="operator">/</span>my.cnf文件，添加如下内容</span><br><span class="line">general_log<span class="operator">=</span><span class="number">1</span>   #开启查询日志，<span class="number">0</span>关闭，<span class="number">1</span>开启</span><br><span class="line">general_log_file<span class="operator">=</span>mysql_query.log    #设置日志文件名，默认host_name.log</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="（4）慢查询日志"><a href="#（4）慢查询日志" class="headerlink" title="（4）慢查询日志"></a>（4）慢查询日志</h2><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，默认10s）的所有SQL语句的日志。</p><p>SHOW VARIABLES LIKE ‘slow_query_log’; MySQL的慢查询日志是默认不开启的，需要在MySQL的配置文件（/ect/my.cnf）中配置如下信息：</p><p><img src="https://img-blog.csdnimg.cn/e661d2c2f6fe4160b1fa02227e46a812.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/e661d2c2f6fe4160b1fa02227e46a812.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> 配置完毕之后，重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息：/var/lib/mysql/localhost-slow.log。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打家劫舍（算法）</title>
      <link href="/2023/05/23/da-jia-jie-she-wen-ti-suan-fa/"/>
      <url>/2023/05/23/da-jia-jie-she-wen-ti-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><a href="https://leetcode.cn/problems/house-robber/">打家劫舍<img src="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" class="lazyload placeholder" data-srcset="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img">https://leetcode.cn/problems/house-robber/</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=<span class="number">2</span>) nums[<span class="number">1</span>]=Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            nums[i]=Math.max(nums[i-<span class="number">2</span>]+nums[i],nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这是一个典型的dp问题，设f[i]是偷盗前i个房屋可以获得的最高金额。</p><p>当房间数大于2时，可以将前i个房屋能获得的最大金额分为两种情况。</p><p>（1）偷第i个房间，则由题意知道，此时就不能偷第i-1个房间。因为f[i-2]等于偷前i-2个房间可以偷到的最大金额，所以此时偷前i个房间可以获得的最大金额等于偷前i-2个房间能偷到的最大金额加上第i个房间的金额，即f[i]=f[i-2]+nums[i];</p><p>（2）不偷第i个房间，此时可以偷第i-1个房间，偷前i个房间能获得的最大金额就相当于偷前i-1个房间可以获得的最大金额，即f[i]=f[i-1]；</p><p>综合两种情况，取两种情况的最大值，即为偷前i个房间可以获得的最大金额，即：</p><p>f[i]=max(f[i-2]+nums[i],f[i-1]);</p><p>所以状态转移方程：</p><p><img src="https://img-blog.csdnimg.cn/cba931cb36674a89b848e88707a6c51b.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/cba931cb36674a89b848e88707a6c51b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>最后结果为f[n-1]，n为房屋总个数。 </p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍 II<img src="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" class="lazyload placeholder" data-srcset="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img">https://leetcode.cn/problems/house-robber-ii/</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> maxRob(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxRob(Arrays.copyOfRange(nums,<span class="number">0</span>,n-<span class="number">1</span>)),maxRob(Arrays.copyOfRange(nums,<span class="number">1</span>,n)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxRob</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=<span class="number">2</span>) nums[<span class="number">1</span>]=Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            nums[i]=Math.max(nums[i-<span class="number">2</span>]+nums[i],nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>这个题和上面一个题的思路差不多，只不过因为这个是环形房屋，所以可以将环形房屋拆分成线形房屋，分为两种情况讨论。</p><p>这个题和上个不一样的地方在于第一个房屋和最后一个房屋不能同时偷盗，所以分为以下两种情况讨论（设有n个房屋）：</p><p>（1）偷盗第一个房屋，此时不能偷盗最后一个房屋，所以此时能获得的最大金额为偷盗第1个房屋到第n-1个房屋的最大金额。</p><p>（2）偷盗最后一个房屋，此时不能偷盗第一个房屋，所以此时能获得的最大金额为偷盗第2个房屋到第n个房屋的最大金额。</p><p>按上个题的思路算出两种情况下获得的最大金额，然后取两种情况的最大值即可。</p><p>要注意的一点是当只有一个房屋的时候，直接返回该房屋的金额即可。</p><h1 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍 III<img src="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" class="lazyload placeholder" data-srcset="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img">https://leetcode.cn/problems/house-robber-iii/</a></p><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p><p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p><p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p><p><strong>示例 1:</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2c097a0036506f362f5b380614de1503.jpeg" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/2c097a0036506f362f5b380614de1503.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,2,3,null,3,null,1]</span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ea82aa0ebbd485ff59fa21dbe537c8ff.jpeg" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/ea82aa0ebbd485ff59fa21dbe537c8ff.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,4,5,1,3,null,1]</span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树的节点数在 <code>[1, 104]</code> 范围内</li><li><code>0 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] res=dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dfs(TreeNode node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] l=dfs(node.left);</span><br><span class="line">        <span class="type">int</span>[] r=dfs(node.right);</span><br><span class="line">        <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>]=Math.max(l[<span class="number">0</span>],l[<span class="number">1</span>])+Math.max(r[<span class="number">0</span>],r[<span class="number">1</span>]);</span><br><span class="line">        res[<span class="number">1</span>]=l[<span class="number">0</span>]+r[<span class="number">0</span>]+node.val;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>这个题可以设置一个数组，num[0]记录不偷当前节点的房屋能获得的最大金额，num[1]记录偷当前节点能获得的最大金额。记录当前节点左节点为left，右节点为right，对两种情况进行讨论。</p><p>（1）当不偷当前房屋的时候，左子节点可以偷盗也可以不偷盗，即从左子节点上的房屋能获得的最大金额为max(left[0],left[1])。同理，右子节点房屋也可以偷盗可以不偷，右子节点房屋能获得的最大金额为max(right[0],right[1])。即num[0]=max(left[0],left[1])+max(right[0],right[1])。</p><p>（2）当偷盗当前房屋，左右子节点都不能偷盗，从左右子节点能获得的最大金额分别为left[0]和right[0]，再加上当前节点能获得的金额，即为偷盗当前房屋能获得的最大金额。即num[1]=left[0]+right[0]+node.val。</p><p>最后计算到根节点，所有房屋能获得的最大金额为max(root[0],root[1])。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql锁</title>
      <link href="/2023/05/11/mysql-suo/"/>
      <url>/2023/05/11/mysql-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="一、锁"><a href="#一、锁" class="headerlink" title="一、锁"></a>一、锁</h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><p>全局锁：锁定数据库中的所有表。</p><p>表级锁：每次操作锁住整张表。</p><p>行级锁：每次操作锁住对应的行数据。</p><h3 id="（一）全局锁"><a href="#（一）全局锁" class="headerlink" title="（一）全局锁"></a>（一）全局锁</h3><p>全局锁是对整个数据库实例加锁，加锁之后整个实例只能读取，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><p>其典型使用场所是做全库的逻辑备份，对所有表进行锁定，从而获取一致性的视图，保证数据的完整性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>弊端：</strong></p><p>性能较差，是比较重的操作。</p><p>&lt;1&gt;、如果在主库上备份，那么备份期间都不能执行更新，业务基本上就要停摆。</p><p>&lt;2&gt;、如果在从库上备份，那么备份期间从库不能执行主库同步过来的二进制日志（binlog），而导致主从延迟。</p><p>在InnoDB引擎中，我们可以在备份时加上参数–single-transaction参数来完成不加锁的一致性数据备份。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --single-transcation -uroot -p123456 itcast &gt; itcast.sql</span><br></pre></td></tr></table></figure><h3 id="（二）表级锁"><a href="#（二）表级锁" class="headerlink" title="（二）表级锁"></a>（二）表级锁</h3><p>锁住整张表，锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><p><strong>&lt;1&gt;、表锁</strong></p><p>表共享读锁（read lock）</p><p>表独占写锁（write lock）<img src="https://img-blog.csdnimg.cn/7c9b4dc96e764c718bf787ec5a762def.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/7c9b4dc96e764c718bf787ec5a762def.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>加锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock tables 表名... read<span class="operator">/</span>write</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>释放锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables<span class="operator">/</span>客户端断开连接</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>&lt;2&gt;、元数据锁（meta data lock，MDL）</strong></p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了DML与DDL冲突，保证读写的正确性。</p><p>在MySQL5.5种引入了MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）。<img src="https://img-blog.csdnimg.cn/3ccc52bd34a24a509300f363dbb677b0.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/3ccc52bd34a24a509300f363dbb677b0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> SHARED_READ，SHARED_WRITE：共享锁，相互兼容，与EXCLUSIVE互斥。</p><p>EXCLUSIVE：排他，与其他MDL都互斥。</p><p>查看元数据锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">object_type,object_schema,object_name,lock_type,lock_duration </span><br><span class="line"><span class="keyword">FROM</span> performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>&lt;3&gt;、意向锁</strong></p><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p><p>意向共享锁（IS）：由语句select…lock in share mode添加。与表锁共享锁（read）兼容，与表锁排他锁（write）互斥。</p><p>意向排他锁（IX）：由insert、update、delete、select…for update添加。与表锁共享锁（read）和排他锁（write）都互斥。但是意向锁之间不会互斥。</p><p>查看意向锁及行锁的加锁情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">object_schema,object_name,index_name,lock_type,lock_data </span><br><span class="line"><span class="keyword">FROM</span> performance_schema.fate_locks;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="（三）行级锁"><a href="#（三）行级锁" class="headerlink" title="（三）行级锁"></a>（三）行级锁</h3><p>每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据时基于索引组织的，行锁时通过索引上的索引项加锁来实现的，而不是对记录加的锁，对于行级锁，主要分为以下三类：</p><p>1、行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此进行update和delete。在RC、RR隔离级别下都支持。</p><p>2、间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</p><p>3、临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</p><p><strong>行锁</strong></p><p>InnoDB实现了以下两种类型的行锁：</p><p>共享锁（S）：允许一个事务去读取一行，阻止其他事务获得相同数据集的排他锁。</p><p>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获取相同数据集的共享锁和排他锁。<img src="https://img-blog.csdnimg.cn/395c8a71f64742b6b57a0aa09494dabf.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/395c8a71f64742b6b57a0aa09494dabf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑<img src="https://img-blog.csdnimg.cn/08334d9b1dab422c9553cfa7fee668c7.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/08334d9b1dab422c9553cfa7fee668c7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> 默认情况下，InnoDB在REPEATABLE READ事务隔离级别允许，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</p><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，会自当优化为行锁。</p><p>InnoDB的行锁时针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</p><p><strong>间隙锁/临键锁</strong></p><p>间隙锁锁的是两个记录间的间隙，不包含数据记录，临键锁锁的是当前的数据记录和该数据之前的间隙。</p><p>默认情况下，InnoDB在REPEATABLE READ事务隔离级别允许，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</p><p>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。</p><p>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁。</p><p>索引上的范围查询（唯一索引）–会访问到不满足条件的第一个值为止。</p><p>间隙锁的唯一目的时防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql高级（二）</title>
      <link href="/2023/05/01/mysql-gao-ji-er/"/>
      <url>/2023/05/01/mysql-gao-ji-er/</url>
      
        <content type="html"><![CDATA[<h1 id="一、SQL优化"><a href="#一、SQL优化" class="headerlink" title="一、SQL优化"></a>一、SQL优化</h1><h3 id="（一）插入数据"><a href="#（一）插入数据" class="headerlink" title="（一）插入数据"></a>（一）插入数据</h3><p><strong>批量插入</strong></p><p>多次插入每一次insert都要与数据库建立连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (),(),();</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>一次插入数据不宜过多，不要超过1000条。</p><p><strong>手动提交事务</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (),(),();</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (),(),();</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (),(),();</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>主键顺序插入</strong></p><p><em><strong>*<img src="https://img-blog.csdnimg.cn/f4faf9f683b44cbd882555908cec34cf.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/f4faf9f683b44cbd882555908cec34cf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑*</strong></em> 主键顺序插入效率高于乱序插入。</p><p><strong>大批量插入数据</strong></p><p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。</p><p><img src="https://img-blog.csdnimg.cn/6f6e5796432f4f91a6b111ef0eb74523.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/6f6e5796432f4f91a6b111ef0eb74523.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看开关是否开启</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@local</span>_infile;</span><br><span class="line"><span class="comment">--开启开关</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> local_infile<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">--加载数据</span></span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INFILE <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="string">&#x27;表名&#x27;</span> FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> LINES TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="（二）主键优化"><a href="#（二）主键优化" class="headerlink" title="（二）主键优化"></a>（二）主键优化</h3><p><strong>数据组织方式：</strong>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表。<img src="https://img-blog.csdnimg.cn/4e7ffd686e8a4b54b1150093b5208d4f.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/4e7ffd686e8a4b54b1150093b5208d4f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> <strong>页分裂：</strong>页可以为空，也可以填充一半，也可以填充到100%。每个页包含了2-N行数据（如果一行数据足够大，会行溢出），根据主键排序。主键乱序插入时可能会发生。</p><p>****<img src="https://img-blog.csdnimg.cn/593d23ada4a84a598d218ce6e5ea1986.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/593d23ada4a84a598d218ce6e5ea1986.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑**页合并：**当删除一行记录时，实际上记录并没有被物理删除，只是被标记（flaged）为删除并且它的空间变的允许被其他记录声明使用。</p><p>当页中删除的记录达到MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定，在创建表和创建索引的时候可以自己指定。</p><p><strong>主键设计原则：</strong></p><p>满足业务需求的情况下，尽量降低主键的长度。</p><p>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</p><p>尽量不要使用UUID做主键或者是其他自然主键，如身份证号，无序，长度也较长。</p><p>业务操作时，避免对主键的修改。</p><h3 id="（三）order-by优化"><a href="#（三）order-by优化" class="headerlink" title="（三）order by优化"></a>（三）order by优化</h3><p><strong>Using filesort：</strong>通过表的索引或者全表扫描，读取满足条件的数据行，然后再排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的都叫FileSort排序。</p><p><strong>Using index：</strong>通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。</p><p><strong>Backward index scan：</strong>反向扫描索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--根据字段1，字段进行一个降序，一个升序</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段... <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> <span class="keyword">asc</span>,字段<span class="number">2</span> <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">--创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_字段<span class="number">1</span>_字段<span class="number">2</span>_ad <span class="keyword">ON</span> 表名(字段<span class="number">1</span> <span class="keyword">ASC</span>,字段<span class="number">2</span> <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>优化：</strong></p><p>根据排序字段创建合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>尽量使用覆盖索引。</p><p>多字段排序时，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</p><p>如果不可避免的出现filesort，大数据排序时，可以适当增大排序缓冲区的大小sort_buffer_size（默认256k）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;sort_buffer_size&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="（四）group-by优化"><a href="#（四）group-by优化" class="headerlink" title="（四）group by优化"></a>（四）group by优化</h3><p>Using temporary：用到了临时表。</p><p>分组操作时，建立适当索引来提高效率。</p><p>分组操作时，索引的使用也是满足最左前缀原则的。</p><h3 id="（五）limit优化"><a href="#（五）limit优化" class="headerlink" title="（五）limit优化"></a>（五）limit优化</h3><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询的方法优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> a.<span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span> a,(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> 表<span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT 开始,数量) b <span class="keyword">WHERE</span> a.id<span class="operator">=</span>b.id; </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="（六）count优化"><a href="#（六）count优化" class="headerlink" title="（六）count优化"></a>（六）count优化</h3><p>在MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高，前提是后面没有where条件。</p><p>InnoDB引擎在执行count(*)时，需要把数据一行行地从引擎里面读出来，然后累积计数。</p><p><strong>优化思路：</strong>没有特别好的优化方案，可以自己计数。</p><p><strong>用法：</strong>count(*)、count(主键)、count(字段)、count(1)</p><p><strong>count(主键)：</strong>InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加（主键值不可能为null）。</p><p><strong>count(字段)：</strong>InnoDB遍历整张表把每一行的字段值都取出来，返回给服务层。如果有not null约束，直接按行进行累加；如果没有not null约束，服务层判断是否为null，不为null，计数累加。</p><p><strong>count(1)：</strong>InnoDB引擎会遍历整张表，但不取值。服务层对于返回的每一行，都放一个数字“1”进去，直接按行进行累加。</p><p><strong>count(*)：</strong>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</p><p><strong>性能：</strong>count(*)~count(1)&gt;count(主键)&gt;count(字段)，尽量使用count( *)。</p><h3 id="（七）update优化"><a href="#（七）update优化" class="headerlink" title="（七）update优化"></a>（七）update优化</h3><p><strong>执行update语句的注意事项：</strong></p><p>在InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><h1 id="二、视图-存储过程-触发器"><a href="#二、视图-存储过程-触发器" class="headerlink" title="二、视图/存储过程/触发器"></a>二、视图/存储过程/触发器</h1><h3 id="（一）视图"><a href="#（一）视图" class="headerlink" title="（一）视图"></a>（一）视图</h3><p>视图是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p><p>视图不保存数据，只保存了SQL的逻辑。我们在创建视图时，主要的工作就在创建这条SQL查询语句上。</p><p><strong>创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列表列名)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span><span class="operator">|</span><span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION];</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>封装的就是select查询的数据。</p><p>WITH CASCADED CHECK OPTION：防止视图插入的数据不符合创建视图时的条件。</p><p><strong>视图的检查选项：</strong>当使用WITH CHECK自居创建视图时，MySQL会通过视图检查正在更改的每个行，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，他还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，MySQL提供了两个选项：CASCADED和LOCAL，默认值是LOCAL。</p><p>CASCADED：</p><p><img src="https://img-blog.csdnimg.cn/49fb0a0babbd472cbeb6cfcbab2194ce.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/49fb0a0babbd472cbeb6cfcbab2194ce.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>LOCAL：</p><p><strong>查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看创建视图语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br><span class="line"><span class="comment">--查看视图数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 视图名称...;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>视图是一种虚拟的表，可以像操作表一样操作视图。</p><p><strong>修改</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> 视图名称&#123;(列名列表)&#125; <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span><span class="operator">|</span><span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION];</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称&#123;(列名列表)&#125; <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span><span class="operator">|</span><span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION];</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>CREATE OR REPLACE：创建或替换。</p><p><strong>删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] 视图名称 [,视图名称]...;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>IF EXISTS：判断是否存在。</p><hr><hr><p><strong>视图的更新：</strong></p><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含一下任何一项，则该视图不可更新：</p><p>1、聚合函数或窗口函数（SUM()、MIN()、MAX()、COUNT()等）</p><p>2、DISTINCT</p><p>3、GROUP BY</p><p>4、HAVING</p><p>5、UNION或者UNION ALL</p><p><strong>作用：</strong></p><p>操作简单：视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p><p>安全：数据库可以授权，但不能授权到数据库特定的行和特定的列上。通过视图用户只能查询和修改他们能见到的数据。</p><p>数据独立：视图可以帮助用户屏蔽表真实结构变化带来的影响。</p><h3 id="（二）存储过程"><a href="#（二）存储过程" class="headerlink" title="（二）存储过程"></a>（二）存储过程</h3><p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><p>存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。  </p><p><strong>创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称([参数列表])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">--SQL语句</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>调用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 名称([参数]);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>查看</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询指定数据库的存储过程及状态信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.ROUTINES ROUTINE_SCHEMA<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"><span class="comment">--查询某个存储过程的定义</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> [IF <span class="keyword">EXISTS</span>] 存储过程名称;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意：在命令行执行sql时，一旦遇到分号，就认为SQL语句结束。所以在命令行中，执行创建存储过程的SQL时，需要通过delimiter关键字指定SQL语句的结束符。</p><hr><hr><p><strong>系统变量</strong></p><p>系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p><p>全局变量：针对所有会话有效。</p><p>会话变量：仅在当前会话内有效。</p><p><strong>查看系统变量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看所有系统变量(默认session级别)</span></span><br><span class="line"><span class="keyword">SHOW</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] VARIABLES;</span><br><span class="line"><span class="comment">--可以通过LIKE模糊匹配的方式查找变量</span></span><br><span class="line"><span class="keyword">SHOW</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;......&#x27;</span>;</span><br><span class="line"><span class="comment">--查看指定变量的值</span></span><br><span class="line"><span class="keyword">SELECT</span> @@[SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] 系统变量名;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>设置系统变量值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] 系统变量名<span class="operator">=</span>值；</span><br><span class="line"><span class="keyword">SET</span> @@[SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] 系统变量名<span class="operator">=</span>值；</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如果没有指定SESSION|GLOBAL，默认是SESSION，会话变量。</p><p>MySQL服务重新启动之后，所设置的全局参数会失效，要想不失效，可以再/etc/my.cnf中配置。</p><p><strong>用户自定义变量</strong></p><p>用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用”@变量名“使用就可以。其作用域为当前连接。</p><p><strong>赋值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@var</span>_name<span class="operator">=</span>expr[,<span class="variable">@var</span>_name<span class="operator">=</span>expr]...;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@var</span>_name:<span class="operator">=</span>expr[,<span class="variable">@var</span>_name:<span class="operator">=</span>expr]...;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@var</span>_name:<span class="operator">=</span>expr[<span class="variable">@var</span>_name:<span class="operator">=</span>expr]...;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> <span class="variable">@var</span>_name <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>使用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@var</span>_name;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为NULL。</p><p><strong>局部变量</strong></p><p>局部变量是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN···END块。</p><p><strong>声明</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 变量名 变量类型[DEFAULZT...];</span><br><span class="line"><span class="comment">--变量类型就是数据库字段类型：INT,CHAR,VACHAR等。</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>赋值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> 变量名<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">SET</span> 变量名:<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表名...;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><hr><hr><p><strong>if条件判断</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF 条件<span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">...</span><br><span class="line">ELSEIF 条件<span class="number">2</span> THRN<span class="comment">--可选</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span><span class="comment">--可选</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>case选择</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--语法一</span></span><br><span class="line"><span class="keyword">CASE</span> case_value</span><br><span class="line"><span class="keyword">WHEN</span> when_value1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">[<span class="keyword">WHEN</span> when_value2 <span class="keyword">THEN</span> statement_list2]...</span><br><span class="line">[<span class="keyword">ELSE</span> statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"><span class="comment">--语法二</span></span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> search_condition1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">[<span class="keyword">WHEN</span> search_conition2 <span class="keyword">THEN</span> statement_list2]...</span><br><span class="line">[<span class="keyword">ELSE</span> statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>while循环</strong></p><p>满足条件进行循环，先判断条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE 条件 DO</span><br><span class="line"><span class="keyword">SQL</span>逻辑...</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>repeat循环</strong></p><p>满足条件推出循环，先执行一次逻辑，再判断条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REPEAT</span><br><span class="line"><span class="keyword">SQL</span>逻辑...</span><br><span class="line">UNTIL 条件</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>loop循环</strong></p><p>如果不在SQL逻辑中增加退出循环的语句，就是死循环。loop可以配合以下两个语句使用：</p><p>（1）LEAVE：配合循环使用，退出循环。</p><p>（2）ITERATE：跳过剩下的语句，直接进入下一次循环。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:]LOOP</span><br><span class="line"><span class="keyword">SQL</span>逻辑...</span><br><span class="line"><span class="keyword">END</span> LOOP[end_label];</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><hr><hr><p><strong>存储过程参数</strong></p><table><thead><tr><th>类型</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>IN</td><td>该类参数作为输入，也就是需要调用时传入值</td><td>默认</td></tr><tr><td>OUT</td><td>该类参数作为输出，也就是该参数可以作为返回值</td><td></td></tr><tr><td>INOUT</td><td>既可以作为输入参数，也可以作为输出参数</td><td></td></tr></tbody></table><p><strong>用法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CTEATE <span class="keyword">PROCEDURE</span> 存储过程名称([<span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> 参数名 参数类型])</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="comment">--SQL语句</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><hr><hr><p><strong>游标</strong></p><p>游标时用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结构及进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH和CLOSE，其语法分别如下。</p><p><img src="https://img-blog.csdnimg.cn/677b724fe8f64d1fbee916a3c96c0ccf.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/677b724fe8f64d1fbee916a3c96c0ccf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><strong>声明游标</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 游标 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>打开游标</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> 游标名称;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>获取游标记录</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> 游标名称 <span class="keyword">INTO</span> 变量[,变量];</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><hr><hr><p><strong>条件处理程****序</strong></p><p>条件处理程序可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> handler_action HANDLER <span class="keyword">FOR</span> condition_value [,condition_value]... statement;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>handler_action：</p><p>CONTINUE：继续执行当前程序。</p><p>EXIT：终止执行当前程序。</p><p>condition_value：</p><p>SQLSTATE sqlstate_value：状态码，如02000。</p><p>SQLWARNING：所有以01开头的SQLSTATE代码的简写。</p><p>NOT FOUND：所有以02开头的SQLSTATE代码的简写。</p><p>SQLEXCEPTION：所有没有被SQLWARNING或NOT FOUND捕获的SQL STATE代码的简写。</p><h3 id="（三）存储函数"><a href="#（三）存储函数" class="headerlink" title="（三）存储函数"></a>（三）存储函数</h3><p>存储函数是由返回值的存储过程，存储函数的参数只能是IN类型，具体语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 存储函数名称([参数列表])</span><br><span class="line"><span class="keyword">RETURNS</span> type [characteristic...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">--SQL语句</span></span><br><span class="line">RETURN...;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>characteristic说明：</p><p>DETERMINSTIC：相同的输入参数总是产生相同的结果。</p><p>NO SQL：不包含SQL语句。</p><p>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</p><h3 id="（四）触发器"><a href="#（四）触发器" class="headerlink" title="（四）触发器"></a>（四）触发器</h3><p>触发器是与表有关的数据库对象，在insert/update/delete之前或者之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p><p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><p>**<em>*<img src="https://img-blog.csdnimg.cn/bcf5389ce87b4383a3b7913ad582a848.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/bcf5389ce87b4383a3b7913ad582a848.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑*<em>创建</em></em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">BEFORE<span class="operator">/</span>AFTER <span class="keyword">INSERT</span><span class="operator">/</span><span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">ON</span> tbl_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="comment">--行级触发器</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">trigger_stmt;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>查看</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [schema_name.]trigger_name;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql高级（一）</title>
      <link href="/2023/04/20/mysql-gao-ji-yi/"/>
      <url>/2023/04/20/mysql-gao-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、存储引擎"><a href="#一、存储引擎" class="headerlink" title="一、存储引擎"></a>一、存储引擎</h1><h2 id="（一）Mysql体系结构"><a href="#（一）Mysql体系结构" class="headerlink" title="（一）Mysql体系结构"></a>（一）Mysql体系结构</h2><p><img src="https://img-blog.csdnimg.cn/a217ede77aed49f481f4684a8a43fc76.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/a217ede77aed49f481f4684a8a43fc76.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><strong>连接层 ：</strong>接收客户端连接，完成连接处理，以及认证授权的相关的安全方案。</p><p><strong>服务层：</strong>绝大部分的核心功能都在服务层，所有跨存储引擎的实现都在服务层，如SQL接口，并完成缓存查询，SQL的分析和优化。</p><p><strong>引擎层：</strong>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同存储引擎索引结构不一样。</p><p><strong>存储层：</strong>存储数据库的相关数据，日志，索引，错误日志等。</p><h2 id="（二）存储引擎简介"><a href="#（二）存储引擎简介" class="headerlink" title="（二）存储引擎简介"></a>（二）存储引擎简介</h2><p>存储引擎是存储数据，建立索引，更新/查询数据等技术的实现方式。存储引擎是基于表的，所以存储引擎也可被称为表类型。</p><p><img src="https://img-blog.csdnimg.cn/8bd9646e23734fb8a86252333af2cd85.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/8bd9646e23734fb8a86252333af2cd85.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>可以在创建表的时候指定存储引擎，mysql5.5之后默认存储引擎InnoDB。</p><p> 查询数据库支持的存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/935db810eb4b4ff8a0303ccc9bec1544.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/935db810eb4b4ff8a0303ccc9bec1544.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h2 id="（三）存储引擎特点"><a href="#（三）存储引擎特点" class="headerlink" title="（三）存储引擎特点"></a>（三）存储引擎特点</h2><h3 id="MEMORY："><a href="#MEMORY：" class="headerlink" title="MEMORY："></a><strong>MEMORY：</strong></h3><p>表数据存储在内存中，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表。</p><p><strong>特点：</strong></p><p>内存存放，访问速度比较快</p><p>支持hash索引（默认）</p><p><strong>文件：</strong></p><p>xx.sdi：存储表结构信息</p><h3 id="InnoDB："><a href="#InnoDB：" class="headerlink" title="InnoDB："></a>InnoDB：</h3><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，Mysql5.5之后的默认存储引擎。</p><p><strong>特点：</strong></p><p>DML操纵遵循ACID模型，支持事务；</p><p>行级锁，提高并发访问性能；</p><p>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</p><p><strong>文件</strong></p><p>xxx.ibd：xxx是表名，InnoDB的每张表都对应一个表空间文件，存储该表的表结构f(frm,sdi)，数据和索引。</p><p><strong>参数：</strong>innodb_file_per_table（每一张表都对应一个表文件，默认打开）</p><p><img src="https://img-blog.csdnimg.cn/a264fea9cbe84fef83dabbf42a06a4e9.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/a264fea9cbe84fef83dabbf42a06a4e9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h3 id="MyISAM："><a href="#MyISAM：" class="headerlink" title="MyISAM："></a><strong>MyISAM：</strong></h3><p> Mysql早期默认存储引擎。</p><p><strong>特点：</strong></p><p>不支持事务，不支持外键；</p><p>支持表锁，不支持行锁；</p><p>访问数据快；</p><p><strong>文件：</strong></p><p>xxx.MYI：存储索引</p><p>xxx.MYD：存储数据</p><p>xxx.sdi：存储表结构信息</p><p><img src="https://img-blog.csdnimg.cn/c368d439a68a47f281d047c3c1a0bff2.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/c368d439a68a47f281d047c3c1a0bff2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h2 id="（四）存储引擎选择"><a href="#（四）存储引擎选择" class="headerlink" title="（四）存储引擎选择"></a>（四）存储引擎选择</h2><p>InnoDB：如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，包含很多更新、删除操作，那么Innodb是比较合适的选择。绝大场景选择的是InnoDB。</p><p>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不能很高，那么选择这个存储引擎是非常合适的。例如：日志相关，服务器和评论相关数据。经常用nosql系列数据库替代。</p><p>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保证数据的安全性。经常用nosql系列数据库替代，例如redis。</p><h1 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h1><h2 id="（一）索引概述"><a href="#（一）索引概述" class="headerlink" title="（一）索引概述"></a>（一）索引概述</h2><p>索引（index）帮助mysql高效获取数据的数据结构（有序）。在原始数据之外，数据库还要维护索引这种的数据结构，通过这种数据结构指向数据。</p><p>无索引会全表扫描，有索引效率会比较高效。</p><p><strong>优点：</strong></p><p>提高查询效率，降低数据的IO成本。</p><p>通过索引列队数据进行排序，会降低数据排序的成本，降低CPU的消耗</p><p><strong>缺点：</strong></p><p>索引列也是要占空间的。</p><p>索引降低了更新表的速度，insert、update、delete。</p><h2 id="（二）索引结构"><a href="#（二）索引结构" class="headerlink" title="（二）索引结构"></a>（二）索引结构</h2><p>不同的存储引擎有不同的索引结构。</p><p>B+Tree索引：最常见的索引类型，大部分存储引擎都支持B+树索引。</p><p>Hash索引：底层数据结构用哈希表实现，性能很高，但不支持范围查询。</p><p>R-tree（空间索引）：是MyISAM引擎的一个特殊索引，主要用于地理空间数据类型，使用较少。</p><p>Full-text（全文索引）:是一种通过建立倒排索引，快速匹配文档的方式。使用较少。</p><p><img src="https://img-blog.csdnimg.cn/8b77a8b0d67b4569a1ffb3407b67fc00.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/8b77a8b0d67b4569a1ffb3407b67fc00.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>默认索引是B+Tree索引。</p><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a><strong>B+Tree索引</strong></h3><p><strong>二叉树：</strong>顺序插入时，会形成一个链表，查询性能大大降低。二叉树只有两个子节点，大数据量情况下，层级较深，索引速度慢。</p><p><strong>红黑树：</strong>可以解决形成一个链表的问题，但也只有两个子节点，大数据量情况下，层级较深，索引速度慢。</p><p><strong>B-Tree（多路平衡查询树）：</strong>可以避免层级较深的缺点</p><p><img src="https://img-blog.csdnimg.cn/9dc027e6781249cc9dc76329911a0a7e.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/9dc027e6781249cc9dc76329911a0a7e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> <strong>B+Tree：</strong>相对于B-Tree，B-Tree一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低。而且B+Tree树搜索效率稳定，叶子节点形成双向链表，便于范围搜索和排序。</p><p>分叶子节点起到索引的作用，所有元素都会出现在叶子节点。</p><p>叶子节点中间形成一个单向链表。</p><p><img src="https://img-blog.csdnimg.cn/49cf020e0f1c4f0a9cd0617763bde498.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/49cf020e0f1c4f0a9cd0617763bde498.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>Mysql中对经典的B+Tree进行了优化。在原B+Tree的基础上，增加了一个指向相邻叶子节点的链表指针，形成 了带指针的B+Tree，提高区间访问性能，利于数据库数据的排序。</p><p><img src="https://img-blog.csdnimg.cn/8ebe38e12b26415dafcce7ae20fd4f85.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/8ebe38e12b26415dafcce7ae20fd4f85.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a><strong>Hash索引</strong></h3><p>采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p><p>如果产生了hash冲突，可以通过链表来解决。</p><p><img src="https://img-blog.csdnimg.cn/059312f5a09f433dae738fe863f88858.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/059312f5a09f433dae738fe863f88858.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><strong>特点：</strong></p><p>只能使用等值比较（=，in），不支持范围查询（between，&gt;，&lt;，···）；</p><p>无法使用索引完成排序操作</p><p>查询效率高，通常只需要一次检索就行了，效率通常高于B+Tree索引。</p><p><strong>存储引擎支持：</strong></p><p>Memory引擎，但InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动创建的。</p><h2 id="（三）索引分类"><a href="#（三）索引分类" class="headerlink" title="（三）索引分类"></a>（三）索引分类</h2><p><strong>主键索引</strong></p><p>针对表中主键创建的索引，默认自动创建，只能有一个，primary</p><p><strong>唯一索引</strong></p><p>避免同一表中某数据列的值重复，可以有多个，unique</p><p><strong>常规索引</strong></p><p>快速定位特定数据，可以有多个</p><p><strong>全文索引</strong></p><p>全文索引查找的是文本中的关键字，而不是索引当中的值，可以有多个，fulltext</p><h3 id="在InnoDB中，根据索引存储形式，又分为："><a href="#在InnoDB中，根据索引存储形式，又分为：" class="headerlink" title="在InnoDB中，根据索引存储形式，又分为："></a><strong>在InnoDB中，根据索引存储形式，又分为：</strong></h3><p><strong>聚集索引</strong></p><p>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据，必须有，而且只有一个。</p><p>聚集索引选取规则：</p><p>如果存在主键，主键索引就是聚集索引。</p><p>如果不存在主键，将使用第一个唯一索引作为聚集送印。</p><p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p><p><strong>二级索引</strong></p><p>将数据和索引分开存储，索引结构的叶子节点关联的是对应的主键，可以存在多个。</p><p><img src="https://img-blog.csdnimg.cn/231e9a86385d405ea553caa00e879a7b.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/231e9a86385d405ea553caa00e879a7b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><strong>回表查询：</strong>先到二级索引中拿到对应主键值，再根据主键值到聚集索引中拿到对应行数据。</p><h2 id="（四）索引语法"><a href="#（四）索引语法" class="headerlink" title="（四）索引语法"></a>（四）索引语法</h2><p><strong>创建索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT] INDEX index_name <span class="keyword">ON</span> table_name(index_col_name,...);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>查看索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>删除索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="（五）SQL性能分析"><a href="#（五）SQL性能分析" class="headerlink" title="（五）SQL性能分析"></a>（五）SQL性能分析</h2><p>主要优化查询语句。</p><h3 id="SQL执行频率"><a href="#SQL执行频率" class="headerlink" title="SQL执行频率"></a><strong>SQL执行频率</strong></h3><p>MySQL客户端连接成功后，通过show [session|global] status命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;COM_______&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a><strong>慢查询日志</strong></h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，默认10s）的所有SQL语句的日志。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>MySQL的慢查询日志是默认不开启的，需要在MySQL的配置文件（/ect/my.cnf）中配置如下信息：</p><p><img src="https://img-blog.csdnimg.cn/d78a3800823f4eafbcc56c1501b27341.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/d78a3800823f4eafbcc56c1501b27341.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> 配置完毕之后，重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息：/var/lib/mysql/localhost-slow.log。</p><h3 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a><strong>profile详情</strong></h3><p>show profiles 能够在做SQL优化是帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@have</span>_profiling;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>默认profiling开关是关闭的，可以通过set语句在session/global级别开启profiling：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@profiling</span>;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="variable">@have</span>_profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>查询执行效率</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看每一条SQL的耗时基本情况</span></span><br><span class="line"><span class="keyword">SHOW</span> PROFILES;</span><br><span class="line"><span class="comment">--查看指定query_id的SQL语句各个阶段的耗时情况</span></span><br><span class="line"><span class="keyword">SHOW</span> PROFILE <span class="keyword">FOR</span> QUERY query_id;</span><br><span class="line"><span class="comment">--查看指定query_id的SQL语句CPU的使用情况</span></span><br><span class="line"><span class="keyword">SHOW</span> PROFILE CPU <span class="keyword">FOR</span> QUERY query_id;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a><strong>explain执行计划</strong></h3><p>EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--直接在SELECT语句之前加上关键字explain/desc</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/2f94ebe9709e4581a197cd99a342ef67.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/2f94ebe9709e4581a197cd99a342ef67.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> <strong>id：</strong>select查询的序列号，表示查询中执行的select自居或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</p><p><strong>select_type：</strong>表示SELECT的类型，常见的取值有SIMPLE（简单表，既不用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQERY（SELECT/WHERE之后包含了子查询）等.</p><p><strong>type：</strong>表示连接类型，性能由好到差的连接类型为NULL(不太可能出现NULL，当不访问表的时候会出现NULL)、system(访问一张系统表)、const(根据主键或者唯一索引访问一般会出现)、eq_ref、ref（非唯一性的索引访问时一般会出现）、range、index、all（全表扫描，性能很低）。</p><p><strong>possible_key：</strong>显示可能应用的索引，一个或多个。</p><p><strong>key：</strong>实际使用的索引，如果为NULL，则没有使用索引。</p><p><strong>key_len：</strong>表示索引中使用的字节数，该值为索引字段的最大可能长度，并非实际使用的长度，在不损失精确性的前提下，长度越短越好。</p><p><strong>rows：</strong>MySQL认为必须要执行的查询行数，在InnoDB引擎中的表中，是一个估计值，可能并不总是精确的。</p><p><strong>filtered：</strong>表示返回结果的行数占需要读取行数的百分比，filtered的值越大越好。</p><p><strong>Extra：</strong>格外的值。</p><h2 id="（六）索引使用"><a href="#（六）索引使用" class="headerlink" title="（六）索引使用"></a>（六）索引使用</h2><p><strong>最左前缀法则：</strong>如果索引使用了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳过某一列，索引将部分失效（后面的字段索引失效）。</p><p><strong>范围查询：</strong>联合索引中，出现范围查询（&gt;，&lt;）范围查询右侧的列索引失效。</p><p>规避：在业务允许的情况下，尽量使用（&gt;=，&lt;=）。</p><p><strong>索引列运算：</strong>不要在索引列上进行运算操作，索引将失效。</p><p><strong>字符串不加引号：</strong>字符串类型字段使用时，不加单引号，索引将失效。</p><p><strong>模糊查询：</strong>如果仅仅时尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p><strong>or连接的条件：</strong>用or分开的条件，如果or前的条件中的列中有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><p><strong>数据分布影响：</strong>如果MySQL评估使用索引会比全表更慢，则不使用索引。</p><p><strong>SQL提示：</strong>SQL提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些认为的提示来达到优化操作的目的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--USE INDEX：建议使用</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 USE INDEX(索引名)...;</span><br><span class="line"><span class="comment">--IGNORE INDEX：忽略用哪个索引</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 IGNORE INDEX(索引名)...;</span><br><span class="line"><span class="comment">--FORCE INDEX：强制使用</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 FOECE INDEX(索引名)...;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>覆盖索引：</strong>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经能够全部找到），减少使用select *。</p><p>using index condition：查找使用了索引，但是需要回表查询数据。</p><p>using where;using index：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据。</p><p><strong>前缀索引：</strong>当字段类型为字符串（varchar、text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以将字符串的一部分前缀，建立索引吗，这样可以大大节约索引空间，从而提高索引效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_XXX <span class="keyword">ON</span> table_name(<span class="keyword">column</span>(n));</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高查询效率越高。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--求取选择性</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> 字段名)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">SUBSTRING</span>(字段名,<span class="number">1</span>,<span class="number">5</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>单列索引与联合索引</strong></p><p>单列索引：即一个索引只包含单个列。</p><p>联合索引：即一个索引包含了多个列。</p><p>在业务场景中，如果存在多个查询条件，考虑针对查询字段建立索引时，建议建立联合索引，而非单列索引。</p><h2 id="（七）索引设计原则"><a href="#（七）索引设计原则" class="headerlink" title="（七）索引设计原则"></a>（七）索引设计原则</h2><p>1，针对于数据量较大（超100多万），且查询比较频繁的表建立索引。</p><p>2，针对于常用于查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p><p>3，尽量选择区分度高的列作为索引（例如身份证号），尽量建立唯一索引，区分度越高，使用索引的效率越高。</p><p>4、如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p><p>5、尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖，节省存储空间，避免回表，提高查询效率。</p><p>6、要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p><p>7、如果索引列不能存储NULL值，请在创建表时用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-Java并发机制的底层实现原理</title>
      <link href="/2023/04/08/bing-fa-java-bing-fa-ji-zhi-de-di-ceng-shi-xian-yuan-li/"/>
      <url>/2023/04/08/bing-fa-java-bing-fa-ji-zhi-de-di-ceng-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>它在多处理器开发中保证了共享变量的“可见性”。</p><p>可见性的意思是当一个线程修改一个共享变量时，另一个线程可以读到这个修改的值。</p><p>volatile比synchronized的使用和执行成本更低，因为它不会引起线程上下文切换和调度。</p><h3 id="volatile实现原理："><a href="#volatile实现原理：" class="headerlink" title="volatile实现原理："></a><strong>volatile实现原理：</strong></h3><p>在生成汇编代码时会在volatile变量修饰的共享变量进行写操作的时候会多出Lock前缀的指令。Lock前缀的指令在多核处理器下会引发两件事情：</p><p>（1）将当前处理器的缓存行的数据写回到系统内存。</p><p>（2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</p><p>多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，就会重新从系统内存读取数据到处理器缓存里。</p><p><strong>volatile两条实现原则：</strong></p><p>（1）Lock前缀指令会引起处理器缓存回写到内存。</p><p>（2）一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</p><h3 id="volatile的使用优化："><a href="#volatile的使用优化：" class="headerlink" title="volatile的使用优化："></a><strong>volatile的使用优化：</strong></h3><p>著名Java并发编程大师Doug lea在JDK7的并发包里新增一个队列集合类linkedTransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。</p><p>内部类PaddedAtomicReference相对于父类AtomicReference只做了一件事情，就是将共享变量追加到64字节。</p><p><strong>为什么追加到64字节能够提高并发编程的效率呢？</strong></p><p>很多处理器的L1，L2或L3缓存的高速缓存行是64个字节宽，不支持填充缓存行。如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都读取到同一个高速缓存行中。当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点。而队列的入队和出队操作则需要不停修改头节点和尾节点。所以在多处理器的情况下会严重影响到队列的入队和出队效率。Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一缓存行，使头、尾节点在修改时不会互相锁定。</p><p><strong>在什么情况下使用volatile时不应该追加到64字节？</strong></p><p>（1）缓存行非64字节宽的处理器。</p><p>（2）共享变量不会被频繁地写。</p><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>对于普通同步方法，锁是当前实例对象。</p><p>对于静态同步方法，锁是当前类的Class对象。</p><p>对于同步方法块，锁是Synchronized括号里配置的对象。</p><h3 id="Java对象头："><a href="#Java对象头：" class="headerlink" title="Java对象头："></a><strong>Java对象头：</strong></h3><p>synchronized用的锁是存在Java对象头里的。</p><p>Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。</p><p><strong>Mark Word</strong></p><p>32位JVM的Mark Word的默认存储结构。</p><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit是否是偏向锁</th><th>2bit锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象的HashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr></tbody></table><p>运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据。</p><table><thead><tr><th>锁状态</th><th>25bit</th><th></th><th>4bit</th><th>1bit</th><th>2bit</th></tr></thead><tbody><tr><td></td><td>23bit</td><td>2bit</td><td></td><td>是否是偏向锁</td><td>锁标志位</td></tr><tr><td>轻量级锁</td><td>指向栈中-</td><td>锁-</td><td>记录的</td><td>指针</td><td>00</td></tr><tr><td>重量级锁</td><td>指向-</td><td>互斥量-</td><td>（重量级锁）的</td><td>指针</td><td>10</td></tr><tr><td>GC标记</td><td>空-</td><td>-</td><td></td><td></td><td>11</td></tr><tr><td>偏向锁</td><td>线程ID</td><td>Epoch</td><td>对象分代年龄</td><td>1</td><td>01</td></tr></tbody></table><p>64位虚拟机，MarkWord是64bit大小的，其存储结构如表。</p><table><thead><tr><th>锁状态</th><th>25bit</th><th>31bit</th><th>1bit</th><th>4bit</th><th>1bit</th><th>2bit</th></tr></thead><tbody><tr><td></td><td></td><td></td><td>cms_free</td><td>分代年龄</td><td>偏向锁</td><td>锁标志位</td></tr><tr><td>无锁</td><td>unused</td><td>hashCode</td><td></td><td></td><td>0</td><td>01</td></tr><tr><td>偏向锁</td><td>Thread(54-</td><td>bit)Epoch(2bit)</td><td></td><td></td><td>1</td><td>01</td></tr></tbody></table><h3 id="偏向锁和轻量级锁："><a href="#偏向锁和轻量级锁：" class="headerlink" title="偏向锁和轻量级锁："></a>偏向锁和轻量级锁：</h3><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了”偏向锁“和”轻量级锁“。</p><p>在Java SE 1.6种，锁一共有4种状态，级别低到高：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。</p><p>锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。</p><p><strong>偏向锁的获取</strong></p><p>当一个线程访问同步块并获得锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象的偏向锁指向当前线程。</p><p><strong>偏向锁的撤销</strong></p><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等到全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p><p><strong>关闭偏向锁</strong></p><p>偏向锁在Java6和Java7中里是默认启用的，它在应用程序启动几秒钟后才激活。</p><p>JVM参数关闭延迟：-XX:BiasedLockingStartupDelay=0。</p><p>JVM参数关闭偏向锁：-XX:UseBiasedLocking=false。</p><p><strong>轻量级锁加锁</strong></p><p>线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><p><strong>轻量级锁解锁</strong></p><p>轻量级解锁时，会使用原子的CAS操作将DIsplaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-并发编程的挑战</title>
      <link href="/2023/04/02/bing-fa-bing-fa-bian-cheng-de-tiao-zhan/"/>
      <url>/2023/04/02/bing-fa-bing-fa-bian-cheng-de-tiao-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="同步VS异步"><a href="#同步VS异步" class="headerlink" title="同步VS异步"></a>同步VS异步</h2><p>同步和异步用来形容一次方法调用。</p><p><strong>同步：</strong>同步方法调用一开始，调用者必须等待被调用的方法结束后，调用者后面的代码才能执行。</p><p><strong>异步：</strong>异步调用指的是，调用者不管被调用的方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。</p><h2 id="并发VS并行"><a href="#并发VS并行" class="headerlink" title="并发VS并行"></a>并发VS并行</h2><p><strong>并发：</strong>指多个任务交替执行</p><p><strong>并行：</strong>真正意义上的“同时运行”。</p><p>实际上，系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。</p><h2 id="阻塞VS非阻塞"><a href="#阻塞VS非阻塞" class="headerlink" title="阻塞VS非阻塞"></a>阻塞VS非阻塞</h2><p>阻塞和非阻塞通常用来形容多线程间的相互影响。</p><p><strong>阻塞：</strong>一个线程占有了临界区资源，那么其他线程需要这个资源就必须进行等待该资源的释放，会导致等待的线程挂起。</p><p><strong>非阻塞：</strong>没有一个线程可以阻塞其他线程，所有的线程都会尝试地前行。</p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。</p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p><strong>优点：</strong></p><p>1、并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升。</p><p>2、面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分。</p><p><strong>缺点：</strong>并发编程的目的是为了让程序运行的更快，但是也会造成一些问题：上下文切换，线程安全</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。因为时间片非常短，所以CPU通过不断地切换线程执行，让我们感觉多个线程是同时执行的。</p><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p><p><strong>多线程一定快吗？</strong></p><p>不一定，因为线程有创建和上下文切换的开销。</p><p><strong>如何减少上下文切换？</strong></p><p>1、无锁并发编程。可以参考concurrentHashMap锁分段的思想，不同线程处理不同段的数据，这样在多线程竞争条件下，可以减少上下文切换的时间。</p><p>2、CAS算法。利用Atomic下使用CAS算法来更新数据，使用了乐观锁，可以有效减少一部分不必要的锁竞争带来的上下文切换。</p><p>3、使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态。</p><p>4、协程。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>一旦产生死锁，就会造成系统功能的不可用。</p><p><strong>模拟死锁的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DeadLockDemo</span>().deadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deadLock</span><span class="params">()</span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//对A加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span>(A)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 get resource A&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//睡眠一段时间，让t2先获取到B</span></span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//尝试获取B，对B加锁，因为t2一直在尝试获取A，一直不释放B，所以t1获取不到B</span></span><br><span class="line">                    <span class="keyword">synchronized</span>(B)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;t1 get resource B&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//对B加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (B)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 get resource B&quot;</span>);</span><br><span class="line">                    <span class="comment">//获取A，对A加锁，因为t1一直在尝试获取B，没有获取到一直未执行结束，不释放A，所以t2不会获取到A</span></span><br><span class="line">                    <span class="keyword">synchronized</span>(A)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;t2 get resource A&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>避免死锁常用的方法：</strong></p><p>1、避免一个线程同时获取多个锁。</p><p>2、避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</p><p>3、尝试使用定时锁，使用lock.tryLock(timeout)来代替使用内部锁机制。</p><p>4、对数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC-共享模型之内存</title>
      <link href="/2023/03/26/juc/"/>
      <url>/2023/03/26/juc/</url>
      
        <content type="html"><![CDATA[<h3 id="JMM体现在以下几个方面"><a href="#JMM体现在以下几个方面" class="headerlink" title="JMM体现在以下几个方面"></a><strong>JMM体现在以下几个方面</strong></h3><p>原子性-保证指令不会受到线程上下文切换的影响</p><p>可见性-保证指令不会受cpu缓存的影响</p><p>有序性-保证指令不会受cpu指令并行优化的影响</p><h3 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a><strong>可见性：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;JC&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JC</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> run=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (run)&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;停止t&quot;</span>);</span><br><span class="line">        run=<span class="literal">false</span>; <span class="comment">//线程t并不会停止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始状态，t线程刚开始从主内存中读取run到自己的工作内存。</p><p>JIT编译器将run缓存到工作内存的高速缓存中，减少对主内存中run的访问，提高效率。</p><p><strong>解决办法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> run=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>volatile（易变关键字）</p><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存。</p><h3 id="两阶段终止模式，Balking模式"><a href="#两阶段终止模式，Balking模式" class="headerlink" title="两阶段终止模式，Balking模式"></a>两阶段终止模式，Balking模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Thread monitorThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> stop=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">rivate <span class="keyword">volatile</span> <span class="type">boolean</span> starting=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(starting)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        starting=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    monitorThread=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stop)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;执行监控记录&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;monitor&quot;</span>);</span><br><span class="line">    monitorThread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">    stop=<span class="literal">true</span>;</span><br><span class="line">    starting=<span class="literal">false</span>;</span><br><span class="line">    monitorThread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序性-指令重排序优化"><a href="#有序性-指令重排序优化" class="headerlink" title="有序性-指令重排序优化"></a>有序性-指令重排序优化</h3><p>指令重排的前提是，重排指令不能影响结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> ready=<span class="literal">false</span>; </span><br><span class="line"><span class="comment">//volatile boolean ready=false;禁止重排序，防止之前的指令被重排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready)&#123;</span><br><span class="line">        r.r1=num+num;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//结束时r1结果可能会出现0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span>&#123;</span><br><span class="line">    num=<span class="number">2</span>;</span><br><span class="line">    ready=<span class="literal">true</span>;<span class="comment">//重排序可能将两个语句调换位置执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中。</p><p>读屏障（lfence）保证在该屏障之后的，对共享变量的读取，加载的是主存中最新数据。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中位数为key的子序列</title>
      <link href="/2023/03/19/he-wei-k/"/>
      <url>/2023/03/19/he-wei-k/</url>
      
        <content type="html"><![CDATA[<h1 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">和为 K 的子数组</a></h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的连续子数组的个数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-107 &lt;= k &lt;= 107</code></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">​    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">​    map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> sum[i], d = t - k;</span><br><span class="line"></span><br><span class="line">​      ans += map.getOrDefault(d, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">​      map.put(t, map.getOrDefault(t, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>利用前缀和的思想，求出每一个元素到第一个元素的和，两个元素前缀和相减就是两个元素之间所有元素的和。</p><p>1、定义一个数组，用于存储所有元素的前缀和。</p><p>2、定义map集合，以前缀和为key</p><p>3、遍历sum，如果map中有（当前前缀和-k）为key的元素，就使得结果加上该key的value。再将当前元素前缀和存入map集合，如果不存在就存入0，存在就加一。</p><h1 id="统计中位数为-K-的子数组"><a href="#统计中位数为-K-的子数组" class="headerlink" title="统计中位数为 K 的子数组"></a><a href="https://leetcode.cn/problems/count-subarrays-with-median-k/">统计中位数为 K 的子数组</a></h1><p>给你一个长度为 <code>n</code> 的数组 <code>nums</code> ，该数组由从 <code>1</code> 到 <code>n</code> 的 <strong>不同</strong> 整数组成。另给你一个正整数 <code>k</code> 。</p><p>统计并返回 <code>nums</code> 中的 <strong>中位数</strong> 等于 <code>k</code> 的非空子数组的数目。</p><p><strong>注意：</strong></p><ul><li>数组的中位数是按递增顺序排列后位于中间的那个元素，如果数组长度为偶数，则中位数是位于中间靠左的那个元素。<ul><li>例如，<code>[2,3,1,4]</code> 的中位数是 <code>2</code> ，<code>[8,4,3,5,1]</code> 的中位数是 <code>4</code> 。</li></ul></li><li>子数组是数组中的一个连续部分。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,4,5], k = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：中位数等于 4 的子数组有：[4]、[4,5] 和 [1,4,5] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1], k = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：[3] 是唯一一个中位数等于 3 的子数组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= nums[i], k &lt;= n</code></li><li><code>nums</code> 中的整数互不相同</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> t=n+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[pos] != k) ++pos;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;k)&#123;</span><br><span class="line">                count+=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;k)&#123;</span><br><span class="line">                count+=-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                count+=t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=pos)&#123;</span><br><span class="line">                res+=map.getOrDefault(count-t,<span class="number">0</span>);</span><br><span class="line">                res+=map.getOrDefault(count-t-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(count,map.getOrDefault(count,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这个思路和上面那道题思路差不多，求中位数为k的子序列，可以将大于k的元素都设为1，小于k的元素都设为-1，将等于k的元素都设为t，和为t或者t+1的序列排序后中位数就为key。注意t要大于序列的长度，否则当为一的元素多的话和也会为t。</p><p>1、遍历数组，找到值为k的元素的下标。</p><p>2、声明一个map，以前缀和为key，该前缀和出现的次数为value。</p><p>3、遍历数组，当元素大于k时前缀和加一，小于时加0，等于时加t。</p><p>4、进行比较，如果当前元素下标小于所找的元素下标，证明该元素前面所有子序列没有k出现，直接将前缀和存入map加一就行。如果大于所找元素下标，寻找有没有符合当前前缀和-t的map，将结果加上该key的value。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杨辉三角（算法）</title>
      <link href="/2023/03/11/yang-hui-san-jiao/"/>
      <url>/2023/03/11/yang-hui-san-jiao/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="链接：https-www-lanqiao-cn-problems-1457-learning"><a href="#链接：https-www-lanqiao-cn-problems-1457-learning" class="headerlink" title="链接：https://www.lanqiao.cn/problems/1457/learning/"></a>链接：<a href="https://www.lanqiao.cn/problems/1457/learning/">https://www.lanqiao.cn/problems/1457/learning/</a></h3><p>下面的图形是著名的杨辉三角形：</p><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1357404-20210910-1631247098135" class="lazyload placeholder" data-srcset="https://dn-simplecloud.shiyanlou.com/courses/uid1357404-20210910-1631247098135" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image"></p><p>如果我们按从上到下、从左到右的顺序把所有数排成一列，可以得到如下数列： 1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,⋯1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,⋯</p><p>给定一个正整数 <em>N</em>，请你输出数列中第一次出现 <em>N</em> 是在第几个数？</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入一个整数 <em>N</em>。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出一个整数代表答案。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><blockquote><p>输入</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><blockquote><p>输出</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>对于 20的评测用例，1≤N≤10； 对于所有评测用例，1≤N≤10000000000。</p><h3 id="运行限制"><a href="#运行限制" class="headerlink" title="运行限制"></a>运行限制</h3><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对杨辉三角形进行仔细观察可知道，其中有很多数是重复的，因此我们只需要记录其有效部分。具体规律如下图所示：</p><p>" class="lazyload placeholder" data-srcset="" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp<img src=""></p><p>还可以发现，对于同一行，列数越大对应的数值也越大。而且某一行的某一列的值为x，在列数不变的情况下，无论行数怎么变大都不会再出现比x小的数；同理再行数不变的情况下列数怎么变大也不会出现比x小的数。并且得知n小于等于10的0次方时，有效列数为0-16列。因此我们可以一列一列的考虑，由于随着行号的变大，数值时单调递增的，其知道了行号、列号对应的数值也就知道了，于是便可以二分行号，使用二分查找的方法来计算本题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">16</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pan(i,n))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">pan</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=k*<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> right=Math.max(left,n);</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">suan</span> <span class="operator">=</span> suan(mid, k, n);</span><br><span class="line">            <span class="keyword">if</span>(suan&gt;=n)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">suan</span> <span class="operator">=</span> suan(right, k, n);</span><br><span class="line">        <span class="keyword">if</span>(suan==n)&#123;</span><br><span class="line">            System.out.println((<span class="type">long</span>)(right+<span class="number">1</span>)*right/<span class="number">2</span>+k+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">suan</span><span class="params">(<span class="type">long</span> mid,<span class="type">long</span> k,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">long</span> res=<span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> i=mid,j=<span class="number">1</span>;j&lt;=k;j++,i--)&#123;</span><br><span class="line">            res=res*i/j;</span><br><span class="line">            <span class="keyword">if</span>(res&gt;n)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-垃圾回收算法</title>
      <link href="/2023/03/01/jvm-la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue/"/>
      <url>/2023/03/01/jvm-la-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue/</url>
      
        <content type="html"><![CDATA[<h1 id="判断对象已死："><a href="#判断对象已死：" class="headerlink" title="判断对象已死："></a>判断对象已死：</h1><h3 id="1、引用计数算法"><a href="#1、引用计数算法" class="headerlink" title="1、引用计数算法"></a>1、引用计数算法</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加一，当引用失效时，计数器就减一。任何时刻计数器为零的对象就是不可能再被使用的。</p><p><strong>优缺点：</strong></p><p>占用了一些额外的内存空间来计数，但它的原理简单，判定效率也高。</p><p>主流的Java虚拟机没有选用引用计数法来管理内存。主要原因时这个算法有很多例外情况要考虑，必须配合大量的额外处理才能保证正确的工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。</p><h3 id="2、可达性分析算法"><a href="#2、可达性分析算法" class="headerlink" title="2、可达性分析算法"></a>2、可达性分析算法</h3><p>通过一系列称为”GC Roots“的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为”引用链“。如果这个对象多GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象时不能再被使用的。</p><p><strong>可以作为GC Roots的对象包括以下几种：</strong></p><p>1、在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆中使用到的参数、局部变量、临时变量等。</p><p>2、在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 </p><p>3、在方法区中常量引用的对象，譬如字符串常量池里的引用。</p><p>4、在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</p><p>5、Java虚拟机内部的引用，如基本数据类型对饮的Class对象，一些常驻的异常对象等，还有系统类加载器。</p><p>6、所有被同步锁（synchronized关键字）持有的对象。</p><p>7、反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p><p><strong>被可达性分析算法判定为不可达时一定”非死不可“吗？</strong></p><p>不是”非死不可“。要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那么它将会被第一次标记。随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。假如对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为”没有必要执行“。</p><p>如果这个对象被判定为确有必要执行finalize（）方法，该对象会被放入一个F-Queue的队列中，然后在一条由一条虚拟机自动创建的，低调度优先级的Finalizer线程去执行它们的finalize（）方法。但是”执行“并不承诺一定会等待它运行结束。因为如果某个对象的finalize（）方法执行很慢，或者是发生死循环，会导致队列中其他对象处于等待状态，甚至导致整个内存回收子系统崩溃。</p><p>finalize（）方法是对象拯救自己的最后一次机会，随后收集器会对F-Queue中的对象进行第二次标记。如果对象在finalize（）方法中重新与引用链上的任何一个对象建立关联，成功拯救自己，那第二次标记时它就会被移出”即将回收”的集合。</p><p>值得注意的是，finalize（）方法只能被系统自动调用一次，如果对象面对下一次回收，它的finalize（）方法不回被再次执行，不能再次自救。</p><h1 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h1><h3 id="1、强引用"><a href="#1、强引用" class="headerlink" title="1、强引用"></a>1、强引用</h3><p>是最传统的”引用“的定义，是指在程序代码之中普遍存在的引用赋值，当用new创建对象的时候就是强引用。无论任何情况下，只要强引用的关系还在，垃圾回收器永远不会回收掉被引用的对象。</p><h3 id="2、软引用"><a href="#2、软引用" class="headerlink" title="2、软引用"></a>2、软引用</h3><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进收回范围之中进行二次回收。就是内存不满的时候不会回收，在内存满了之后会进行回收操作。</p><h3 id="3、弱引用"><a href="#3、弱引用" class="headerlink" title="3、弱引用"></a>3、弱引用</h3><p>弱引用也用来描述那些非必须的对象，但是他的强度比软引用更弱一些。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><h3 id="4、虚引用"><a href="#4、虚引用" class="headerlink" title="4、虚引用"></a>4、虚引用</h3><p>它是最弱的一种引用关系。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p><h1 id="垃圾收集算法："><a href="#垃圾收集算法：" class="headerlink" title="垃圾收集算法："></a>垃圾收集算法：</h1><h3 id="分代收集理论："><a href="#分代收集理论：" class="headerlink" title="分代收集理论："></a>分代收集理论：</h3><p>当前商用虚拟机的垃圾收集器，大多数遵循了“分代收集”的理论进行设计。他建立在分代假说之上：</p><p><strong>1）弱分代假说：</strong>绝大多数对象都是朝生夕灭的。</p><p><strong>2）强分代假说：</strong>熬过越多次垃圾收集过程的对象就越难以消亡。</p><p><strong>3）跨代引用假说：</strong>跨代引用相对于同代引用来说仅占极少数。</p><p>收集器应该将Java堆中划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之后存储。</p><p><strong>优缺点：</strong>同时兼顾了垃圾收集的时间开销和内存空间的有效利用。</p><h3 id="标记-清除算法："><a href="#标记-清除算法：" class="headerlink" title="标记-清除算法："></a>标记-清除算法：</h3><p>算法分为“标记”和“清除”两个阶段：首先标记出所有要被回收的对象，在标记完成后，同意回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记的过程就是对象是否属于垃圾的判定过程。</p><p><strong>优缺点：</strong></p><p>1、执行效率不稳定：如果Java堆中包含大量对象，而且其中大部分是要被回收的，这是必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量的增长而降低。</p><p>2、内存空间碎片化：标记、清除之后回产生大量不连续的内存碎片，空间碎片太多可能会导致当以后再程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发了一次垃圾收集动作。</p><h3 id="标记-复制算法："><a href="#标记-复制算法：" class="headerlink" title="标记-复制算法："></a>标记-复制算法：</h3><p>标记-复制算法常被简称为复制算法。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次性清理掉。</p><p><strong>优缺点：</strong></p><p>1、如果内存中多数对象是存活的话，这种算法将会产生大量的内存空间复制的开销。</p><p>2、对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存的时候也不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。实现简单，运行高效。</p><p>3、可用内存缩小为了原来的一半，内存浪费未免太多了。</p><h3 id="标记-整理算法："><a href="#标记-整理算法：" class="headerlink" title="标记-整理算法："></a>标记-整理算法：</h3><p>标记的过程和“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。</p><p><strong>优缺点：</strong></p><p>1、如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象的移动操作必须全程暂停用户应用程序才能进行，这就让使用者不得不小心翼翼地权衡其弊端，像这种的停顿被最初的虚拟机设计者形象地描述为“Stop The World”。</p><p>2、不像标记-复制算法那样浪费额外的空间，也不会像标记-清除算法一样产生空间碎片。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka生产者</title>
      <link href="/2023/03/01/kafka-sheng-chan-zhe/"/>
      <url>/2023/03/01/kafka-sheng-chan-zhe/</url>
      
        <content type="html"><![CDATA[<h3 id="生产者发送原理"><a href="#生产者发送原理" class="headerlink" title="生产者发送原理"></a>生产者发送原理</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42842456/1710421449788-ee3089cf-d5d4-4ee1-9423-083e91fe1a7a.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2024/png/42842456/1710421449788-ee3089cf-d5d4-4ee1-9423-083e91fe1a7a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>消息的发送可能会经过拦截器、序列化、分区器等过程。消息发送的主要涉及两个线程，分别为main线程和sender线程，其中main线程是消息的生产线程，而sender线程是jvm单例的线程，专门用于消息的发送。</p><p>在main线程中创建了一个双端队列RecordAccumulator。main线程将消息发送给RecordAccumulator，sender线程不断从RecordAccumulator中拉取消息发送到kafka Broker。</p><h3 id="Kafka发送消息的三种形式"><a href="#Kafka发送消息的三种形式" class="headerlink" title="Kafka发送消息的三种形式"></a>Kafka发送消息的三种形式</h3><p><strong>发后即忘：</strong>只管往Kafka中发送消息而不关心消息是否正确到达。在大多数情况下，这种发送方式没有什么问题，不过在有些时候（比如发生不可重试异常时）会造成消息的丢失。这种发送方式性能最高，可靠性也最差。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42842456/1710422190669-ae667ba4-3359-45e4-aeba-b0854beba7b4.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2024/png/42842456/1710422190669-ae667ba4-3359-45e4-aeba-b0854beba7b4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>同步：</strong>通过get方法等待Kafka的响应，判断消息是否发送成功。以同步的方式发送消息时，一条一条地发送，对每条消息返回的结果判断，可以明确地知道每条消息的发送情况，但是由于同步的方式会阻塞，只有当消息通过get返回future对象时，才会继续下一条消息的发送。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42842456/1710422199793-44b0f694-101c-422a-8861-db6e3440e421.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2024/png/42842456/1710422199793-44b0f694-101c-422a-8861-db6e3440e421.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>异步：</strong>消息以异步的方式发送，通过回调函数返回消息成功/失败。在调用send方法发送消息的同时，指定一个回调函数，服务器在返回响应时会调用该回调函数，通过回调函数能够对异常情况进行处理，当调用了回调函数时，只有回调函数执行完毕生产者才会结束，否则一直会阻塞。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42842456/1710422206657-1f884c3f-5dd4-4078-8e8e-5e95d45bb0eb.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2024/png/42842456/1710422206657-1f884c3f-5dd4-4078-8e8e-5e95d45bb0eb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h3 id="生产者拦截器"><a href="#生产者拦截器" class="headerlink" title="生产者拦截器"></a>生产者拦截器</h3><p>生产者拦截器和消费者拦截器时在Kafka0.10版本被引入的，主要用于实现Client端的定制化控制逻辑。</p><p>对于生产者而言，拦截器是的用户在消息发送前以及生产者回调逻辑千有机会对消息做一些定制化需求，比如修改消息等，可以指定多个拦截器按序作用于同一条消息从而形成一个拦截链。</p><p><strong>自定义拦截器：</strong>可以通过实现org.apache.kafka.clients.producer.ProducerInterceptor接口编写拦截器。ProducerInterceptor包含configure，onSend，onAcknowledgement，close。</p><p><strong>onSend：</strong>该方法在消息发送前调用，可以编写一些对消息做过滤，修改的程序等，这里可以对消息做任何操作。但是最好不要改变消息的主题和分区信息，否则会影响目标分区的计算。</p><p><strong>onAcknowledgement：</strong>该方法会在消息从RecordAccumulator成功发送到Kafka之后或者发送过程中失败调用，可以用于地消息失败成功发送数量做统计等。但是该方法允许在生产者的IO线程中，尽量不要写一些重要的逻辑，否则会拖慢生产者消息发送效率。</p><p><strong>close：</strong>关闭拦截器，主要用于执行一些资源清理工作。</p><h3 id="序列器"><a href="#序列器" class="headerlink" title="序列器"></a>序列器</h3><p>在Kafka中，创建一个生产者对象必须指定序列化器，我们有两种选择：</p><p>1、使用自定义序列化器。</p><p>2、使用已有的序列化器和反序列化器。</p><p>通常不建议使用自定义序列化器，因为使用不同版本的序列化器和反序列化器会出现新旧消息的兼容性问题，特变时当消息记录中有修改字段的情况。</p><p>Apache Avro是一种与编程语言无关的序列化格式，推荐在Kafka上使用Avro序列化器。</p><p>Avro数据通过与语言无关的schema来定义，schema通过JSON来描述，数据被序列化成二进制文件或JSON文件，不过一般会使用二进制文件。Avro在读写文件时需要用到schema，schema一般会被内嵌在数据文件里。</p><p>Avro有一个很好的特性，就是当负责写消息的应用程序使用了新的schema，负责读消息的应用程序可以继续处理消息无需做任何改动。</p><h3 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h3><p><strong>分区好处：</strong></p><p>1、便于合理使用存储资源，每个Partition在一个Broker上存储，可以把海量的数据按照分区切割成一块一块数据存储在多台Broker上，合理控制分区的任务，可以实现负载均衡的效果。</p><p>2、提高并行度，生产者可以以分区为单位发送数据，消费者可以以分区为单位进行消费数据。</p><p><strong>分区策略：</strong></p><p>1、在指明partition的情况下，直接将指明的值作为partition值。</p><p>2、没有指明partition值但是有key的情况下，将key的hash值与topic的partition数进行取余得到partition值。</p><p>3、既没有partition值又没有key值得情况下，Kafka采用Sricky Partition（黏性分区器），会随机选择一个分区，并尽可能用一直使用该分区，待该分区得batch已满或者已完成，Kafka再随机一个分区进行使用（和上一次的分区不同）。</p><p><strong>自定义分区：</strong></p><p>1、定义类实现Partition方法。</p><p>2、重写partition()方法。</p><p>3、使用分区器方法，再生产者的配置中添加分区器参数。</p><h3 id="生产者提高吞吐量"><a href="#生产者提高吞吐量" class="headerlink" title="生产者提高吞吐量"></a>生产者提高吞吐量</h3><p><strong>buffer.memory：</strong>该参数用来设置生产者内存缓冲区的大小，生产者用它缓冲要发送到服务器的消息。如果应用程序发送消息的速度超过发送到服务器的速度，会导致生产者空间不足。这个时候，send()方法调用要么被阻塞，要么抛出异常，取决于如何设max.block.ms。当生产者调用时send()，消息并不会立即发送，而是会添加到内部缓冲区中。默认buffer.memory值为32MB。如果生产者发送消息的速度超过了将消息发送到broker的速度，或者存在网络问题，send()方法调用会被阻塞max.block.ms参数配置的时常，默认1分钟。</p><p><strong>max.block.ms：</strong>该参数指定了在调用send()方法或使用partitionsFor()方法获取元数据时生产者的阻塞时间。当生产者的发送缓冲区已满，或者没有可用的元数据时，这些方法就会被阻塞。在阻塞时间达到max.block.ms时，生产者会抛出超时异常。</p><p><strong>linger.ms：</strong>该参数指定了生产者在发送批次之前等待更多消息加入批次的时间。kafka生产者会在批次填满或linger.ms达到上限时把批次发送出去。默认情况下，只要有可用的线程，生产者就会把消息发送出去，就算批次里只有一个消息。把linger.ms设置成比0大的数，让生产者在发送批次之前等待一会儿，使更多的消息加入到这个批次。虽然这样会增加延迟，但也会提升吞吐量（因为一次性发送更多的消息，每个消息的开销就变小了）。</p><p><strong>batch.size：</strong>当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算（而不是消息个数）。当批次被填满，批次里的所有消息会被发送出去。不过生产者井不一定都会等到批次被填满才发送，这取决于linger.ms的配置，比如如果linger.ms时间到了，即便批次只包含一个消息，也会被立即发送。所以就算把批次大小设置得很大，也不会造成延迟，只是会占用更多的内存而已。但如果设置得太小，因为生产者需要更频繁地发送消息，会增加一些额外的开销。</p><p>可以使用配置使用linger.ms和batch.size。linger.ms是准备好发送批次之前的延迟时间，默认值为0。这意味着即使批次中只有1条消息，批次也会立即发送。有时，会增加linger.ms以减少请求数量并提高吞吐量。但这将导致更多消息保留在内存中。batch.size是单个批次的最大大小，当满足这两个要求中的任何一个时，将发送批次。</p><p><strong>compression.type：</strong>默认情况下，消息发送时不会被压缩。该参数可以设置为snappy 、gzip 或lz4，它指定了消息被发送给broker 之前使用哪一种压缩算也进行压缩。使用压缩可以降低网络传输开销和存储开销，而这往往是向Kafka 发送消息的瓶颈所在。</p><p>故要提高生产者的吞吐量，就必须合理的配置这几个参数的值，要多方面综合考虑。如为了增大batch.size就无限设置linger.ms，让其等待时间过长，这样就会导致消息发送延迟过高，这是不可取的。</p><h3 id="消息累加器"><a href="#消息累加器" class="headerlink" title="消息累加器"></a>消息累加器</h3><p>kafka为了提高Producer客户端的发送吞吐量和提高性能，选择了将消息暂时缓存起来，等到满足一定的条件,再进行批量发送,，这样可以减少网络请求，提高吞吐量。</p><p>消息累加器默认32m，如果生产者的发送速率大于sender发送的速率，消息就会堆满累加器。生产者就会阻塞，或者报错，报错取决于阻塞时间的配置。</p><p>累加器的存储形式为ConcurrentMap&lt;TopicPartition, Deque<ProducerBatch>&gt;，可以看出来就是一个分区对应一个双端队列，队列中存储的是ProducerBatch一般大小是16k根据batch.size配置，新的消息会append到ProducerBatch中，满16k就会创建新的ProducerBatch，并且触发sender线程进行发送。</p><p>如果消息量非常大，生成了大量的ProducerBatch，在发送后，又需要JVM通过GC回收这ProducerBatch就变得非常影响性能，所以kafka通过 BufferPool作为内存池来管理ProducerBatch的创建和回收，需要申请一个新的ProducerBatch空间时，调用 free.allocate(size, maxTimeToBlock)找内存池申请空间。</p><p>如果单条消息大于16k，那么就不会复用内存池了，会生成一个更大的ProducerBatch专门存放大消息，发送完后GC回收该内存空间。</p><h3 id="消息确认机制-ACK"><a href="#消息确认机制-ACK" class="headerlink" title="消息确认机制-ACK"></a>消息确认机制-ACK</h3><p>Kafka中消息确认（Acknowledgement）是指生产者发送消息后，等待Kafka返回的确认信息。信息确认用于保证消息发送的可靠性，主要有一下几种模式：</p><p>1、最速消息确认：生产者发送消息后立即返回确认，不等待Broker的确认。此模式吞吐量最高，但可靠性最低。</p><p>2、知识消息确认：生产者发送消息后等待Broker落盘确认，再返回确认给生产者。此模式吞吐量较高，且消息不会丢失。</p><p>3、完成消息确认：生产者发送消息后等待消息被提交后再确认，再返回确认给消费者。此模式吞吐量较低，但可靠性最高。</p><p>4、等待ISR确认：生产者发送消息后等待消息被复制到ISR集合内的副本数后再确认，再返回确认给消费者。此模式吞吐量中等，且保证高可靠性。</p><p><strong>acks确认机制</strong></p><p>acks参数指定了必须要有多少个分区副本收到消息，生产者才认为该消息是写入成功的。</p><p>acks=0，表示生产者在成功写入消息之前不会等待任何来自服务器的响应。。换句话说，一旦出现了问题导致服务器没有收到消息，那么生产者就无从得知，消息也就丢失了。</p><p>acks=1，表示只要集群的leader分区副本接收到了消息，就会向生产者发送一个成功响应的ack，此时生产者接收到ack之后就可以认为该消息是写入成功的。 一旦消息无法写入leader分区副本(比如网络原因、leader节点崩溃)，生产者会收到一个错误响应。</p><p>acks =-1/all，表示只有所有参与复制的节点(ISR列表的副本)全部收到消息时，生产者才会接收到来自服务器的响应。这种模式是最高级别的，也是最安全的，可以确保不止一个Broker接收到了消息。 该模式的延迟会很高。</p><p>数据完全可靠条件 = ACK级别设置为-1 + 分区副本大于等于2 + ISR里应答的最小副本数量大于等于2</p><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>在一般的MQ模型中，常有以下的消息通信概念</p><p><strong>至少一次：</strong> ACK级别设置为-1 + 分区副本大于等于2 + ISR里应答的最小副本数量&gt;=2。可以保证数据不丢失，但是不能保证数据不重复。</p><p><strong>最多一次：</strong>ACK级别设置为0 。可以保证数据不重复，但是不能保证数据不丢失。</p><p><strong>精确一次：</strong>至少一次 + 幂等性 。 Kafka 0.11版本引入一项重大特性：幂等性和事务。</p><p>幂等性，简单地说就是对接口的多次调用所产生的结果和调用一次是一致的。生产者在进行重试的时候有可能会重复写入消息，而使用Kafka 的幂等性功能之后就可以避免这种情况。（不产生重复数据）</p><p>实现幂等的关键点就是服务端可以区分请求是否重复，过滤掉重复的请求。要区分请求是否重复的有两点：</p><p><strong>唯一标识：</strong>要想区分请求是否重复，请求中就得有唯一标识。例如支付请求中，订单号就是唯一标识</p><p><strong>记录下已处理过的请求标识：</strong>光有唯一标识还不够，还需要记录下那些请求是已经处理过的，这样当收到新的请求时，用新请求中的标识和处理记录进行比较，如果处理记录中有相同的标识，说明是重复交易，拒绝掉。</p><p>为了实现Producer的幂等性，Kafka引入了Producer ID（即PID）和Sequence Number。</p><p><strong>PID：</strong>每个新的Producer在初始化的时候会被分配一个唯一的PID，这个PID对用户是不可见的。</p><p><strong>Sequence Numbler：</strong>对于每个PID，该Producer发送数据的每个&lt;Topic, Partition&gt;都对应一个从0开始单调递增的Sequence Number。</p><p>Kafka可能存在多个生产者，会同时产生消息，但对Kafka来说，只需要保证每个生产者内部的消息幂等就可以了，所有引入了PID来标识不同的生产者。</p><p>对于Kafka来说，要解决的是生产者发送消息的幂等问题。也即需要区分每条消息是否重复。</p><p>Kafka通过为每条消息增加一个Sequence Numbler，通过Sequence Numbler来区分每条消息。每条消息对应一个分区，不同的分区产生的消息不可能重复。所有Sequence Numbler对应每个分区</p><p>Broker端在缓存中保存了这seq number，对于接收的每条消息，如果其序号比Broker缓存中序号大于1则接受它，否则将其丢弃。这样就可以实现了消息重复提交了。但是，只能保证单个Producer对于同一个&lt;Topic, Partition&gt;的Exactly Once语义。不能保证同一个Producer一个topic不同的partion幂等。</p><p><strong>开启幂等性：</strong>生产者客户端参数enable.idempotence设置为true。</p><h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>由于幂等性不能跨分区运作，为了保证同时发的多条消息，要么全成功，要么全失败。kafka引入了事务的概念。</p><p>原子性：事务性消息要么完全成功，要么完全失败。这确保了消息不会被部分处理。<br>可靠性：一旦消息被写入Kafka，它们将被视为已经处理，即使发生了应用程序或系统故障。<br>顺序性：事务性消息在单个分区内保持顺序。这对于需要按顺序处理的应用程序至关重要。</p><p>Kafka事务的回滚，并不是删除已写入的数据，而是将写入数据的事务标记为 Rollback/Abort 从而在读数据时过滤该数据。</p><h3 id="保证消息顺序"><a href="#保证消息顺序" class="headerlink" title="保证消息顺序"></a>保证消息顺序</h3><p>针对消息有序的业务需求，还分为全局有序和局部有序。</p><ul><li>全局有序：一个Topic下的所有消息都需要按照生产顺序消费。</li><li>局部有序：一个Topic下的消息，只需要满足同一业务字段的要按照生产顺序消费。例如：Topic消息是订单的流水表，包含订单orderId，业务要求同一个orderId的消息需要按照生产顺序进行消费。</li></ul><p><strong>全局有序</strong></p><p>由于Kafka的一个Topic可以分为了多个Partition，Producer发送消息的时候，是分散在不同 Partition的。当Producer按顺序发消息给Broker，但进入Kafka之后，这些消息就不一定进到哪个Partition，会导致顺序是乱的。</p><p>因此要满足全局有序，需要1个Topic只能对应1个Partition。</p><p>而且对应的consumer也要使用单线程或者保证消费顺序的线程模型。</p><p><strong>局部有序</strong></p><p>要满足局部有序，只需要在发消息的时候指定Partition Key，Kafka对其进行Hash计算，根据计算结果决定放入哪个Partition。这样Partition Key相同的消息会放在同一个Partition。此时，Partition的数量仍然可以设置多个，提升Topic的整体吞吐量。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42842456/1710661345494-09fea4c7-ab22-4608-a700-6a5b37687f37.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2024/png/42842456/1710661345494-09fea4c7-ab22-4608-a700-6a5b37687f37.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-Java内存区域</title>
      <link href="/2023/02/24/jvm-java-nei-cun-qu-yu-yu-nei-cun-yi-chu-yi-chang/"/>
      <url>/2023/02/24/jvm-java-nei-cun-qu-yu-yu-nei-cun-yi-chu-yi-chang/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="运行时数据区："><a href="#运行时数据区：" class="headerlink" title="运行时数据区："></a>运行时数据区：</h1><h3 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h3><p>当前线程所执行的字节码指令的行号指示器。在Java虚拟机的概念模型里，字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>线程私有，不会出现OutOfMemoryError异常。</p><h3 id="Java虚拟机栈："><a href="#Java虚拟机栈：" class="headerlink" title="Java虚拟机栈："></a>Java虚拟机栈：</h3><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候，Java虚拟机都会创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。</p><p>线程私有。如果线程请求的栈深度大于虚拟机栈所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈的容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p><h3 id="本地方法栈："><a href="#本地方法栈：" class="headerlink" title="本地方法栈："></a>本地方法栈：</h3><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><h3 id="Java堆："><a href="#Java堆：" class="headerlink" title="Java堆："></a>Java堆：</h3><p>Java堆是虚拟机所管理的内存中最大的一块。“几乎”所有的对象实例和数组都在这里分配内存。Java堆是垃圾收集器管理的内存区域，因此一些资料中把它称作“GC堆”。</p><p>线程共享。如果在Java堆中没有内存完成实例分配，并且堆也无法扩展时，Java虚拟机会抛出OutOfMemoryError异常。</p><h3 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h3><p>方法区用来存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。这块内存回收的主要目标是针对常量池的回收和对类型的卸载。</p><p>线程共享。如果方法区无法满足新的内存分配的需求时，将会抛出OutOfMemoryError异常。</p><p><strong>永久代：</strong></p><p>在JDK8之前，许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称为“永久代”。但本质上二者是不等价的。</p><p><strong>元空间：</strong></p><p>在JDK6，HotSpot团队逐步改为采用本地内存的方法来实现方法区的计划了。到了JDK8，终于完全废除了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间来代替，把JDK7中永久代还剩余的内容（主要是内存信息）全部移到元空间中。</p><p><strong>为什么用元空间代替永久代？</strong></p><p>1、避免OOM。使用永久代导致Java应用更容易遇到内存溢出的问题：永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小。元空间存在本地内存中，有系统实际可用空间来控制，当然也可以控制大小-XX：MaxMetaSpaceSize。</p><p>2、提高GC性能：永久代会位GC带来不必要的复杂度，而且回收效率偏低。</p><p>3、合并HotSpot和JRockit：在Oracle收购BEA取得JRockit的所有权后，准备把JRockit中的优秀功能移植到HotSpot虚拟机时，因为两者都对方法区的实现的差异而面临很多困难。</p><h1 id="对象的创建："><a href="#对象的创建：" class="headerlink" title="对象的创建："></a>对象的创建：</h1><h3 id="类加载："><a href="#类加载：" class="headerlink" title="类加载："></a>类加载：</h3><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h3 id="分配内存："><a href="#分配内存：" class="headerlink" title="分配内存："></a>分配内存：</h3><p>在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后就可以完全确定，为对象分配空间的任务实际上便等于把一块确定大小的内存块从Java堆中划分出来。</p><p><strong>分配内存的方法：</strong></p><p><strong>指针碰撞</strong>：如果Java堆中的内存是绝对规整的，所有被使用过内存都被放到一边，空闲的内存被放到另一遍，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个指针向空闲空间的方向挪动一段与对象大小相等的距离。</p><p><strong>空闲列表：</strong>如果Java堆中的内存并不是规整的，已经使用过内存和空闲的内存交错在一起，虚拟机必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</p><p><strong>并发情况下产生的问题：</strong></p><p>1、对分配内存空间的动作进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。</p><p>2、把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程需要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，通过-XX+：-UseTLAB参数来设定。</p><h3 id="初始化零值："><a href="#初始化零值：" class="headerlink" title="初始化零值："></a>初始化零值：</h3><p>内存分配完后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值，如果使用了TLAB，这项工作也可以提前到TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中不赋初值也可以直接使用。</p><h3 id="设置对象头："><a href="#设置对象头：" class="headerlink" title="设置对象头："></a>设置对象头：</h3><p>接下来Java虚拟机堆对象进行必要的设置，例如这个对象时哪个类的实例等。</p><h3 id="执行（）方法："><a href="#执行（）方法：" class="headerlink" title="执行（）方法："></a>执行<init>（）方法：</h3><p>上述操作完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象的创建才刚刚开始。一般来说，new指令之后会接着执行<init>（）方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p><h1 id="对象的内存布局："><a href="#对象的内存布局：" class="headerlink" title="对象的内存布局："></a>对象的内存布局：</h1><p>对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据和对齐填充。</p><h3 id="对象头："><a href="#对象头：" class="headerlink" title="对象头："></a>对象头：</h3><p>HotSpot虚拟机的对象头包括两类信息：</p><p><strong>用于存储对象自身的运行时数据：</strong>如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p><p><strong>类型指针：</strong>即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。但并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。</p><h3 id="实例数据："><a href="#实例数据：" class="headerlink" title="实例数据："></a>实例数据：</h3><p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p><h3 id="对齐填充："><a href="#对齐填充：" class="headerlink" title="对齐填充："></a>对齐填充：</h3><p>对齐填充并不是必然存在的，也没有特殊的含义，仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象的起始位置必须是8字节的证书倍，换句话说就是任何对象的大小都必须是8字节的整数倍。因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h1 id="对象的访问定位："><a href="#对象的访问定位：" class="headerlink" title="对象的访问定位："></a>对象的访问定位：</h1><p>我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。主流的访问方式主要有使用句柄和直接指针两种：</p><h3 id="使用句柄："><a href="#使用句柄：" class="headerlink" title="使用句柄："></a>使用句柄：</h3><p>如果使用句柄访问的话，Java堆中可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p><p><strong>优点：</strong>使用句柄来访问最大的好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><h3 id="直接指针："><a href="#直接指针：" class="headerlink" title="直接指针："></a>直接指针：</h3><p>如果使用直接指针访问的话，Java堆中的对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象的地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</p><p><strong>优点：</strong>使用直接指针来访问的最大好处就是速度更快，它节省了一次指针定位的时间开销。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM面试题</title>
      <link href="/2023/02/19/jvm-mian-shi-ti/"/>
      <url>/2023/02/19/jvm-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="1、什么情况下会发生栈内存溢出。"><a href="#1、什么情况下会发生栈内存溢出。" class="headerlink" title="1、什么情况下会发生栈内存溢出。"></a>1、什么情况下会发生栈内存溢出。</h3><p>1、栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型<br>2、如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，方法递归调用产生这种结果。<br>3、如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多)<br>4、参数 -Xss 去调整JVM栈的大小</p><h3 id="2、详解JVM内存模型"><a href="#2、详解JVM内存模型" class="headerlink" title="2、详解JVM内存模型"></a>2、详解JVM内存模型</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzIyLzE2YzFhNDI2ZWQ5YWI0OGI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ?x-oss-process=image/format,png" class="lazyload placeholder" data-srcset="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzIyLzE2YzFhNDI2ZWQ5YWI0OGI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ?x-oss-process=image/format,png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>程序计数器：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有。</p><p>Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有。</p><p>Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有。</p><p>Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享。</p><p>方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。回收目标主要是常量池的回收和类型的卸载，各线程共享</p><h3 id="3、JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor？"><a href="#3、JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor？" class="headerlink" title="3、JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor？"></a>3、JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor？</h3><h5 id="1）共享内存区划分"><a href="#1）共享内存区划分" class="headerlink" title="1）共享内存区划分"></a><strong>1）共享内存区划分</strong></h5><p>共享内存区 = 持久带 + 堆<br>持久带 = 方法区 + 其他<br>Java堆 = 老年代 + 新生代<br>新生代 = Eden + S0 + S1</p><h5 id="2）一些参数的配置"><a href="#2）一些参数的配置" class="headerlink" title="2）一些参数的配置"></a><strong>2）一些参数的配置</strong></h5><p>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。<br>默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定)<br>Survivor区中的对象被复制次数为15(对应虚拟机参数 -XX:+MaxTenuringThreshold)</p><h5 id="3）为什么要分为Eden和Survivor-为什么要设置两个Survivor区？"><a href="#3）为什么要分为Eden和Survivor-为什么要设置两个Survivor区？" class="headerlink" title="3）为什么要分为Eden和Survivor?为什么要设置两个Survivor区？"></a>3）为什么要分为Eden和Survivor?为什么要设置两个Survivor区？</h5><p>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。<br>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。<br>设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）</p><h3 id="4、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？"><a href="#4、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？" class="headerlink" title="4、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？"></a>4、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？</h3><p>Java堆 = 老年代 + 新生代<br>新生代 = Eden + S0 + S1<br>当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。<br>大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；<br>如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。<br>老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。<br>Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。</p><h3 id="5、你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"><a href="#5、你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。" class="headerlink" title="5、你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"></a>5、你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</h3><h5 id="1）几种垃圾收集器："><a href="#1）几种垃圾收集器：" class="headerlink" title="1）几种垃圾收集器："></a><strong>1）几种垃圾收集器：</strong></h5><p><strong>Serial收集器：</strong> 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。<br><strong>ParNew收集器：</strong> Serial收集器的多线程版本，也需要stop the world，复制算法。<br><strong>Parallel Scavenge收集器：</strong> 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。<br><strong>Serial Old收集器：</strong> 是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。<br><strong>Parallel Old收集器：</strong> 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。<br><strong>CMS(Concurrent Mark Sweep) 收集器：</strong> 是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片。<br><strong>G1收集器：</strong> 标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记。不会产生空间碎片，可以精确地控制停顿。</p><h5 id="2）CMS收集器和G1收集器的区别："><a href="#2）CMS收集器和G1收集器的区别：" class="headerlink" title="2）CMS收集器和G1收集器的区别："></a><strong>2）CMS收集器和G1收集器的区别：</strong></h5><p>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；<br>G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；<br>CMS收集器以最小的停顿时间为目标的收集器；<br>G1收集器可预测垃圾回收的停顿时间<br>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片<br>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。</p><h3 id="6、JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。"><a href="#6、JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。" class="headerlink" title="6、JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。"></a>6、JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzIzLzE2YzFjMTk4MmUzNjA5YjE_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ?x-oss-process=image/format,png" class="lazyload placeholder" data-srcset="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzIzLzE2YzFjMTk4MmUzNjA5YjE_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ?x-oss-process=image/format,png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="7、简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"><a href="#7、简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。" class="headerlink" title="7、简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"></a>7、简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。</h3><h5 id="1）什么是类加载器？"><a href="#1）什么是类加载器？" class="headerlink" title="1）什么是类加载器？"></a>1）什么是类加载器？</h5><p>类加载器 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。</p><p>启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。<br>其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：<br>扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。<br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p><h5 id="2）双亲委派模型"><a href="#2）双亲委派模型" class="headerlink" title="2）双亲委派模型"></a>2）双亲委派模型</h5><p>双亲委派模型工作过程是：</p><p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p><p>双亲委派模型图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzIzLzE2YzFjNTRjZjRhZDg4NmI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ?x-oss-process=image/format,png" class="lazyload placeholder" data-srcset="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzIzLzE2YzFjNTRjZjRhZDg4NmI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ?x-oss-process=image/format,png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h5 id="3）为什么需要双亲委派模型？"><a href="#3）为什么需要双亲委派模型？" class="headerlink" title="3）为什么需要双亲委派模型？"></a>3）为什么需要双亲委派模型？</h5><p>在这里，先想一下，如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么类之间的比较结果及类的唯一性将无法保证，因此，为什么需要双亲委派模型？防止内存中出现多份同样的字节码</p><h5 id="4）怎么打破双亲委派模型？"><a href="#4）怎么打破双亲委派模型？" class="headerlink" title="4）怎么打破双亲委派模型？"></a>4）怎么打破双亲委派模型？</h5><p>打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法。</p><h3 id="8、强引用、软引用、弱引用、虚引用的区别？"><a href="#8、强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="8、强引用、软引用、弱引用、虚引用的区别？"></a>8、强引用、软引用、弱引用、虚引用的区别？</h3><p><strong>1、</strong> 强引用，就是普通的对象引用关系，如 String s = new String(“ConstXiong”)</p><p><strong>2、</strong> 软引用，用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。SoftReference 实现</p><p><strong>3、</strong> 弱引用，相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。WeakReference 实现</p><p><strong>4、</strong> 虚引用是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来跟踪对象被垃圾回收的活动。PhantomReference 实现。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka简介</title>
      <link href="/2023/02/10/kafka-jian-jie/"/>
      <url>/2023/02/10/kafka-jian-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Kafka？"><a href="#什么是Kafka？" class="headerlink" title="什么是Kafka？"></a>什么是Kafka？</h3><p>Kafka是一个开源的分布式事件流平台，事件流就是从事件源以事件流的形式实时捕获数据的时间，持久存储这些事件流供以后检索，实时和回顾地操作、处理和响应事件流，并根据需要将事件流路由到不同的目标技术。事件流保证了数据的连续流动性和解释，以便正确的信息在正确的时间出现在正确的位置。</p><p>Kafka最初由LinkedIn开发并开源，后来称为Apache软件基金会的一个顶级项目。它被设计用于高吞吐量、持久性、分布式的数据流处理。</p><h3 id="Kafka与其他消息队列区别"><a href="#Kafka与其他消息队列区别" class="headerlink" title="Kafka与其他消息队列区别"></a>Kafka与其他消息队列区别</h3><p>消息队列是分布式系统中重要的组件，利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</p><table><thead><tr><th><strong>特性</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RabbitMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td><strong>单机吞吐量</strong></td><td>万级，比RocketMQ、Kafka低一个数量级</td><td>万级，比RocketMQ、Kafka低一个数量级</td><td>十万级，支撑高吞吐，支持强一致性，强一致性下吞吐量稍低</td><td>十万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td><strong>topic数量对吞吐量的影响</strong></td><td></td><td></td><td>topic可以达到几百几千个的级别，吞吐量会有较小幅度的下降。这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic</td><td>topic从几十个到几百个的时候，吞吐量会大幅度下降。所以在同等机器下，Kafka尽量保证topic数量不要过多，如果支撑大规模的topic，需要增加更多的机器资源</td></tr><tr><td><strong>时效性</strong></td><td>毫秒级</td><td>微秒级，这是RabbitMQ的一大特点，延迟性是最低的</td><td>毫秒级</td><td>毫秒级以内</td></tr><tr><td><strong>可用性</strong></td><td>高，基于总从架构实现高可用性</td><td>高，基于总从架构实现高可用性</td><td>非常高，分布式架构</td><td>非常高，Kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td><strong>消息可靠性</strong></td><td>有较低的概率丢失数据</td><td></td><td>经过参数优化，可以做到0丢失</td><td>经过参数优化，可以做到0丢失</td></tr><tr><td><strong>功能支持</strong></td><td>MQ领域的功能极其完备</td><td>基于erlang开发，所以并发能力很强，性能极其好，延时很低</td><td>MQ功能较为完善，分布式的，扩展性好</td><td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td></tr></tbody></table><h3 id="Kafka的应用场景"><a href="#Kafka的应用场景" class="headerlink" title="Kafka的应用场景"></a>Kafka的应用场景</h3><p><strong>1、消息：</strong>Kafka更好地替换传统的消息系统，消息系统被用于各种场景，与大都数消息系统比较Kafka有更好的吞吐量内置分区、副本和故障转移，这有利于处理大规模的消息。</p><p><strong>2、网站活动追踪：</strong>Kafka原本的使用场景是用户的活动追踪，网站的活动（网页浏览，搜索或其他用户的操作信息）发布到不同的话题中心，这些消息可实时处理实时监测，也可加载到Hadoop或者离线处理数据仓库。</p><p><strong>3、指标：</strong>Kafka也常常用于监测数据，分布式应用程序生成的统计数据集中聚合。</p><p><strong>4、日志聚合：</strong>许多人使用Kafka作为日志聚合解决方案的替代品。日志聚合通常从服务器中收集物理日志文件，并将它们放在中央位置进行处理。Kafka抽象出文件的细节，并将日志或时间数据更清晰地抽象为消息流。这允许更低延迟的处理并更容易支持多个数据源和分布式数据消费。</p><p><strong>5、流处理：</strong>Kafka中消息处理一般包含多个阶段。其中原始输入数据是从Kafka主题消费的，然后汇总，丰富，或者以其他的处理方式转化为新主题。</p><p><strong>6、事件采集：</strong>事件采集是一种应用程序的设计风格，其中状态的变化根据时间的顺序记录下来，Kafka支持这种非常大的存储日志数据的场景。</p><p><strong>7、提交日志：</strong>Kafka可以作为一种分布式的外部日志，可帮助节点之间复制数据，并作为失败的节点来恢复数据重新同步，Kafka的日志压缩功能很好地支持这种用法。</p><h3 id="消息队列的两种模式"><a href="#消息队列的两种模式" class="headerlink" title="消息队列的两种模式"></a>消息队列的两种模式</h3><p><strong>1、点对点模式</strong></p><p>消费者主动拉取数据，消息收到后清除消息。</p><p><strong>2、发布/订阅模式</strong></p><p>可以有多个topic主题。</p><p>消费者消费数据后，不删除数据。</p><p>每个消费者相互独立，都可以消费到数据。</p><p><strong>区别：</strong></p><p>点对点消费消息只能发布到一个主题，消费完成就删除消息，并且只有一个消费者。</p><p>发布/订阅模式消息可以发布到多个主题，消息一般保留七天，并且有多个消费者。</p><h3 id="Kafka基本架构"><a href="#Kafka基本架构" class="headerlink" title="Kafka基本架构"></a>Kafka基本架构</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42842456/1710407928158-dc1cbb34-b646-4564-9c5d-1adbc7833001.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2024/png/42842456/1710407928158-dc1cbb34-b646-4564-9c5d-1adbc7833001.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>Producer：</strong>消息生产者，就是向Kafka Broker发消息的客户端。</p><p><strong>Consumer：</strong>消息消费者，就是从Kafka Broker拉取消息的服务端。</p><p><strong>Consumer Group：</strong>消费者组，由多个consumer组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费。消费者组之间互不影响。所有消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。某一个分区中的消息只能够一个消费者组内的一个消费者所消费。</p><p><strong>Broker：</strong>经纪人，一台Kafka服务器就是一个Broker，一个集群由多个Broker组成，一个Broker可以容纳多个Topic。</p><p><strong>Topic：</strong>主题，可以理解为一个队列，生产者和消费者都是面向一个Topic。</p><p><strong>Partition：</strong>分区，为了实现扩展性，一个非常大的Topic可以分布到多个Broker上，一个Topic可以分为多个Partition，每个Partition是一个有序队列。分区有序，不能保证全局有序，如果要保证全局有序，则只能使用一个Partition。</p><p><strong>Replication：</strong>副本，为了保证集群中某个节点发生故障，节点上的Partition数据不丢失，Kafka可以正常地工作，Kafka提供了副本机制，一个Topic的每个分区有若干副本，一个Leader和多个Follower。</p><p><strong>Leader：</strong>每个分区多个副本的主角色，生产者发送数据的对象以及消费者消费数据的对象都是Leader。</p><p><strong>Follower：</strong>每个分区多个副本的从角色，实时地从Leader中同步数据，保持和Leader数据的同步，Leader发生故障的时候，某个Follower会成为新的Leader。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EasyExcel</title>
      <link href="/2023/02/05/easyexcel/"/>
      <url>/2023/02/05/easyexcel/</url>
      
        <content type="html"><![CDATA[<p>​        前一段时间在写一个灌溉系统的项目，项目要求有数据导入导出，这一块正好分配给我去完成了，所以我上网学了一下EasyExcel的使用。</p><a id="more"></a><h2 id="pom导入："><a href="#pom导入：" class="headerlink" title="pom导入："></a>pom导入：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;最新版本&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="实体类："><a href="#实体类：" class="headerlink" title="实体类："></a>实体类：</h2><p>@ColumnWidth：定义列宽</p><p>@ExcelProperty：value：用于匹配excel中的头，必须全匹配,如果有多行头，会匹配最后一行头</p><p>@ExcelIgnore：加了该注解的字段会被忽略</p><p>@DateTimeFormat：日期转换</p><p>@NumberFormat：数字转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ColumnWidth(20)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Field</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;地块编号&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String fieldId;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;冠层温度&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal canopyTemp;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;土壤含水量&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal soilMoisture;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;灌溉决策结果&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer result;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;灌溉情况&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String irrigationInfo;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;其他情况&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="导入："><a href="#导入：" class="headerlink" title="导入："></a>导入：</h2><h4 id="监听器："><a href="#监听器：" class="headerlink" title="监听器："></a>监听器：</h4><p>如果想在抛出异常时跳过异常的地方继续读接下来的数据，可以查看官方文档，在监听器中配置一个异常的方法。因为我写的时候想的是导入数据错误的话让他导入失败，所以没有进行配置这一项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelDataListener</span> <span class="keyword">implements</span> <span class="title class_">ReadListener</span>&lt;Field&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以100条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_COUNT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Field&gt; cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> FieldService fieldService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExcelDataListener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是demo，所以随便new一个。实际使用如果到了spring,请使用下面的有参构造函数</span></span><br><span class="line">        fieldService = <span class="keyword">new</span> <span class="title class_">FieldServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExcelDataListener</span><span class="params">(FieldService fieldService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fieldService = fieldService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个每一条数据解析都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Field data, AnalysisContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(data));</span><br><span class="line">        cachedDataList.add(data);</span><br><span class="line">        <span class="comment">// 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span></span><br><span class="line">        <span class="keyword">if</span> (cachedDataList.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">            saveData();</span><br><span class="line">            <span class="comment">// 存储完成清理 list</span></span><br><span class="line">            cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有数据解析完成了 都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里也要保存数据，确保最后遗留的数据也存储到数据库</span></span><br><span class="line">        saveData();</span><br><span class="line">        log.info(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上存储数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveData</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;条数据，开始存储数据库！&quot;</span>, cachedDataList.size());</span><br><span class="line">        fieldService.saveData(cachedDataList);</span><br><span class="line">        log.info(<span class="string">&quot;存储数据库成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="service："><a href="#service：" class="headerlink" title="service："></a>service：</h4><p>importData：调用接口传入文件，然后调用这个方法。</p><p>saveData：监听器存数据库时调用的方法，可以自定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ReturnUtil&lt;String&gt; <span class="title function_">importData</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EasyExcel.read(file.getInputStream(), Field.class, <span class="keyword">new</span> <span class="title class_">ExcelDataListener</span>(<span class="built_in">this</span>)).sheet().doRead();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> ReturnUtil.error(<span class="string">&quot;导入数据错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReturnUtil.success(<span class="string">&quot;导入数据完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveData</span><span class="params">(List&lt;Field&gt; fieldList)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Field field : fieldList) &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    &#125;</span><br><span class="line">    fieldDao.insertMore(fieldList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="导出数据："><a href="#导出数据：" class="headerlink" title="导出数据："></a>导出数据：</h2><p>因为我是导出为一个文件，所以将官方文档中的导出数据和下载文件结合到了一起。</p><p>按下面那个代码导出的文件名为”田间实时数据.xlsx”，然后表格头是在实体类中定义的。</p><p>这里我用了重复多次写入，因为我看官方文档中写的不能一次写入太多数据，否则会出错，所以我用分页的操作进行了多次写入，防止写入时出错。</p><p>注意：在测试的时候不能用swagger测试，不然下载的文件名是乱码，要把后缀名修改后才能查看。建议用postman或者在网页上直接测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ReturnUtil&lt;String&gt; <span class="title function_">exportData</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;</span>);</span><br><span class="line">    response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> EasyExcel.write(response.getOutputStream(), Field.class).build()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;田间实时数据&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename*=utf-8&#x27;&#x27;&quot;</span> + fileName + <span class="string">&quot;.xlsx&quot;</span>);</span><br><span class="line">        <span class="type">WriteSheet</span> <span class="variable">writeSheet</span> <span class="operator">=</span> EasyExcel.writerSheet(<span class="string">&quot;田间实时数据&quot;</span>).build();</span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> fieldDao.selectCount(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> total / <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">50</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            IPage&lt;Field&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(i, <span class="number">50</span>);</span><br><span class="line">            <span class="comment">// 分页去数据库查询数据 这里可以去数据库查询每一页的数据</span></span><br><span class="line">            List&lt;Field&gt; data = fieldDao.selectPage(page, <span class="literal">null</span>).getRecords();</span><br><span class="line">            excelWriter.write(data, writeSheet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">            List&lt;Field&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            excelWriter.write(data,writeSheet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;导出数据错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ReturnUtil.error(<span class="string">&quot;导出数据错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReturnUtil.success(<span class="string">&quot;导出数据完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2023/01/15/bei-bao-wen-ti/"/>
      <url>/2023/01/15/bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>        给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><a id="more"></a><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1<br>示例 2：</p><p>输入：coins = [2], amount = 3<br>输出：-1<br>示例 3：</p><p>输入：coins = [1], amount = 0<br>输出：0</p><p>链接：<a href="https://leetcode.cn/problems/coin-change">https://leetcode.cn/problems/coin-change</a></p><p>思路：</p><p>我们采用自下而上的方式进行思考。仍定义 F(i)F(i) 为组成金额 ii 所需最少的硬币数量，假设在计算 F(i)F(i) 之前，我们已经计算出 F(0)-F(i-1)F(0)−F(i−1) 的答案。 则 F(i)F(i) 对应的转移方程应为</p><p><img src="https://appdocs.wpscdn.cn/api/v3/office/copy/QkNuTjJ6VGZLakFZbnA5dkVKNTdyV2dTNzRpNTR5Z2lJdmN5MWJ3bTJJTjArQ2pGTW43YjFrWi8rRUx4RGVtaFJINWJnaEFuQWxYTzVXekJ0a2lmd1kvTGhlMVBGZzM3OUFsOGRrb1pFclRsZG5yZWFLaWVnYmNnSUFxK0RIajhCQ1NWamxVRXo2OC9POW9xaStoWkh3WGFFMHVMc045Q0wzc01oNDVkZEV5YlNTODlseFlZS1VoV2Z2WE1OazVzVWVvL2U3QXpQTFo5Z0oxbHh0SmJkN1hKV29zcGNWdFF1SjZ3Z3lUbnZsWTRlMEtUYW95WUJvK1Y1bFl6MGdPMzRweEsyQjg1b0FocnVVV1Y5bFkwRE9wVlhuYjZxbDRicGNqY1J0RkFnZVRuRi9ranEzZFFsK1lBdjEyRQ==/attach/object/VEVNMAYATU" class="lazyload placeholder" data-srcset="https://appdocs.wpscdn.cn/api/v3/office/copy/QkNuTjJ6VGZLakFZbnA5dkVKNTdyV2dTNzRpNTR5Z2lJdmN5MWJ3bTJJTjArQ2pGTW43YjFrWi8rRUx4RGVtaFJINWJnaEFuQWxYTzVXekJ0a2lmd1kvTGhlMVBGZzM3OUFsOGRrb1pFclRsZG5yZWFLaWVnYmNnSUFxK0RIajhCQ1NWamxVRXo2OC9POW9xaStoWkh3WGFFMHVMc045Q0wzc01oNDVkZEV5YlNTODlseFlZS1VoV2Z2WE1OazVzVWVvL2U3QXpQTFo5Z0oxbHh0SmJkN1hKV29zcGNWdFF1SjZ3Z3lUbnZsWTRlMEtUYW95WUJvK1Y1bFl6MGdPMzRweEsyQjg1b0FocnVVV1Y5bFkwRE9wVlhuYjZxbDRicGNqY1J0RkFnZVRuRi9ranEzZFFsK1lBdjEyRQ==/attach/object/VEVNMAYATU" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>其中 cj代表的是第 j 枚硬币的面值，即我们枚举最后一枚硬币面额是 cj，那么需要从 i-cjj这个金额的状态 F(i-cj) 转移过来，再算上枚举的这枚硬币数量 1 的贡献，由于要硬币数量最少，所以 F(i)为前面能转移过来的状态的最小值加上枚举的硬币数量 1 。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> amount + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客周赛+div2</title>
      <link href="/2023/01/13/niu-ke-div2/"/>
      <url>/2023/01/13/niu-ke-div2/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客周赛"><a href="#牛客周赛" class="headerlink" title="牛客周赛"></a>牛客周赛</h1><h2 id="C-小红构造回文"><a href="#C-小红构造回文" class="headerlink" title=" C.小红构造回文"></a><a href="https://ac.nowcoder.com/acm/contest/73760/C"> C.小红构造回文</a></h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>小红拿到了一个回文串，她希望你将这个回文串重排，使得重排后仍然是回文串且和原串不同。你能帮帮她吗？</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>取回文串的第一个字符，向后查找与这个字符不同的字符下标，如果查找到该字符串的一半（字符串为奇数时查找到字符串长度减一的一半）还没有找到不同的字符，则输出-1。如果找到了，就将该位置和他对应的字符分别和第一个字符，最后一个字符交换即可。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scan.next();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> len / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ind</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) != c) &#123;</span><br><span class="line">                ind = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ind == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        chars[<span class="number">0</span>] = chars[ind];</span><br><span class="line">        chars[ind] = c;</span><br><span class="line">        chars[len - <span class="number">1</span>] = chars[<span class="number">0</span>];</span><br><span class="line">        chars[len - <span class="number">1</span> - ind] = chars[ind];</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : chars) &#123;</span><br><span class="line">            sb.append(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D-小红整数操作"><a href="#D-小红整数操作" class="headerlink" title="D.小红整数操作"></a><a href="https://ac.nowcoder.com/acm/contest/73760/D">D.小红整数操作</a></h2><h3 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h3><p>小红拿到了两个正整数x,y，她可以进行以下两种操作：</p><ol><li>将两个数同时乘以a。</li><li>若a既是x的因子，也是y的因子，则将两个数同时除以a。</li></ol><p> 小红希望最终两个数都在[l,r]区间内。她想知道最终的x有多少种不同的取值方案？</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>因为可以同时进行1和2两种操作。</p><p>设n为x和y的最大公约数，则x可以分解为xt * n，y可以分解为yt * n，此时xt和yt都不能再进行2操作</p><p>此时任何x 和 y 进行1操作都得到 a * x和a * y，相当于a * n * xt和a * n * yt。</p><p>此时任何x 和 y 进行2操作都得到 xt 和 yt 的倍数。</p><p>可以看出，x和y无论进行多少次1和2操作，都会得到xt和yt的倍数。要求[l , r]区间中的可能数，可以求xt * a和yt * a的在区间内有多少种可能性。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> (<span class="type">int</span>)gcd(x, y);</span><br><span class="line">        x = x / max;</span><br><span class="line">        y = y / max;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xl1</span> <span class="operator">=</span> l / x;</span><br><span class="line">        <span class="keyword">if</span>(l % x != <span class="number">0</span>) xl1 ++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xr1</span> <span class="operator">=</span> r / x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">yl1</span> <span class="operator">=</span> l / y;</span><br><span class="line">        <span class="keyword">if</span>(l % y != <span class="number">0</span>) yl1++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">yr1</span> <span class="operator">=</span> r / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.min(xr1, yr1)-Math.max(xl1, yl1)+<span class="number">1</span>;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">gcd</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (a % b == <span class="number">0</span>) ? b : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="E-小红树上染色"><a href="#E-小红树上染色" class="headerlink" title="E.小红树上染色"></a><a href="https://ac.nowcoder.com/acm/contest/73760/E">E.小红树上染色</a></h2><h3 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h3><p>小红拿到了一棵树，初始所有节点都是白色。<br> 小红希望染红若干个节点，使得不存在两个白色节点相邻。<br> 小红想知道，共有多少种不同的染色方案？<br> 由于答案过大，请对10^9+7取模。</p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>比赛的时候没有想到用List<Integer>[]类，构造的时候写错了。如果a，b两个边相邻，就将a加入nums[b]的list中，b加入到nums[a]的list中。这样子nums[i]中存放的就是当前节点的所有相连节点。将第一个节点当成根节点，nums[i]就是下标为i的节点下的所有子节点。因为list中也包含当前节点的父节点，所以在遍历的时候要判断去掉父节点。</p><p>用dp的思想，开辟一个二维数组，<code>dp[i][0]</code>存放当前节点染红的方案数，<code>dp[i][1]</code>存放当前节点不染的方案数。可以得到<code>dp[i][0]</code>等于子节点染红+不染的方案数之积，<code>dp[i][1]</code>等于子节点染红的方案数之积。</p><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[][] dp;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt;[] nums;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(br.readLine());</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="title class_">List</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            nums[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            String[] s = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line">            nums[a].add(b);</span><br><span class="line">            nums[b].add(a);</span><br><span class="line">        &#125;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dfs(<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        bw.write((dp[<span class="number">1</span>][<span class="number">0</span>] + dp[<span class="number">1</span>][<span class="number">1</span>]) % M + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        bw.flush();</span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> father)</span> &#123;</span><br><span class="line">        dp[cur][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[cur][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; lists = nums[cur];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != father) &#123;</span><br><span class="line">                dfs(i, cur);</span><br><span class="line">                dp[cur][<span class="number">0</span>] = ((dp[i][<span class="number">0</span>] + dp[i][<span class="number">1</span>]) * dp[cur][<span class="number">0</span>]) % M;</span><br><span class="line">                dp[cur][<span class="number">1</span>] = (dp[i][<span class="number">0</span>] * dp[cur][<span class="number">1</span>]) % M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="DIV2"><a href="#DIV2" class="headerlink" title="DIV2"></a>DIV2</h1><h2 id="B-A-Balanced-Problemset"><a href="#B-A-Balanced-Problemset" class="headerlink" title="B. A Balanced Problemset?"></a><a href="https://codeforces.com/contest/1925/problem/B">B. A Balanced Problemset?</a></h2><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>要将x分成n份，并且该n份的最大公约数最大，每一份可以写成a1 * m, a2 * m, a3 * m,……,an * m。</p><p>可以看出，m也是x的最大公约数，x=（a1+a2+a3+…+an）* m。</p><p>如果想要使m最大，那就要使（a1+a2+a3+…+an）尽可能小，所以要求x中大于 n 最小的约数。</p><h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="keyword">while</span> (t-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">tr</span> <span class="operator">=</span> x;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= x/i; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    x = x / i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x != <span class="number">1</span>) list.add(x);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> list.size();</span><br><span class="line">            <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[len +<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">                dp[i] = list.get(i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> get(list, <span class="number">0</span>, n, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(tr/val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(List&lt;Integer&gt; list,<span class="type">int</span> ind, <span class="type">int</span> n, <span class="type">int</span> min, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(min != <span class="number">0</span> &amp;&amp; sum &lt;= min &amp;&amp; sum &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != <span class="number">0</span>&amp;&amp; sum &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min == <span class="number">0</span> &amp;&amp; sum &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ind; i &lt; list.size(); i++) &#123;</span><br><span class="line">            min = get(list, i + <span class="number">1</span>, n, min, sum * list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Did-We-Get-Everything-Covered"><a href="#C-Did-We-Get-Everything-Covered" class="headerlink" title="C. Did We Get Everything Covered?"></a><a href="https://codeforces.com/contest/1925/problem/C">C. Did We Get Everything Covered?</a></h2><h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>要判断字符串是否包含前k个字母组成的所有长度为n的字符串，将k个字母全部出现一次算成一遍，统计一共出现过几遍。如果没有达到n遍，那么就输出NO。</p><p>要找反例，每次统计的时候将每一遍最后出现的那个字符记录下来，这样子就保证反例下一个字母是在下一遍中出现的。因为统计的遍数没有达到n，所以当记录到最后已经记录的字符数量肯定是小于n的，而将字符串剩下的字符中没有出现的字母记录下来，只要这个字母在前面已经记录过的字母后面出现，这时字符串就不能构成这样子的序列。</p><h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Integer.parseInt(br.readLine());</span><br><span class="line">        <span class="keyword">while</span> (t-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] s = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">2</span>]);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">            <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ind</span> <span class="operator">=</span> chars[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(ind &lt; k &amp;&amp; nums[ind] == cur) &#123;</span><br><span class="line">                    nums[ind]++;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">if</span>(count == k) &#123;</span><br><span class="line">                        sb.append(chars[i]);</span><br><span class="line">                        cur++;</span><br><span class="line">                        count = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur &gt;= n) &#123;</span><br><span class="line">                bw.write(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bw.write(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == cur) &#123;</span><br><span class="line">                    c = (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            bw.write(sb.toString()+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bw.flush();</span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛补题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全排列（算法）</title>
      <link href="/2022/12/11/quan-pai-lie-suan-fa/"/>
      <url>/2022/12/11/quan-pai-lie-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><a id="more"></a><p>示例 1：</p><p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br>示例 2：</p><p>输入：nums = [0,1]<br>输出：[[0,1],[1,0]]<br>示例 3：</p><p>输入：nums = [1]<br>输出：[[1]]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/permutations">https://leetcode.cn/problems/permutations</a></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            output.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        backtrack(n, output, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//n:小链表长度</span></span><br><span class="line"><span class="comment">//output:链表</span></span><br><span class="line"><span class="comment">//res:返回的链表</span></span><br><span class="line"><span class="comment">//frist: 表示从左往右填到第first 个位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> first)</span> &#123;</span><br><span class="line">        <span class="comment">// 所有数都填完了，将列表放到结果集中</span></span><br><span class="line">        <span class="keyword">if</span> (first == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(output));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// Collections.swap()交换集合中两个位置的元素</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">            <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">            backtrack(n, output, res, first + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 撤销交换</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p><img src="https://img-blog.csdnimg.cn/5b700828f40741269d332c1db9327d66.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/5b700828f40741269d332c1db9327d66.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20221211134609207"></p><p>采用回溯法，从左往右每一个位置都依此尝试填入一个数，看能不能填完这 n个空格。</p><p>如果first=n，代表已经填完n个数，将队列放到结果集中。否则，填入一个之前没有填入过的数，使i=first，在first后的数字都没有填入过队列中，所以遍历first以后的数字，将数字填入first位置上，填完继续填下一位置。将全部的位置填完后，回到上一次递归的位置，将交换的两个数交换回来，即i与first位置上的数，继续for循环，一直到最后，全部的可能都排列出来。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本周小结</title>
      <link href="/2022/12/04/ben-zhou-xiao-jie/"/>
      <url>/2022/12/04/ben-zhou-xiao-jie/</url>
      
        <content type="html"><![CDATA[<p>​        因为疫情原因，学校提前放假了，我们也开始了在家的学习。这周总体来讲是招新的事情比较多，在家学习的话，我感觉我的学习效率不是特别高。</p><p>​        <a id="more"></a></p><p>​        前两天新分配了一个项目，和上次我们写的项目差不多，都是商城项目。我们上一次的话我主要写的是用户相关的东西，这次把订单相关的部分分给我了，感觉还挺不错的。虽然两次项目是差不多的，但是我两次写的东西是完全不同的，不用担心和上次的撞了。这次的话我想借鉴一下别人的源码，因为事实上平时我是很少看别人源码的，这次仿着其他项目写，也可以看出来我写的不好的地方，进行一下改善。当然借鉴源码不是准备完全照搬，只是看一下别人项目有什么亮点，完善完善自己的代码。</p><p>​        这一段时间还是在学习JVM，说实话这段时间的学习不是很好，视频看过了忘得太快了，而且太多了，看完一遍差不多学习计划就要截止了。感觉我需要转化一下学习的方法了，要不跟着视频看一遍，估计什么都记不住。到时候考核的话我还要留出一段时间去复习源码，因为上一次学习源码的时候学的有点偏了，有一些地方根本没有学到，面试的时候回答的挺差劲的，所以需要这次去留出时间去复习。</p><p>​        因为这一段时间在进行招新活动，也招进来了一部分人了，我们组也进了几个学弟学妹。虽然感觉他们基础不是特别好，但是态度都挺好的，我说什么事情他们也都可听话，挺欣慰的。</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合面试题</title>
      <link href="/2022/11/27/ji-he-mian-shi-ti/"/>
      <url>/2022/11/27/ji-he-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ArrayList："><a href="#ArrayList：" class="headerlink" title="ArrayList："></a>ArrayList：</h1><h4 id="（1）JDK1-7和JDK1-8下ArrayList-底层数组的默认长度？"><a href="#（1）JDK1-7和JDK1-8下ArrayList-底层数组的默认长度？" class="headerlink" title="（1）JDK1.7和JDK1.8下ArrayList()底层数组的默认长度？"></a>（1）JDK1.7和JDK1.8下ArrayList()底层数组的默认长度？</h4><p>jdk1.7时使用ArrayList的无参构造，初始化后的长度是10，jdk1.8时使用无参构造，构造一个空数组，初始长度是0。</p><h4 id="（2）-如何复制某个ArrayList到另一个ArrayList中去？"><a href="#（2）-如何复制某个ArrayList到另一个ArrayList中去？" class="headerlink" title="（2） 如何复制某个ArrayList到另一个ArrayList中去？"></a>（2） 如何复制某个ArrayList到另一个ArrayList中去？</h4><p>使用clone()方法<br>使用ArrayList构造方法<br>使用addAll方法</p><h4 id="（3）arraylist怎么保证线程安全？"><a href="#（3）arraylist怎么保证线程安全？" class="headerlink" title="（3）arraylist怎么保证线程安全？"></a>（3）arraylist怎么保证线程安全？</h4><p>&lt;1&gt;、使用Vector</p><p>&lt;2&gt;、使用Collections.synchronizedList()</p><p>&lt;3&gt;、使用CopyOnWriteArrayList，涉及线程安全的部分，是通过写时复制的方式来实现。它内部有个volatile数组来保持数据。在“添加/修改/删除”数据时，会先获取互斥锁，再新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给volatile数组，然后再释放互斥锁。</p><p>1.在做修改操作的时候加锁</p><p>2.每次修改都是将元素copy到一个新的数组中，并且将数组赋值到成员变量array中。</p><p>3.利用volatile关键字修饰成员变量array，这样就可以保证array的引用的可见性，每次修改之前都能够拿到最新的array引用。</p><p>迭代器的弱一致性:弱一致性是指返回迭代器后，其他线程对list的增删改对迭代器是不可见的。</p><h4 id="（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？"><a href="#（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？" class="headerlink" title="（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？"></a>（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？</h4><p>使用ArrayList时，可以使用有参构造方法根据业务实际指定集合大小，以减少扩容的次数，提高写入效率。</p><h4 id="（5）Java集合的快速失败机制-“fail-fast”和安全失败机制“fail-safe”？"><a href="#（5）Java集合的快速失败机制-“fail-fast”和安全失败机制“fail-safe”？" class="headerlink" title="（5）Java集合的快速失败机制 “fail-fast”和安全失败机制“fail-safe”？"></a>（5）Java集合的快速失败机制 “fail-fast”和安全失败机制“fail-safe”？</h4><p>“fail-fast”是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。</p><p>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>“fail-safe”采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有的集合内容，在拷贝的集合上进行遍历。</p><p>原理：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><h4 id="（6）扩容机制？"><a href="#（6）扩容机制？" class="headerlink" title="（6）扩容机制？"></a>（6）扩容机制？</h4><p>首先判断当前数组是不是空数组，如果是空数组，那么将数据由0扩容到需求长度minCapacity，此时有参构造生成的空数组扩容到1，无参构造扩容到10，因为在计算minCapacity时，如果是无参构造，取默认长度和需求长度 minCapacity 中比较大的值，返回10。如果是有参构造的空数组，minCapacity返回1。</p><p>如果不是空数组，创建一个长度为原来数组长度1.5倍的新数组，当新数组长度大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于Integer的最大值，也就是溢出为负数，那么抛出内存溢出异常。否则的话根据与MAX_ARRAY_SIZE的比较情况确定返回Integer的最大值还是MAX_ARRAY_SIZE。最后将旧数组的值用Arrays.copyOf（）方法拷贝到新数组。</p><h4 id="（6）Iterator-和-ListIterator-有什么区别？"><a href="#（6）Iterator-和-ListIterator-有什么区别？" class="headerlink" title="（6）Iterator 和 ListIterator 有什么区别？"></a>（6）Iterator 和 ListIterator 有什么区别？</h4><p>（1）Iterator可以在所有集合中使用，而ListIterator只能在List类型和其子类型中使用</p><p>（2）ListIterator和Iterator都有hasnext（）和next（）方法可以实现顺序向后遍历，但是ListIterator有hasPrevious（）方法和previous（）方法，可以实现逆向遍历，Iterator不可以。</p><p>（3）ListIterator有add（）方法，可以向List中添加对象，而Iterator不能。</p><p>（4）ListIterator可以定位当前索引的位置，next Index（）和previous Index（）可以实现，Iterator没用此功能。</p><p>（5）两个都可以实现删除操作，但是ListIterator可以实现对象的修改，set（）方法可以实现，Iterator不能修改。</p><h4 id="（7）迭代器Iterator是什么？"><a href="#（7）迭代器Iterator是什么？" class="headerlink" title="（7）迭代器Iterator是什么？"></a>（7）迭代器Iterator是什么？</h4><p>Iterator是可以遍历集合的对象，为各种容器提供了公共的操作接口，隔离对容器的遍历操作和底层实现（解耦）。</p><p>迭代器是java23种设计模式之一，用于顺序访问集合对象的元素，无需知道集合对象的底层实现。</p><h4 id="（8）Array和ArrayList的区别？"><a href="#（8）Array和ArrayList的区别？" class="headerlink" title="（8）Array和ArrayList的区别？"></a>（8）Array和ArrayList的区别？</h4><p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</p><p>Array大小是固定的，所以需要事前确定合适的空间大小。ArrayList的大小是动态变化的，在每次添加新的元素的时候都会检查内部数组空间是否足够。</p><p>ArrayList提供了更多的方法和特性，比如：all All（），removeAll（），iterator（）等。</p><p>对于基本数据类型，ArrayList使用自动装箱来减少编码工作量；而当处理固定大小的基本数据类型的时候，这种方式相对比较慢，这时候应该使用Array。</p><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList:"></a>LinkedList:</h1><h4 id="（1）LinkedList-可以存储-null-值吗？元素可以重复吗？"><a href="#（1）LinkedList-可以存储-null-值吗？元素可以重复吗？" class="headerlink" title="（1）LinkedList 可以存储 null 值吗？元素可以重复吗？"></a>（1）LinkedList 可以存储 null 值吗？元素可以重复吗？</h4><p>LinkedList 底层是由双向链表实现的，并且在添加元素的时候，没有对元素进行值校验，所以可以存储 null 值，并且存储的元素是可以重复的。</p><h4 id="（2）LinkedList和ArrayList的相同点与不同点"><a href="#（2）LinkedList和ArrayList的相同点与不同点" class="headerlink" title="（2）LinkedList和ArrayList的相同点与不同点?"></a>（2）LinkedList和ArrayList的相同点与不同点?</h4><p><strong>相同点：</strong></p><p>都是List集合的实现类，允许出现重复的元素，元素有序。</p><p>都是不同步的，线程都不安全。</p><p><strong>不同点：</strong></p><p>ArratList集合的底层采用的是Object数组结构，LinkedList底层采用的是双向链表结构。</p><p>查询时，ArrayList实现了RandomAccess接口，支持随机访问，时间复杂度是O（1），LinkedList需要进行遍历，时间复杂度是O（n）。</p><p>在插入元素时，ArrayList插入和删除元素时，原数组该插入或者删除位置已经它之后的元素都要进行移位操作，时间复杂度都是O（n），而且增加的时候可能还会引起扩容。LinkedList只要遍历找到该索引在的位置然后改变指针指向即可，如果是添加到头节点前或者链表末尾的位置，时间复杂度就是O（1），如果是指定了索引位置，时间复杂度就是O（n），总体来讲LinkedList增加和删除时性能比ArrayList好。</p><p>空间占用方面，ArrayList存在一定的空间浪费，因为每次扩容都是以前的1.5倍。但是LinkedList每个元素都要存放它的前驱节点的位置和后继节点的位置，所以对每个元素的存储要比ArrayList消耗更大的空间。</p><p>ArrayList适合多读，增删少的情况，Linked适合少读，增删多的情况。</p><h4 id="（3）LinkedList版本前后变化？"><a href="#（3）LinkedList版本前后变化？" class="headerlink" title="（3）LinkedList版本前后变化？"></a>（3）LinkedList版本前后变化？</h4><p>LinkedList在1.6时底层是带头节点的双向循环列表，在1.7之后是不带头节点的双向链表。</p><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector:"></a>Vector:</h1><h4 id="（1）ArrayList和Vector的区别？"><a href="#（1）ArrayList和Vector的区别？" class="headerlink" title="（1）ArrayList和Vector的区别？"></a>（1）ArrayList和Vector的区别？</h4><p><strong>相同点：</strong></p><p>都实现了List接口。</p><p>底层数据结构都是数组。</p><p><strong>不同点：</strong></p><p>Verctor使用了Synchronized关键字来实现线程同步，所以线程是安全的，而ArrayList是线程不安全的。</p><p>在性能方面，因为Verctor很多方法使用了Synchronized关键字进行了加锁操作，所以性能不如ArrayList。</p><p>在扩容的时候，ArrayList扩容到原来的1.5倍，而Verctor扩容到原来的2倍。</p><p>Vector可以设置增长因子，而ArrayList不可以。</p><h4 id="（2）为什么不推荐使用Verctor？"><a href="#（2）为什么不推荐使用Verctor？" class="headerlink" title="（2）为什么不推荐使用Verctor？"></a>（2）为什么不推荐使用Verctor？</h4><p>Verctor每个操作方法都加的有synchronized关键字，针对性能来说会比较大的影响，导致它性能很差。</p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap:"></a>HashMap:</h1><h4 id="（1）HashMap-jdk1-7和1-8的区别？"><a href="#（1）HashMap-jdk1-7和1-8的区别？" class="headerlink" title="（1）HashMap jdk1.7和1.8的区别？"></a>（1）HashMap jdk1.7和1.8的区别？</h4><p>底层数据结构不一样，jdk1.7是链表加数组，数组用来存储数据，链表用来防止hash冲突。1.8是链表加数组加红黑树，数组用来存储数据，链表和红黑树用来防止hash冲突。在链表长度大于等于8并且数组长度大于64时链表会变成红黑树（数组长度小于64会进行扩容）。避免单条链表过长而影响查询效率，提高查询效率。</p><p>1.7新增链表节点会采用头插法，1.8新增链表节点采用尾插法，所以1.8不容易形成环形链表。</p><p>1.7在扩容后会按原来的方法重新计算扩容后元素的位置，1.8在扩容后元素计算在新数组中的位置时按规律计算，扩容后的位置=原来的位置或者原数组的长度+原位置。节省了重新计算hash值的时间。</p><p>1.7是先扩容后插入的，1.8是先插入后扩容。</p><p>在计算hash值的时候，1.7经过了四次位运算和五次异或运算一共九次扰动，1.8经过了一次异或运算和一次位运算一共两次扰动。（两次扰动分别是key.hashCode()与key.hashCode右移16位进行异或，这样子做的目的是高16位不变，低16位与高16位进行异或操作，进而减少碰撞的发生，高低位都参与到Hash的运算。如果不进行hash扰动，因为hash有32位，直接对数组长度取余，起作用的只是hash值的几个低位）。</p><h4 id="（2）为什么要增加红黑树？为什么不一直用红黑树？为什么到8转化为红黑树？到6转化为链表？"><a href="#（2）为什么要增加红黑树？为什么不一直用红黑树？为什么到8转化为红黑树？到6转化为链表？" class="headerlink" title="（2）为什么要增加红黑树？为什么不一直用红黑树？为什么到8转化为红黑树？到6转化为链表？"></a>（2）为什么要增加红黑树？为什么不一直用红黑树？为什么到8转化为红黑树？到6转化为链表？</h4><p>因为链表结构的查询效率是非常低的，他不像数组，能够通过索引开始找到想要的值，只能挨个遍历。当hash冲突很严重的时候，会严重影响查询的性能。当链化后链化特别严重，查询效率会退化到O（n），为了解决这个问题，jdk8中添加了红黑树来解决这个问题（时间复杂度O（logn））。</p><p>之所以不一直用红黑树，是为了权衡时间和空间，因为红黑树的节点占用空间是普通链表节点的两倍。</p><p>理想情况下随机hashCode算法下所有节点的分布频率会遵循泊松分布，链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。</p><p>因为转化成树和生成树的时间不会太短，为了避免频繁的转化。</p><h4 id="（3）为什么不用AVL树？为什么不用b树？为什么要用红黑树？"><a href="#（3）为什么不用AVL树？为什么不用b树？为什么要用红黑树？" class="headerlink" title="（3）为什么不用AVL树？为什么不用b树？为什么要用红黑树？"></a>（3）为什么不用AVL树？为什么不用b树？为什么要用红黑树？</h4><p>1、二叉排序树（二叉查找树）</p><p>1）若左子树不为空，则左子树上所有节点均小于根节点</p><p>2）若右子树不为空，则右子树上所有节点均大于根节点</p><p>3）左右子树也为二叉排序树</p><p>2、平衡二叉树（AVL树）：是一种二叉查找树，当且仅当两个子树的高度差不超过1时，这个树是二叉平衡树。</p><p>3、红黑树：是许多二叉查找树中的一种，它能保证在最坏的情况下，基本动态集合操作的时间为O（logn）。</p><p>每个节点非红即黑</p><p>根节点总是黑色的</p><p>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</p><p>每个叶子节点都是黑色的空节点（NIL节点）</p><p>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</p><h5 id="【1】为什么不用二叉排序树？"><a href="#【1】为什么不用二叉排序树？" class="headerlink" title="【1】为什么不用二叉排序树？"></a>【1】为什么不用二叉排序树？</h5><p>二叉排序树在添加元素的时候极端情况下会出现线性结构。（因为二叉排序树左子树所有的节点的值均小于根节点的特点，如果添加的元素都比根节点小，会导致左子树线性增长，这样就失去了用树型结构替换链表的初衷，导致查询时间增长），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p><h5 id="【2】为什么不用二叉平衡树（AVL树）？"><a href="#【2】为什么不用二叉平衡树（AVL树）？" class="headerlink" title="【2】为什么不用二叉平衡树（AVL树）？"></a>【2】为什么不用二叉平衡树（AVL树）？</h5><p>红黑树不追求完全平衡，他只要求部分达到平衡。红黑树是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数要比红黑树多。</p><p>在CurrentHashMap中是加锁了的，实际上是读写锁，如果写冲突就会等待，如果插入时间过程等待时间就更长，而红黑树相对于AVL树插入速度更快。</p><p>红黑树更加通用，它在添加，删除方面表现相对较好，但是AVL树的查找速度更快，代价是添加/删除速度较慢。</p><h5 id="【3】为什么不用B-B-树？"><a href="#【3】为什么不用B-B-树？" class="headerlink" title="【3】为什么不用B/B+树？"></a>【3】为什么不用B/B+树？</h5><p>B和B+树主要用于数据存储在磁盘上的场景，比如数据库索引就是用B+树实现的。这两种数据结构的特点就是树比较矮胖，每个结点存放一个磁盘大小的数据，这样一次可以把一个磁盘的数据读入内存，减少磁盘转动的耗时，提高效率。而红黑树多用于内存中排序，也就是内部排序。</p><h4 id="（4）HashMap-的方法？"><a href="#（4）HashMap-的方法？" class="headerlink" title="（4）HashMap 的方法？"></a>（4）HashMap 的方法？</h4><h5 id="【1】put方法？"><a href="#【1】put方法？" class="headerlink" title="【1】put方法？"></a>【1】put方法？</h5><p>调用hash函数获取key对应的hash值，再计算其数组下标。</p><p>如果没有出现hash冲突，则直接放入数组，如果出现hash冲突，则以链表的方式放在链表后面。如果链表的长度已经大于等于8，数组长度小于64进行扩容，数组长度大于64就把链表转化为红黑树。</p><p>如果节点的key已经存在，则替换value就行。</p><p>如果集合中的键值对大于数组长度*负载因子，调用resize（）方法进行扩容。</p><h5 id="【2】get方法？"><a href="#【2】get方法？" class="headerlink" title="【2】get方法？"></a>【2】get方法？</h5><p>通过hash&amp;（数组.length-1）获取该key对应的数据节点的hash值。</p><p>判断首节点是否为空，为空则直接返回空。</p><p>再判断首节点的key和目标值是否相同，相同则直接返回（首节点不用区分链表还是红黑树）。</p><p>首节点的next为空，则直接返回空。</p><p>首节点是树形节点，则进入红黑树的取值流程，并返回结果。</p><p>进入链表的取值流程，链表结构进行顺序遍历查找操作，每次用 == 符号 和 equals( ) 方法来判断 key 是否相同，满足条件则直接返回该结点。链表遍历完都没有找到则返回空。</p><h5 id="【3】resize方法（扩容）？"><a href="#【3】resize方法（扩容）？" class="headerlink" title="【3】resize方法（扩容）？"></a>【3】resize方法（扩容）？</h5><p>首先判断数组长度，如果大于0说明已经被初始化过，那么按当前数组长度的2倍进行扩容，阈值也变为原来的二倍。</p><p>若数组未被初始化过，且阈值大于0说明调用了HashMap的有参构造方法，那么就把数组大小设为阈值。</p><p>若数组未被初始化过，且阈值为0说明调用了HashMap的无参构造方法，那么就把数组的大小设为16，阈值设为16*负载因子。</p><p>接着需要判断如果不是第一次初始化，那么扩容之后1，要通过hash&amp;旧数组中的位置重新计算键值对的位置，若为0索引位置不变，不为0则并把他们新的位置=旧位置+旧数组长度，如果节点是红黑树类型的化则需要进行红黑树的拆分。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PC寄存器</title>
      <link href="/2022/11/20/pc-ji-cun-qi/"/>
      <url>/2022/11/20/pc-ji-cun-qi/</url>
      
        <content type="html"><![CDATA[<p><strong>使用PC寄存器存储字节码指令地址有什么用呢?为什么使用PC寄存器记原当前线程的执行地址呢?</strong><br>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。<br>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="https://img-blog.csdnimg.cn/90e5e881b0e24efd9a388500454e70d4.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/90e5e881b0e24efd9a388500454e70d4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>PC寄存器为什么会被设定为线程私有?</strong><br>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢﹖为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个Pc寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互千扰的情况。<br>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。<br>这样必然导致经常中断或恢复，如何保证分毫无差呢﹖每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒杀功能</title>
      <link href="/2022/11/12/shang-cheng-xiang-mu-miao-sha-gong-neng/"/>
      <url>/2022/11/12/shang-cheng-xiang-mu-miao-sha-gong-neng/</url>
      
        <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>这次完善项目的时候加入了秒杀功能。这个功能要考虑的地方挺多的，我在网上找了一些资料，然后把这个功能大致完成了。但是还有很多地方我没考虑到，有些地方实现的不是很好，等以后再回头看对这个功能进行进一步的完善吧。</p><a id="more"></a><h2 id="记录一下我现在实现的一些功能："><a href="#记录一下我现在实现的一些功能：" class="headerlink" title="记录一下我现在实现的一些功能："></a>记录一下我现在实现的一些功能：</h2><h3 id="redis做缓存"><a href="#redis做缓存" class="headerlink" title="redis做缓存:"></a>redis做缓存:</h3><p>因为秒杀这个功能并发性是很大的，所以如果在秒杀的时候直接对mysql数据库进行操作，数据库可能承受不住，所以一般情况下都会用redis做缓存，将秒杀商品的信息存到redis里面，当redis里面查不到数据的时候再进入mysql查询，如果查询到数据，就将mysql中的数据写入到redis。</p><img src="https://img-blog.csdnimg.cn/495b19609c4a4e37a53dab3da59a9c91.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/495b19609c4a4e37a53dab3da59a9c91.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" style="zoom: 67%;" /><h3 id="库存问题："><a href="#库存问题：" class="headerlink" title="库存问题："></a>库存问题：</h3><p>在扣减内存时，要先判断一个用户是否已经购买过，确定未购买再进行扣减内存。但因为查询数据库和更新数据库不是原子性操作，在并发性很高的情况下，可能会出现超卖的情况。这时候可以使用lua脚本，查询和扣减内存的操作均在lua中进行，可以保证原子性。</p><p>key[1]:用来存储已经进行秒杀过的用户id</p><p>key[2]:存储秒杀商品内存</p><p>ARGV[1]:用户id</p><p>ARGV[2]:订单信息类转化为的Json</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> userKey=KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> stockKey=KEYS[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">local</span> userId=ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> orderMsg=ARGV[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">local</span> userExists=redis.call(<span class="string">&#x27;sismember&#x27;</span>,userKey,userId)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(userExists)==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, stockKey) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>,stockKey));</span><br><span class="line">    <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>);</span><br><span class="line">        redis.call(<span class="string">&#x27;sadd&#x27;</span>,userKey,userId);</span><br><span class="line">        redis.call(<span class="string">&#x27;lpush&#x27;</span>,<span class="string">&#x27;orderList&#x27;</span>,orderMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>-2:用户已经秒杀过，不能再进行秒杀</p><p>-1:秒杀商品在redis里面不存在，返回后对数据库进行查询，如果商品存在将商品信息存入redis，不存在直接返回</p><p>0:库存不足，直接返回</p><p>1:秒杀成功，将库存减一，用户id存入已经秒杀过的用户中</p><h3 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h3><p>在秒杀时先从redis数据库中查询数据，如果数据不存在就进入mysql查询。但是在高并发的情况下，一瞬间有很多请求同时进行，此时在redis中查询不到数据，就会全部进入mysql查询，会造成缓存击穿。解决缓存击穿有好几种方案，例如：热数据设置永不过期、加分布式锁。这里我使用了分布式锁，就是让很多请求同时查询不到数据的时候，只允许一个请求对mysql进行操作，这个请求将mysql中的数据读取到redis之后，其他请求再进入redis进行查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(result.equals(MagicIntegerEnum.STOCK_NO_EXIST.getKey()))&#123;</span><br><span class="line">    String lockKey=<span class="string">&quot;killLock&quot;</span>;</span><br><span class="line">    result = luaUtil.runLuaScript(<span class="string">&quot;Stock.lua&quot;</span>,keyList,userId.toString(),orderJson);</span><br><span class="line">    <span class="type">String</span> <span class="variable">userValue</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisUtil.setNx(lockKey, userValue, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        <span class="type">SecKill</span> <span class="variable">kill</span> <span class="operator">=</span> killDao.getByProId(proId, <span class="number">1</span>);</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(lockKey);</span><br><span class="line">        <span class="keyword">if</span>(kill==<span class="literal">null</span>)&#123;</span><br><span class="line">            luaUtil.runLockLua(<span class="string">&quot;Lock.lua&quot;</span>,list,userValue);</span><br><span class="line">            <span class="keyword">return</span> ReturnUtil.error(<span class="string">&quot;无秒杀商品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(redisUtil.hasKey(userKey)) &#123;</span><br><span class="line">            size = redisUtil.setMembers(userKey).size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> stock=kill.getKillStock()-size;</span><br><span class="line">        redisUtil.set(killKey, Integer.toString(stock));</span><br><span class="line">        luaUtil.runLockLua(<span class="string">&quot;Lock.lua&quot;</span>,list,userId.toString());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*只有在 key 不存在时设置 key 的值,将值 value 关联到 key ,设置过期时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setNx</span><span class="params">(String key,String value,<span class="type">long</span> timeout,TimeUnit unit)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForValue().setIfAbsent(key, value, timeout, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置过期时间，防止死锁。</p><p>如果在进行删除操作之前，一个锁刚好到过期时间，此时另一个请求正好加锁，就会释放掉别人的锁，所以加锁的时候要加userValue，在释放锁的时候判断一下是否是自己的锁，如果是，再将锁释放。因为在get和del之间可能也会出现异常，所以也要保证原子性，就在使用了lua脚本。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lockKey=KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> userValue=ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> exist=redis.call(<span class="string">&#x27;exists&#x27;</span>, lockKey);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(exist)==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;get&#x27;</span>,lockKey)==userValue) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;del&#x27;</span>,lockKey));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="异步下单："><a href="#异步下单：" class="headerlink" title="异步下单："></a>异步下单：</h3><p>在秒杀之后下单的操作其实并发性并没有那么高，我在网上找了一些资料，发现很多时候秒杀下单的时候会采用mq消息队列进行异步处理。但是因为我对这个不是很了解，就使用了redis的list做消息队列，这一部分完成的不是很理想，因为目前我对线程这一块的知识了解的特别特别特别模糊，等以后我学习了更多知识后再对这一部分进行完善。</p><p>目前的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        SKILL_ORDER.submit(<span class="keyword">new</span> <span class="title class_">OrderHandle</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderHandle</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            String queue=<span class="string">&quot;orderList&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">orderJson</span> <span class="operator">=</span> redisUtil.lBRightPop(queue, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">                    <span class="keyword">if</span> (orderJson == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(orderJson)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> JSON.parseObject(orderJson, Order.class);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) ((Math.random() * <span class="number">9</span> + <span class="number">1</span>) * <span class="number">100000</span>);</span><br><span class="line">                    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">                    <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMss&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> localDateTime.format(formatter);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> format + order.getUserId() + order.getProId() + order.getAddId() + i;</span><br><span class="line">                    <span class="type">SecKill</span> <span class="variable">kill</span> <span class="operator">=</span> killDao.getByProId(order.getProId(), <span class="number">1</span>);</span><br><span class="line">                    order.setOrderCode(code);</span><br><span class="line">                    order.setOrderPrice(kill.getKillPrice());</span><br><span class="line">                    orderDao.insertOrder(order);</span><br><span class="line">                    String orderKey=<span class="string">&quot;killOrder:&quot;</span>+order.getOrderId();</span><br><span class="line">                    redisUtil.setEx(orderKey,<span class="string">&quot;1&quot;</span>,<span class="number">10</span>,TimeUnit.MINUTES);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>@PostConstruct：在类启动的时候运行。</p><p>构造方法 ——&gt; @Autowired —— &gt; @PostConstruct ——&gt; 静态方法 （按此顺序加载）</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>客服功能</title>
      <link href="/2022/11/05/shang-cheng-xiang-mu-ke-fu-gong-neng/"/>
      <url>/2022/11/05/shang-cheng-xiang-mu-ke-fu-gong-neng/</url>
      
        <content type="html"><![CDATA[<p>最近一段时间我们在完善项目，我们在写的项目是一个商城项目。上次考核的时候考虑到进度问题，客服功能只做了一半，这次项目我对它进行了完善。</p><a id="more"></a><p>客服功能因为要实现即时通信，我主要是基于websocket实现的，它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。因为是第一次去写类似的功能，所以在实现过程中遇到了很多问题。</p><h3 id="离线消息："><a href="#离线消息：" class="headerlink" title="离线消息："></a><strong>离线消息</strong>：</h3><p>因为客服和用户并不是一直在线的，但是在用户离线的时候别人向他发送的消息他也应该接收到。所以在发送信息的时候我加了一个判断，当用户离线的时候将接收到的信息存到redis里面，在用户连接websocket的查询redis判断用户是否有离线的信息，如果有，在登录的时候一起发送过来。</p><p>发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Session</span> <span class="variable">userSession</span> <span class="operator">=</span> map.get(<span class="string">&quot;user:&quot;</span> + userId);</span><br><span class="line"><span class="keyword">if</span> (userSession != <span class="literal">null</span>) &#123;</span><br><span class="line">            userSession.getAsyncRemote().sendText(msgJson);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;msg@&quot;</span> + message.getUserId() + <span class="string">&quot;:offLine&quot;</span>;</span><br><span class="line">            redisUtil.lLeftPush(userKey, msgJson);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>登录时判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String chatKey= <span class="string">&quot;msg@&quot;</span> +userId + <span class="string">&quot;:offLine&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(redisUtil.hasKey(chatKey)&amp;&amp;redisUtil.lLen(chatKey)!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> redisUtil.lRightPop(chatKey);</span><br><span class="line">    session.getAsyncRemote().sendText(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="角色绑定："><a href="#角色绑定：" class="headerlink" title="角色绑定："></a>角色绑定：</h3><p>因为店铺与客服是一对多的关系，一个店铺里面可以有多个客服在线，当用户与客服进行聊天时，要保证一个客服和一个用户进行聊天，否则不符合逻辑。所以写项目的时候我给聊天列表设置了一个状态，客服可以查看所有的聊天列表，然后选择性进行接取业务，当一个聊天列表被一个客服接取后，其他客服不能进入这个聊天列表与用户进行聊天。</p><p>因为店铺与客服的一对多的关系，所以在用户反馈的时候该店铺的所有客服都可以看到聊天记录。我在用户给店铺发送信息的时候，先查询店铺里面有哪些客服，再查询客服的session，遍历给客服发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(value = &quot;/websocket/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketUtil&gt; webSocketSet = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;WebSocketUtil&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Session&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//    private static Map&lt;Integer, List&lt;Integer&gt;&gt; storeMap=new HashMap&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChatDao chatDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRedisUtil</span><span class="params">(RedisUtil redisUtil)</span>&#123;</span><br><span class="line">        WebSocketUtil.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChatDao</span><span class="params">(ChatDao chatDao)</span>&#123;</span><br><span class="line">        WebSocketUtil.chatDao = chatDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session,<span class="meta">@PathParam(&quot;userId&quot;)</span>Integer userId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.session = session;</span><br><span class="line">        <span class="built_in">this</span>.key=<span class="string">&quot;user:&quot;</span>+userId;</span><br><span class="line">        map.put(key, session);</span><br><span class="line">        String chatKey= <span class="string">&quot;msg@&quot;</span> +userId + <span class="string">&quot;:offLine&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(redisUtil.hasKey(chatKey)&amp;&amp;redisUtil.lLen(chatKey)!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> redisUtil.lRightPop(chatKey);</span><br><span class="line">            session.getAsyncRemote().sendText(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        webSocketSet.add(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//加入set中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;有新连接加入:&quot;</span>+userId+<span class="string">&quot;,当前在线人数为&quot;</span> + webSocketSet.size());</span><br><span class="line">        <span class="built_in">this</span>.session.getAsyncRemote().sendText(<span class="string">&quot;恭喜&quot;</span>+userId+<span class="string">&quot;成功连接上WebSocket(其频道号：&quot;</span>+userId+<span class="string">&quot;)--&gt;当前在线人数为：&quot;</span>+webSocketSet.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span> &#123;</span><br><span class="line">        webSocketSet.remove(<span class="built_in">this</span>);  <span class="comment">//从set中删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;有一连接关闭！当前在线人数为&quot;</span> + webSocketSet.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息*/</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message,<span class="meta">@PathParam(&quot;id&quot;)</span> String id)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生错误时调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">( Throwable error)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发生错误&quot;</span>);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 群发自定义消息</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">broadcast</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (WebSocketUtil item : webSocketSet) &#123;</span><br><span class="line">            <span class="comment">//同步异步说明参考：http://blog.csdn.net/who_is_xiaoming/article/details/53287691</span></span><br><span class="line">            <span class="comment">//this.session.getBasicRemote().sendText(message);</span></span><br><span class="line">            item.session.getAsyncRemote().sendText(message);<span class="comment">//异步发送消息.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(Integer userId, Integer storeId, Message message)</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">userSession</span> <span class="operator">=</span> map.get(<span class="string">&quot;user:&quot;</span> + userId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msgJson</span> <span class="operator">=</span> JSON.toJSONString(message);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userListKey</span> <span class="operator">=</span> <span class="string">&quot;userList:&quot;</span> + userId + <span class="string">&quot;@chat&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">storeListKey</span> <span class="operator">=</span> <span class="string">&quot;storeList:&quot;</span> + storeId + <span class="string">&quot;@chat&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">userList</span> <span class="operator">=</span> (<span class="type">int</span>) Double.parseDouble(redisUtil.zScore(userListKey, storeId + <span class="string">&quot;&quot;</span>) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">storeList</span> <span class="operator">=</span> (<span class="type">int</span>) Double.parseDouble(redisUtil.zScore(storeListKey, userId + <span class="string">&quot;&quot;</span>) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//发送给用户.</span></span><br><span class="line">        <span class="keyword">if</span> (userSession != <span class="literal">null</span>) &#123;</span><br><span class="line">            userSession.getAsyncRemote().sendText(msgJson);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;msg@&quot;</span> + message.getUserId() + <span class="string">&quot;:offLine&quot;</span>;</span><br><span class="line">            redisUtil.lLeftPush(userKey, msgJson);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        List&lt;Integer&gt; list = storeMap.get(storeId);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;msg@&quot;</span> + userList + <span class="string">&quot;:message&quot;</span>;</span><br><span class="line">        redisUtil.lLeftPush(userKey, msgJson);</span><br><span class="line">        <span class="type">String</span> <span class="variable">storeKey</span> <span class="operator">=</span> <span class="string">&quot;msg@&quot;</span> + storeList + <span class="string">&quot;:message&quot;</span>;</span><br><span class="line">        redisUtil.lLeftPush(storeKey, msgJson);</span><br><span class="line">        Integer chatListId;</span><br><span class="line">        <span class="keyword">if</span> (message.getMessageStatus() == <span class="number">0</span>) &#123;</span><br><span class="line">            chatListId = storeId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chatListId = userId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">numKey</span> <span class="operator">=</span> <span class="string">&quot;chat@No:&quot;</span> + chatListId + <span class="string">&quot;num&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (redisUtil.hasKey(numKey)) &#123;</span><br><span class="line">            redisUtil.incrBy(numKey, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisUtil.set(numKey, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(redisUtil.hasKey(<span class="string">&quot;chatService:&quot;</span>+storeId))&#123;</span><br><span class="line">            Set&lt;String&gt; strings = redisUtil.setMembers(<span class="string">&quot;chatService:&quot;</span> + storeId);</span><br><span class="line">             list = strings.stream().map(Integer::parseInt).collect(Collectors.toList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer id :</span><br><span class="line">                    list) &#123;</span><br><span class="line">                <span class="type">Session</span> <span class="variable">chatSession</span> <span class="operator">=</span> map.get(<span class="string">&quot;user:&quot;</span> + id);</span><br><span class="line">                String chatKey;</span><br><span class="line">                <span class="keyword">if</span> (chatSession != <span class="literal">null</span>) &#123;</span><br><span class="line">                    chatSession.getAsyncRemote().sendText(msgJson);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    chatKey = <span class="string">&quot;msg@&quot;</span> + message.getUserId() + <span class="string">&quot;:offLine&quot;</span>;</span><br><span class="line">                    redisUtil.lLeftPush(chatKey, msgJson);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引</title>
      <link href="/2022/10/30/mysql-suo-yin/"/>
      <url>/2022/10/30/mysql-suo-yin/</url>
      
        <content type="html"><![CDATA[<p>mysql索引</p><a id="more"></a><h3 id="索引类型："><a href="#索引类型：" class="headerlink" title="索引类型："></a>索引类型：</h3><h4 id="按逻辑："><a href="#按逻辑：" class="headerlink" title="按逻辑："></a>按逻辑：</h4><p>普通索引：普通索引是mysql中最基本的索引，允许在列中插入重复值和空值，唯一的任务就是加快数据访问速度。</p><p>唯一索引：避免数据重复，唯一索引列的值必须唯一，允许有空值，如果是组合索引，则列值的组合必须唯一。</p><p>主键索引：主键索引是专门为主键字段创建的索引，一个表只能有一个主键，不允许有空值。</p><p>组合索引：在多个字段上创建的索引，只有在查询的时候使用了创建索引时的第一个字段，才会使用索引，遵循最左前缀原则。</p><p>全文索引：全文索引主要用来查询文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。只能在 CHAR、VARCHAR 或 TEXT 类型的列上创建。在mysql引擎中只有MyISAM引擎支持全文索引。</p><h3 id="索引优缺点："><a href="#索引优缺点：" class="headerlink" title="索引优缺点："></a>索引优缺点：</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>通过创建唯一索引，可以保持数据库中数据的唯一性。</p><p>使用索引可以大幅度提升系统性能，提高查询速度。</p><p>可以降低查询中分组和排序的时间。</p><p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>索引需要占用额外的物理空间。</p><p>当数据量非常大时，维护和创建索引也所耗费的时间也是非常大的。</p><p>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降<br>低了数据的维护速度。</p><h4 id="什么样的字段适合创建索引？"><a href="#什么样的字段适合创建索引？" class="headerlink" title="什么样的字段适合创建索引？"></a>什么样的字段适合创建索引？</h4><p>在经常需要搜索的列上，可以加快搜索的速度。</p><p>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。</p><p>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。</p><p>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p><h4 id="什么样的字段不适合创建索引？"><a href="#什么样的字段不适合创建索引？" class="headerlink" title="什么样的字段不适合创建索引？"></a>什么样的字段不适合创建索引？</h4><p>在查询中很少使用的列不应该创建索引。因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>数据值很少的表格也不应该创建索引。因为，当数据太少的时候，全盘搜索可能都比索引查找还快，就没有必要创建索引了，反而还会降低磁盘空间和性能。</p><p>定义为text、image和bit数据类型的列不应该创建索引。因为，这种列要么是数据相当大要么是数据相当少。</p><p>当修改性能远大于检索性能时不应该创建索引。因为，修改性能和检索性能是相矛盾的，两者只会一增一减。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector</title>
      <link href="/2022/10/18/vector/"/>
      <url>/2022/10/18/vector/</url>
      
        <content type="html"><![CDATA[<p>Vector是基于数组实现的随机访问的同步的List结构，其public方法都是加锁的（加锁后不再需要临时变量保持原子性）</p><a id="more"></a><h2 id="Vector的继承关系"><a href="#Vector的继承关系" class="headerlink" title="Vector的继承关系:"></a>Vector的继承关系:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>继承了 AbstractList 抽象类，实现了 List 接口，实现了 RandomAccess, Cloneable, java.io.Serializabl e接口，所以支持快速访问、复制(拷贝)、序列化。</p><p>查和改操作速度非常快【时间复杂度：O(1)】,增和删操作相对较慢【时间复杂度：最快O(1)最慢O(n)】。</p><p>相比于 ArrayList 其效率低，因为加入了 synchronized 操作。</p><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized:"></a>Synchronized:</h4><p>线程安全是并发编程中的重要关注点，应该注意到的是，造成线程安全问题的主要诱因有两点:</p><ul><li>一是存在共享数据(也称临界资源)</li><li>二是存在多条线程共同操作共享数据</li></ul><p>为了解决这个问题，我们可能需要这样一个方案，当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行，这种方式有个高尚的名称叫互斥锁，即能达到互斥访问目的的锁，也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。在 Java 中，关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到synchronized另外一个重要的作用，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能），这点确实也是很重要的。</p><p>synchronized 是悲观锁的实现，因为 synchronized 修饰的代码，每次执行时都会进行加锁操作，同时只允许一个线程进行操作，所以它是悲观锁的实现。</p><p>synchronized 是非公平锁，并且是不可设置的。这是因为非公平锁的吞吐量大于公平锁，并且是主流操作系统线程调度的基本选择，所以这也是 synchronized 使用非公平锁原因。</p><p>同时，synchronized是一个典型的可重入锁，可重入锁最大的作用是避免死锁。</p><p><strong>三大特性：</strong><br><strong>synchronized保证原子性：</strong><br>1.通过monitorenter和monitorexit指令，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。<br>2.即使在执行过程中，由于某种原因，比如CPU时间片用完，线程1放弃了CPU，但是它并没有进行解锁。而由于synchronized的锁是可重入的，这就保证下一个时间片还是只能被他自己获取到，还是会继续执行代码。直到所有代码执行完为止。</p><p><strong>synchronized保证可见性：</strong><br>对于一个被synchronized修饰的变量，在其解锁之前，必须先把此变量同步回主存当中。</p><p><strong>synchronized保证有序性：</strong><br> 尽管synchronized无法禁止指令重排和处理器优化，但是可以通过单线程机制来保证有序性。由于synchronized修饰的代码，在同一时刻只能被同一线程访问，从根本上避免了多线程的情况。而单线程环境下，在本线程内观察到的所有操作都是天然有序的，所以synchronized可以通过单线程的方式来保证程序的有序性。</p><h2 id="LinkList主要方法分析："><a href="#LinkList主要方法分析：" class="headerlink" title="LinkList主要方法分析："></a>LinkList主要方法分析：</h2><h4 id="（一）字段"><a href="#（一）字段" class="headerlink" title="（一）字段"></a>（一）字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//储存Vector元素的数组</span></span><br><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Vector元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> elementCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Vector扩容增加的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> capacityIncrement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2767605614048989439L</span>;</span><br></pre></td></tr></table></figure><h4 id="（二）构造方法"><a href="#（二）构造方法" class="headerlink" title="（二）构造方法"></a>（二）构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  <span class="comment">//如果容量不合法，则抛出非法参数异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity]; <span class="comment">//设置新数组</span></span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;  <span class="comment">//赋值增加的容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造方法，initialCapacity数组容量，调用另一个有参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造方法，调用一个有参构造方法，容量设为10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造方法，构造指定列表内的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();  <span class="comment">//将集合转化为数组</span></span><br><span class="line">    elementCount = a.length;  <span class="comment">//赋值元素数量</span></span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;  <span class="comment">//如果c的类型是ArrayList，则直接对elementData赋值</span></span><br><span class="line">        elementData = a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elementData = Arrays.copyOf(a, elementCount, Object[].class); <span class="comment">//如果不是，进行转化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（三）常用方法"><a href="#（三）常用方法" class="headerlink" title="（三）常用方法"></a>（三）常用方法</h4><p><strong>扩容算法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部可以调用的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        modCount++; <span class="comment">//修改次数加一</span></span><br><span class="line">        ensureCapacityHelper(minCapacity);  <span class="comment">//调用ensureCapacityHelper()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)  <span class="comment">//如果最小长度大于数组长度，进行扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果capacityIncrement &gt; 0，则每次扩容增加capacityIncrement，否则，容量翻倍</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">  <span class="comment">//如果新容量还是小于最小容量，则容量取最小容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">     <span class="comment">//如果扩容的容量大于整型的最大值，则进行异常处理或者赋值为整型最大值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity); </span><br><span class="line">    <span class="comment">//调用Arrays.copyOf() 创建一个新的数组并将数据拷贝到新数组中，最后让 elementData 进行引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">//如果最小容量小于0，抛出内存溢出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="comment">//如果最小容量大于最大容量，取Integer最大值，否则取最大容量</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? </span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一般情况下，扩容分为两种情况，第一种是初始化Vector指定capacityIncrement，且为正数，则每次扩容增加capacityIncrement；另一种情况是，初始化未指定capacityIncrement，则每次扩容的容量翻倍。</p><p><strong>转为数组：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">copyInto</span><span class="params">(Object[] anArray)</span> &#123;</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, anArray, <span class="number">0</span>, elementCount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, elementCount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; elementCount)</span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());</span><br><span class="line"></span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, elementCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; elementCount)</span><br><span class="line">        a[elementCount] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数的方法实现思路与ArrayList如出一辙，Vector和ArrayList都是操作数组来实现列表，因此其实现的逻辑基本一致。</p><h2 id="常见题"><a href="#常见题" class="headerlink" title="常见题"></a>常见题</h2><h4 id="（1）ArrayList和Vector的区别？"><a href="#（1）ArrayList和Vector的区别？" class="headerlink" title="（1）ArrayList和Vector的区别？"></a>（1）ArrayList和Vector的区别？</h4><p><strong>相同点：</strong></p><p>都实现了List接口。</p><p>底层数据结构都是数组。</p><p><strong>不同点：</strong></p><p>Verctor使用了Synchronized关键字来实现线程同步，所以线程是安全的，而ArrayList是线程不安全的。</p><p>在性能方面，因为Verctor很多方法使用了Synchronized关键字进行了加锁操作，所以性能不如ArrayList。</p><p>在扩容的时候，ArrayList扩容到原来的1.5倍，而Verctor扩容到原来的2倍。</p><p>Vector可以设置增长因子，而ArrayList不可以。</p><h4 id="（2）为什么不推荐使用Verctor？"><a href="#（2）为什么不推荐使用Verctor？" class="headerlink" title="（2）为什么不推荐使用Verctor？"></a>（2）为什么不推荐使用Verctor？</h4><p>Verctor每个操作方法都加的有synchronized关键字，针对性能来说会比较大的影响，导致它性能很差。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linklist</title>
      <link href="/2022/10/16/linklist/"/>
      <url>/2022/10/16/linklist/</url>
      
        <content type="html"><![CDATA[<p>LinkedList是一个双向链表的数据结构。</p><a id="more"></a><h2 id="LinkList的继承关系"><a href="#LinkList的继承关系" class="headerlink" title="LinkList的继承关系:"></a>LinkList的继承关系:</h2><p>LinkedList继承了AbstractSequentialList，从<em>Sequential</em>这个单词可以看出，该抽象类实现的是顺序访问的结构，因为可以推测可能和链表有关。ArrayList底层是由数组支持，而LinkedList是由双向链表实现的，其中的每个对象包含数据的同时还包含指向链表中前一个与后一个元素的引用。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7c77b61e791b55845538c2215f60844f.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/7c77b61e791b55845538c2215f60844f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><h4 id="AbstractSequentialList："><a href="#AbstractSequentialList：" class="headerlink" title="AbstractSequentialList："></a><strong>AbstractSequentialList：</strong></h4><p><img src="https://img-blog.csdnimg.cn/50b0d46e8acf42fda6fe44d16a8fe55b.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/50b0d46e8acf42fda6fe44d16a8fe55b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" style="zoom:50%;" /><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>AbstractSequentialList 是Java中位于 java.util 包下的一个抽象类，它继承了 AbstractList 类，，并实现了AbstractList没实现的get(int)方法。但是保留了listIterator(int)，获取迭代器方法。以最大限度地减少实现由“顺序访问”数据存储（如链表）接口所需的工作。对于随机访问数据（如数组），应优先使用 AbstractList<br>而非此类。</p><h4 id="Deque："><a href="#Deque：" class="headerlink" title="Deque："></a><strong>Deque</strong>：</h4><p>这个接口，这个类名字的由来是“double ended queue”，也就是双向队列，即从头部和尾部都可以进行队列的操作。</p><p><img src="https://img-blog.csdnimg.cn/7c936d6fd9c5447dace493c2c7567193.png#pic_center" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/7c936d6fd9c5447dace493c2c7567193.png#pic_center" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><h2 id="LinkList主要方法分析："><a href="#LinkList主要方法分析：" class="headerlink" title="LinkList主要方法分析："></a>LinkList主要方法分析：</h2><h4 id="（一）字段"><a href="#（一）字段" class="headerlink" title="（一）字段"></a>（一）字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个linklist的大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头结点，永远指向第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾节点，永远指向最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item; </span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">//指向后一个元素</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">//指向前一个元素</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>transient关键字：</strong></p><p>transient是短暂的意思。对于transient 修饰的成员变量，在类的实例对象的序列化处理过程中会被忽略。 因此，transient变量不会贯穿对象的序列化和反序列化，生命周期仅存于调用者的内存中而不会写到磁盘里进行持久化。</p><p><strong>为什么要用transient关键字？</strong></p><p>在持久化对象时，对于一些特殊的数据成员（如用户的密码，银行卡号等），我们不想用序列化机制来保存它。为了在一个特定对象的一个成员变量上关闭序列化，可以在这个成员变量前加上关键字transient。</p><p><strong>transient的作用：</strong></p><p>transient是Java语言的关键字，用来表示一个成员变量不是该对象序列化的一部分。当一个对象被序列化的时候，transient型变量的值不包括在序列化的结果中。而非transient型的变量是被包括进去的。  注意static修饰的静态变量天然就是不可序列化的。</p><p><strong>transient使用总结:</strong></p><p>（1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法被访问。</p><p>（2） transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</p><p>（3）一个静态变量不管是否被transient修饰，均不能被序列化(如果反序列化后类中static变量还有值，则值为当前JVM中对应static变量的值)。序列化保存的是对象状态，静态变量保存的是类状态，因此序列化并不保存静态变量。</p><h4 id="（二）构造方法"><a href="#（二）构造方法" class="headerlink" title="（二）构造方法"></a>（二）构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将集合变成一个双向链表linklist</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（三）常用方法"><a href="#（三）常用方法" class="headerlink" title="（三）常用方法"></a>（三）常用方法</h4><p><strong>add:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">     checkPositionIndex(index); <span class="comment">//检查索引是否越界</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (index == size) <span class="comment">//如果索引等于链表长度，则在尾节点后面插入</span></span><br><span class="line">         linkLast(element);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         linkBefore(element, node(index));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index)) <span class="comment">//检查是否可以插入</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//检查是否可以插入</span></span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将节点插入链表尾部（最后一个节点后面）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//将尾节点的值赋值给l</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);  <span class="comment">//新建节点，以l为前驱节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++; <span class="comment">//长度加一</span></span><br><span class="line">    modCount++; <span class="comment">//修好次数加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将节点插入链表头部（第一个结点前面）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;  <span class="comment">//将第一个节点的值赋值给f</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f); <span class="comment">//新建节点，以头结点为后继节点</span></span><br><span class="line">    first = newNode;<span class="comment">//将第一个节点赋值为新建节点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>) <span class="comment">//如果链表为空，最后一个尾节点也应该是新建的节点</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode; <span class="comment">//如果链表不为空，将原先头节点的前驱节点设为新建节点</span></span><br><span class="line">    size++; <span class="comment">//长度加一</span></span><br><span class="line">    modCount++; <span class="comment">//修好次数加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个节点前插入</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;  <span class="comment">//将succ节点的前驱节点赋值给pred</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ); <span class="comment">//创建新节点</span></span><br><span class="line">    succ.prev = newNode; <span class="comment">//设新节点为succ的前驱节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>) <span class="comment">//如果原本succ的前驱节点为空，则可以认为插入后头节点就是新节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode; <span class="comment">//否则，将pred的后继节点设为新节点</span></span><br><span class="line">    size++; <span class="comment">//长度加一</span></span><br><span class="line">    modCount++; <span class="comment">//修好次数加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addAll：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将集合从指定位置开始插入</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    checkPositionIndex(index); <span class="comment">//检查index是否在size之内</span></span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray(); <span class="comment">//将集合转化为数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)  <span class="comment">//如果数组长度为0，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;  <span class="comment">//得到插入节点的前驱节点和后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;<span class="comment">//如果插入节点为尾部，前驱节点就是last，后继节点就是null</span></span><br><span class="line">        succ = <span class="literal">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则，调用node获取后继节点，再获取前驱节点</span></span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;  <span class="comment">//遍历数据将数据插入</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>); <span class="comment">//创建新节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="literal">null</span>)<span class="comment">//如果前驱节点是null，证明新节点就是头节点</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;  <span class="comment">//更新前驱节点为新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="literal">null</span>) &#123; <span class="comment">//如果后继节点为空，那么尾节点就是集合最后一个节点，即最后更新为pred的新节点</span></span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则，将后继节点与前面的节点连接起来</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;<span class="comment">//扩大链表长度</span></span><br><span class="line">    modCount++; <span class="comment">//增加修改次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>remove：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除第一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first; <span class="comment">//获取第一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)<span class="comment">//如果为空，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(); <span class="comment">//没有这样的元素异常</span></span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f); <span class="comment">//调用unlinkFirst()方法对元素进行删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123; <span class="comment">//私有方法，只能类内调用</span></span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element= f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next; <span class="comment">//获取f的后继节点赋值给next</span></span><br><span class="line">    f.item = <span class="literal">null</span>;<span class="comment">//将f的值赋为空</span></span><br><span class="line">    f.next = <span class="literal">null</span>; <span class="comment">// 依靠GC回收</span></span><br><span class="line">    first = next;  <span class="comment">//将头节点赋值为f的后继节点next</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) <span class="comment">//如果后继节点为空，那么尾节点也为空</span></span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="literal">null</span>; <span class="comment">//否则，将后继节点的前驱节点赋值为空</span></span><br><span class="line">    size--;<span class="comment">//将链表长度减一</span></span><br><span class="line">    modCount++;  <span class="comment">//操作数加一</span></span><br><span class="line">    <span class="keyword">return</span> element;  <span class="comment">//返回删除元素的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;<span class="comment">//删除尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;  <span class="comment">//删除尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> &#123;  <span class="comment">//和删除头节点相似</span></span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="literal">null</span>;</span><br><span class="line">    l.prev = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;  <span class="comment">//遍历链表找到null</span></span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;  <span class="comment">//遍历链表找到o</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unlink(Node&lt;E&gt; x) &#123;<span class="comment">//删除一个元素x</span></span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next; <span class="comment">//将节点的下一个位置赋值给next</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;  <span class="comment">//将节点的上一个位置赋值给prev</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123; <span class="comment">//如果prev等于null，证明头节点为next</span></span><br><span class="line">        first = next; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//否则上一个位置的后继节点为next，删除节点的前驱节点赋值为null</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123; <span class="comment">//和前面相似</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="literal">null</span>;  <span class="comment">//要删除的节点赋值为null</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p><p><strong>get:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item; <span class="comment">//调用node()方法</span></span><br><span class="line">&#125;</span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;<span class="comment">//这里采用了索引分开搜索的方法，缩小一半的搜寻量</span></span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123; <span class="comment">//如果索引小于size的一半</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) <span class="comment">//for循环</span></span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)  <span class="comment">//如果索引大于size的一半</span></span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h4 id="（1）LinkedList-可以存储-null-值吗？元素可以重复吗？"><a href="#（1）LinkedList-可以存储-null-值吗？元素可以重复吗？" class="headerlink" title="（1）LinkedList 可以存储 null 值吗？元素可以重复吗？"></a><strong>（1）LinkedList 可以存储 null 值吗？元素可以重复吗？</strong></h4><p>LinkedList 底层是由双向链表实现的，并且在添加元素的时候，没有对元素进行值校验，所以可以存储 null 值，并且存储的元素是可以重复的。</p><h4 id="（2）LinkedList和ArrayList的相同点与不同点"><a href="#（2）LinkedList和ArrayList的相同点与不同点" class="headerlink" title="（2）LinkedList和ArrayList的相同点与不同点?"></a>（2）LinkedList和ArrayList的相同点与不同点?</h4><p><strong>相同点：</strong></p><p>都是List集合的实现类，允许出现重复的元素，元素有序。</p><p>都是不同步的，线程都不安全。</p><p><strong>不同点：</strong></p><p>ArratList集合的底层采用的是Object数组结构，LinkedList底层采用的是双向链表结构。</p><p>查询时，ArrayList实现了RandomAccess接口，支持随机访问，时间复杂度是O（1），LinkedList需要进行遍历，时间复杂度是O（n）。</p><p>在插入元素时，ArrayList插入和删除元素时，原数组该插入或者删除位置已经它之后的元素都要进行移位操作，时间复杂度都是O（n），而且增加的时候可能还会引起扩容。LinkedList只要遍历找到该索引在的位置然后改变指针指向即可，如果是添加到头节点前或者链表末尾的位置，时间复杂度就是O（1），如果是指定了索引位置，时间复杂度就是O（n），总体来讲LinkedList增加和删除时性能比ArrayList好。</p><p>空间占用方面，ArrayList存在一定的空间浪费，因为每次扩容都是以前的1.5倍。但是LinkedList每个元素都要存放它的前驱节点的位置和后继节点的位置，所以对每个元素的存储要比ArrayList消耗更大的空间。</p><p>ArrayList适合多读，增删少的情况，Linked适合少读，增删多的情况。</p><h4 id="（3）LinkedList版本前后变化？"><a href="#（3）LinkedList版本前后变化？" class="headerlink" title="（3）LinkedList版本前后变化？"></a>（3）LinkedList版本前后变化？</h4><p>LinkedList在1.6时底层是带头节点的双向循环列表，在1.7之后是不带头节点的双向链表。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arraylist</title>
      <link href="/2022/10/13/arraylist/"/>
      <url>/2022/10/13/arraylist/</url>
      
        <content type="html"><![CDATA[<p>ArrayList 是一个用数组实现的集合，支持随机访问，元素有序且可以重复。ArrayList继承AbstractList 并且实现了List和RandomAccess，Cloneable, Serializable接口。</p><a id="more"></a><h2 id="ArrayList继承关系："><a href="#ArrayList继承关系：" class="headerlink" title="ArrayList继承关系："></a>ArrayList继承关系：</h2><p><img src="https://img-blog.csdnimg.cn/2f2ba4f144434a548342fe7997fe4338.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/2f2ba4f144434a548342fe7997fe4338.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><h4 id="RandomAccess："><a href="#RandomAccess：" class="headerlink" title="RandomAccess："></a><strong>RandomAccess：</strong></h4><p><img src="https://img-blog.csdnimg.cn/93ccf2e44b284bb19af3b02bd6e0c63f.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/93ccf2e44b284bb19af3b02bd6e0c63f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>Linked并没有实现RandomAccess接口，RandomAccess接口是一个标志接口。</p><p>只要List集合实现这个接口，就能支持快速随机访问。随机访问就是表示我们可以在常量时间复杂度内访问数据，也就是时间复杂度是O(1)。而链表是不可以随机访问的，比如说我们想通过下标访问链表当中的某个数据，需要从头结点或者尾节点开始遍历，直到遍历到下标对应的数据，时间复杂度为O(n)。</p><p>当一个List拥有快速访问功能时，其遍历方法采用for循环最快速。而没有快速访问功能的List，遍历的时候采用Iterator迭代器最快速。</p><p>在这个类的JavaDoc中，描述了ArrayList的一些特征，主要如下：</p><p>允许 put null 值，会自动扩容；<br>size、isEmpty、get、set、add 等方法时间复杂度都是 O(1)；<br>是非线程安全的，多线程情况下，推荐使用线程安全类：Collections#synchronizedList；<br>增强 for 循环，或者使用迭代器迭代过程中，如果数组大小被改变，会快速失败，抛出异常。<br>JavaDoc中还提到了fail-fast机制，这个会在下面将迭代器时提到。</p><p>实现这个接口的一些类：</p><p>ArrayList，Vector，CopyOnWriteArrayList，RandomAccessSubList，UnmodifiableArrayList</p><h4 id="Serializable："><a href="#Serializable：" class="headerlink" title="Serializable："></a>Serializable：</h4><p>这个接口主要用于序列化，所谓序列化就是能将对象写入磁盘，反序列化就是能够将对象从磁盘当中读取出来，如果想序列化和反序列化<code>ArrayList</code>的实例对象就必须实现这个接口，如果没有实现这个接口，在实例化的时候程序执行会报错。</p><h4 id="Cloneable："><a href="#Cloneable：" class="headerlink" title="Cloneable："></a>Cloneable：</h4><p>和serializable一样是标志接口。实现Cloneable接口那么实现Cloneable的类就能够调用clone这个方法，如果没有实现Cloneable接口就调用方法，则会抛出异常java.lang.CloneNotSupportedException。</p><p>(1)浅克隆（shallow clone），在拷贝一个对象时，对对象的基本数据类型的成员变量进行拷贝，但对引用类型的成员变量只进行引用的传递，并没有创建一个新的对象，当对引用类型的内容修改会影响被拷贝的对象。</p><p>(2)深克隆（deep clone），在拷贝一个对象时，除了对基本数据类型的成员变量进行拷贝，对引用类型的成员变量进行拷贝时，创建一个新的对象来保存引用类型的成员变量。</p><p>1.为什么Object类中的clone方法定义为protected，而不是public?</p><p>因为不是每个对象都可以被克隆的。Java的设计者故意强制子类在其对象可克隆的情况下重写表方法。</p><p>2.为什么clone方法不是定义在Cloneable接口中呢?</p><p>因为Java提供了一个本地方法来执行一个浅复制以克隆一个对象。由于接口中的方法是抽象的，该本地方法不能在接口中实现。因此，Java的设计者决定在Object类中定义和实现本地clone方法。</p><h4 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h4><p>这个接口主要定义了一些集合常用的方法让ArrayList进行实现，比如add，addAll，contains，remove，set，size，indexOf等等方法。</p><p>AbstractList，这个抽象类也实现了List接口里面的方法，并且为其提供了默认代码实现。</p><h2 id="ArrayList主要方法分析："><a href="#ArrayList主要方法分析：" class="headerlink" title="ArrayList主要方法分析："></a>ArrayList主要方法分析：</h2><h4 id="（一）字段"><a href="#（一）字段" class="headerlink" title="（一）字段"></a>（一）字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">serialVersionUID属性是用来序列的标识符/反序列化的对象序列化类。我们使用serialVersionUID属性记住Serializable类的版本，以验证加载的类和序列化的对象是否兼容。</span></span><br><span class="line"><span class="comment">序列化运行时与每个可序列化的类关联一个版本号，称为serialVersionUID，在反序列化期间使用该版本号来验证序列化对象的发送者和接收者是否已加载了该对象的与序列化兼容的类。如果接收者为对象加载的类serialVersionUID与相应的发送者的类不同，则反序列化将导致 InvalidClassException。可序列化的类可以serialVersionUID通过声明一个serialVersionUID必须为static，final和type的字段来显式声明其自身long。不同类的serialVersionUID属性是独立的。因此，不同的类不必具有唯一的值。</span></span><br><span class="line"><span class="comment">如果可序列化的类未显式声明一个 serialVersionUID，则序列化运行时将根据serialVersionUID该类的各个方面为该类计算默认值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ArrayList 当中默认初始化容量，也就是初始化数组的大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用于空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用于默认大小的空实例的共享空数组实例。 </span></span><br><span class="line"><span class="comment">们将其与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时扩容多少。</span></span><br><span class="line"><span class="comment">无参构造函数 使用该数组初始化 与EMPTY_ELEMENTDATA的区别主要是区分作用，用来减少空数组的存在，优化内存使用 1.8后的优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存放具体数据的数组 ArrayList 底层就是使用数组进行存储的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">size 表示容器当中数据的个数 注意和容器的长度区分开来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure><p>private static final Object[] EMPTY_ELEMENTDATA = {};</p><p>private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</p><p>这两个是用来共享给空数组的，无参构造函数的空数组会用DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋值，有参构造函数的空数组会用EMPTY_ELEMENTDATA赋值。</p><h4 id="（二）构造方法"><a href="#（二）构造方法" class="headerlink" title="（二）构造方法"></a>（二）构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传入一个初始化容量，如果传入的数字大于零，则创建一个容量为 initialCapacity 的Object类型的数组</span></span><br><span class="line"><span class="comment">如果等于零，则引用一个空数组</span></span><br><span class="line"><span class="comment">因为容量不能小于零，所以当传入的数字小于零时，抛出一个异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity]; <span class="comment">//构造数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA; <span class="comment">//引入空数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);<span class="comment">//抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空参构造器，直接用DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传入了一个集合，如果这个集合的为空，直接传一个空数组</span></span><br><span class="line"><span class="comment">不为空，就判断是不是一个数组，是的话直接拷贝到elementData</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;        <span class="comment">//不为空</span></span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">            elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA; <span class="comment">//集合为空，直接传一个空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（三）常用方法"><a href="#（三）常用方法" class="headerlink" title="（三）常用方法"></a>（三）常用方法</h4><h4 id="add："><a href="#add：" class="headerlink" title="add："></a>add：</h4><p>放置新元素的时候没有进行任何的判断，所以ArrayList是允许null值的，且放置是没有加锁，使得ArrayList是线程不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接将待添加的元素放在数组末尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个函数的主要目的是确保 elementData 的容量有 size + 1</span></span><br><span class="line"><span class="comment">否则存储数据的时候数组就会越界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">//扩容</span></span><br><span class="line"><span class="comment">//size 表示容器当中数据的个数 注意和容器的长度区分开来,加入数据之后 容器当中数据的个数也要 + 1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在要求的位置放置某个元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">检查index位置是否可用,判断下是否超出数组范围，超出的话就会抛出IndexOutOfBoundsException异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);<span class="comment">//用ensureCapacityInternal()方法检查数组容量</span></span><br><span class="line"><span class="comment">//使用System.arraycopy方法将index位置及其之后的元素向后拷贝一个单位，再将待插入元素放置在index处即可。</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/img_convert/c067fed59830ddd05ca797cca4ded171.jpeg" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/c067fed59830ddd05ca797cca4ded171.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" style="zoom: 67%;" /><h4 id="ensureCapacityInternal（扩容部分的核心实现）"><a href="#ensureCapacityInternal（扩容部分的核心实现）" class="headerlink" title="ensureCapacityInternal（扩容部分的核心实现）:"></a>ensureCapacityInternal（扩容部分的核心实现）:</h4><img src="https://img-blog.csdnimg.cn/img_convert/deb6bbc2d7011c18712266c978d3e9ee.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/deb6bbc2d7011c18712266c978d3e9ee.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line"><span class="comment">// 如果是无参构造的话，取默认长度和需求长度 minCapacity 中比较大的值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该ArrayList是使用无参构造构建的，那么我们就需要返回DEFAULT_CAPACITY和minCapacity中较大的值。那么在第一次插入的时候，显然DEFAULT_CAPACITY较大，默认值为10，那么我们第一次插入，数组就会扩容为10。而使用有参构造参数为0的方法的话，在这一步返回的仅仅是1。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//调用了ensureExplicitCapacity方法</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++; <span class="comment">//将modCount自增一,这个表示容器发生改变的次数,它跟容器扩容没关系</span></span><br><span class="line">    <span class="comment">//如果最小的需求容量 minCapacity 大于现在容器当中数组的长度，则需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);<span class="comment">//调用grow()方法将底层数组扩容到minCapacity</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 新数组的长度为原数组的长度的1.5倍，右移一位相当于除以2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果新数组的长度，小于需要的最小的容量，则更新数组的长度为 minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line"><span class="comment">//将新的大小和MAX_ARRAY_SIZE的值比较，如果超过了这个值，那么newCapacity就会被赋为hugeCapacity()</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这个函数的主要目的是判断整数是否发生溢出</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 将旧数组的元素拷贝到新数组即可</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// 如果溢出，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果最少需要的值大于MAX_ARRAY_SIZE的话，就只会扩容到Integer.MAX_VALUE，否则就扩容到MAX_ARRAY_SIZE。这里就说明了ArrayList的容量上限为Integer.MAX_VALUE。如果达到了该值，就不会再为ArrayList分配空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove:"></a>remove:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据下标删除元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">//检查是否越界</span></span><br><span class="line"></span><br><span class="line">    modCount++;  <span class="comment">//将modCount自增一,这个表示容器发生改变的次数</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index); <span class="comment">//获取要删除的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>; <span class="comment">//判断数组后面还有多少元素</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) <span class="comment">//将删除元素后面的元素往前copy一份</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// 将最后一个元素设为null，可以进行垃圾回收了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除list中第一个等于o的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                fastRemove(index); <span class="comment">//调用fastRemove()删除指定下标的元素</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有方法，外部不能调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get:"></a>get:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">//检查是否越界</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size) <span class="comment">//越界抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关问题："><a href="#相关问题：" class="headerlink" title="相关问题："></a>相关问题：</h2><h4 id="（1）JDK1-7和JDK1-8下ArrayList-底层数组的默认长度？"><a href="#（1）JDK1-7和JDK1-8下ArrayList-底层数组的默认长度？" class="headerlink" title="（1）JDK1.7和JDK1.8下ArrayList()底层数组的默认长度？"></a>（1）JDK1.7和JDK1.8下ArrayList()底层数组的默认长度？</h4><p>jdk1.7时使用ArrayList的无参构造，初始化后的长度是10，jdk1.8时使用无参构造，构造一个空数组，初始长度是0。</p><h4 id="（2）-如何复制某个ArrayList到另一个ArrayList中去？"><a href="#（2）-如何复制某个ArrayList到另一个ArrayList中去？" class="headerlink" title="（2） 如何复制某个ArrayList到另一个ArrayList中去？"></a>（2） 如何复制某个ArrayList到另一个ArrayList中去？</h4><p>使用clone()方法<br>使用ArrayList构造方法<br>使用addAll方法</p><h4 id="（3）arraylist怎么保证线程安全？"><a href="#（3）arraylist怎么保证线程安全？" class="headerlink" title="（3）arraylist怎么保证线程安全？"></a>（3）arraylist怎么保证线程安全？</h4><p>&lt;1&gt;、使用Vector</p><p>&lt;2&gt;、使用Collections.synchronizedList()</p><p>&lt;3&gt;、使用CopyOnWriteArrayList，涉及线程安全的部分，是通过写时复制的方式来实现。它内部有个volatile数组来保持数据。在“添加/修改/删除”数据时，会先获取互斥锁，再新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给volatile数组，然后再释放互斥锁。</p><p>1.在做修改操作的时候加锁</p><p>2.每次修改都是将元素copy到一个新的数组中，并且将数组赋值到成员变量array中。</p><p>3.利用volatile关键字修饰成员变量array，这样就可以保证array的引用的可见性，每次修改之前都能够拿到最新的array引用。</p><p>迭代器的弱一致性:弱一致性是指返回迭代器后，其他线程对list的增删改对迭代器是不可见的。</p><h4 id="（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？"><a href="#（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？" class="headerlink" title="（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？"></a>（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？</h4><p>使用ArrayList时，可以使用有参构造方法根据业务实际指定集合大小，以减少扩容的次数，提高写入效率。</p><h4 id="（5）Java集合的快速失败机制-“fail-fast”和安全失败机制“fail-safe”？"><a href="#（5）Java集合的快速失败机制-“fail-fast”和安全失败机制“fail-safe”？" class="headerlink" title="（5）Java集合的快速失败机制 “fail-fast”和安全失败机制“fail-safe”？"></a>（5）Java集合的快速失败机制 “fail-fast”和安全失败机制“fail-safe”？</h4><p>“fail-fast”是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。</p><p>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>“fail-safe”采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有的集合内容，在拷贝的集合上进行遍历。</p><p>原理：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><h4 id="（6）扩容机制？"><a href="#（6）扩容机制？" class="headerlink" title="（6）扩容机制？"></a>（6）扩容机制？</h4><p>首先判断当前数组是不是空数组，如果是空数组，那么将数据由0扩容到需求长度minCapacity，此时有参构造生成的空数组扩容到1，无参构造扩容到10，因为在计算minCapacity时，如果是无参构造，取默认长度和需求长度 minCapacity 中比较大的值，返回10。如果是有参构造的空数组，minCapacity返回1。</p><p>如果不是空数组，创建一个长度为原来数组长度1.5倍的新数组，当新数组长度大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于Integer的最大值，也就是溢出为负数，那么抛出内存溢出异常。否则的话根据与MAX_ARRAY_SIZE的比较情况确定返回Integer的最大值还是MAX_ARRAY_SIZE。最后将旧数组的值用Arrays.copyOf（）方法拷贝到新数组。</p><h4 id="（6）Iterator-和-ListIterator-有什么区别？"><a href="#（6）Iterator-和-ListIterator-有什么区别？" class="headerlink" title="（6）Iterator 和 ListIterator 有什么区别？"></a>（6）Iterator 和 ListIterator 有什么区别？</h4><p>（1）Iterator可以在所有集合中使用，而ListIterator只能在List类型和其子类型中使用</p><p>（2）ListIterator和Iterator都有hasnext（）和next（）方法可以实现顺序向后遍历，但是ListIterator有hasPrevious（）方法和previous（）方法，可以实现逆向遍历，Iterator不可以。</p><p>（3）ListIterator有add（）方法，可以向List中添加对象，而Iterator不能。</p><p>（4）ListIterator可以定位当前索引的位置，next Index（）和previous Index（）可以实现，Iterator没用此功能。</p><p>（5）两个都可以实现删除操作，但是ListIterator可以实现对象的修改，set（）方法可以实现，Iterator不能修改。</p><h4 id="（7）迭代器Iterator是什么？"><a href="#（7）迭代器Iterator是什么？" class="headerlink" title="（7）迭代器Iterator是什么？"></a>（7）迭代器Iterator是什么？</h4><p>Iterator是可以遍历集合的对象，为各种容器提供了公共的操作接口，隔离对容器的遍历操作和底层实现（解耦）。</p><p>迭代器是java23种设计模式之一，用于顺序访问集合对象的元素，无需知道集合对象的底层实现。</p><h4 id="（8）Array和ArrayList的区别？"><a href="#（8）Array和ArrayList的区别？" class="headerlink" title="（8）Array和ArrayList的区别？"></a>（8）Array和ArrayList的区别？</h4><p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</p><p>Array大小是固定的，所以需要事前确定合适的空间大小。ArrayList的大小是动态变化的，在每次添加新的元素的时候都会检查内部数组空间是否足够。</p><p>ArrayList提供了更多的方法和特性，比如：all All（），removeAll（），iterator（）等。</p><p>对于基本数据类型，ArrayList使用自动装箱来减少编码工作量；而当处理固定大小的基本数据类型的时候，这种方式相对比较慢，这时候应该使用Array。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String,StringBuilder,StringBuffer</title>
      <link href="/2022/09/15/string-stringbuilder-stringbuffer/"/>
      <url>/2022/09/15/string-stringbuilder-stringbuffer/</url>
      
        <content type="html"><![CDATA[<p>区别：</p><a id="more"></a><p><strong>1，是否可变</strong></p><p>String对象创建后，一旦初始化就不能修改，因为String类中的所有数据都是常量。对String类的任何改变，都返回一个新的String类对象，效率低，浪费内存空间。</p><p>StringBuilder和StringBuffer的对象是可变的。</p><p>StringBuilder：是在Java5中被提出来的。StringBuilder是一个可变的字符序列，可以用append()方法进行对字符串的追加，insert()插入，StringBuilder的原理和StringBuffer一样，但是线程是不安全的。</p><p>StringBuffer：StringBuffer是使用缓冲区的，本身也是操作字符串，但与String类不同，String类中的内容一旦声明就无法改变，改变的只是其内存地址的指向。但是StringBuffer中的内存是可以改变的。append()追加方法，reverse()反转，replace()代替，delete()删除，insert()插入。</p><p><strong>2，构造</strong></p><p>String类是引用数据类型</p><p>StringBuilder和StringBuffer本身是一个具体的操作类，所以不能像String那样用直接赋值的方法进行对象实例化，必须要通过构造方法来完成。（为了获得更好性能，在构造StringBuilder和StringBuffer时要指定其容量，当不指定容量时会默认构造一个容量为16的对象）</p><p><strong>3，线程与速度</strong></p><p>StringBuilder在大多数实现中比StringBuffer快，将StringBuilder用于多个线程是不安全的（不能同步访问），但是在单个线程里StringBuilder比StringBuffer性能好。</p><p>StringBuffer线程是安全的。</p><p>StringBuilder相对于StringBuffer有速度优势，所以一般情况下推荐使用StringBuilder，但是在程序要求线程安全的情况下必须使用StringBuffer。</p><p>速度：StringBuilder&gt;StringBuffer&gt;String</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql引擎</title>
      <link href="/2022/09/15/mysql-yin-qing/"/>
      <url>/2022/09/15/mysql-yin-qing/</url>
      
        <content type="html"><![CDATA[<p><strong>常用的mysql引擎：MyISAM、InnoDB、Memory。</strong></p><a id="more"></a><p>MyISAM：MyISAM是mysql5.5之前的默认引擎。不支持事务，只支持表锁，不支持行锁。但是访问速度快。如果操作主要以读取和插入为主，修改和删除的操作很少，对数据的并发性和完整性要求并不是很强的情况下可以用该引擎，比如用户日志，评论等。</p><p>InnoDB：mysql5.5之后的默认引擎。支持事务和行锁，支持外键。是一种兼顾高可靠性和高性能的通用存储引擎。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，包含很多更新、删除操作，那么innodb是比较合适的选择。（B-Tree索引）</p><p>Memory：Memory是在内存中存储所有的数据。由于受到硬件的问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。（Hash索引）</p><p><strong>查看数据库是否支持引擎：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> ENGINES ;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/e8d45acb76514a03bab54c4cd9c9a334.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/e8d45acb76514a03bab54c4cd9c9a334.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>suport：是否支持引擎（default是默认引擎）</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治法(算法)</title>
      <link href="/2022/09/08/fen-zhi-fa-suan-fa/"/>
      <url>/2022/09/08/fen-zhi-fa-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>分治法是算法常用的解题方法之一，是将一个大的问题拆分为若干小的问题。二分法就是常用的分治法。</p><a id="more"></a><h2 id="可以采用分治法解决的一些问题："><a href="#可以采用分治法解决的一些问题：" class="headerlink" title="可以采用分治法解决的一些问题："></a>可以采用分治法解决的一些问题：</h2><p>1.二分查找</p><p>2.合并排序（归并排序）</p><p>3.快速排序</p><p>4.快速幂</p><p>5.汉诺塔</p><h2 id="一、二分查找"><a href="#一、二分查找" class="headerlink" title="一、二分查找"></a>一、二分查找</h2><p>二分查找对要查找的序列有两个要求：</p><p>​    一是该序列必须是有序的（即该序列中的所有元素都是按照大小关系排好序的，升序和降序都可以）</p><p>​    二是该序列必须是顺序存储的。</p><h4 id="例题：二分查找"><a href="#例题：二分查找" class="headerlink" title="例题：二分查找"></a>例题：<a href="https://leetcode.cn/problems/binary-search/">二分查找</a></h4><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1、先确定中间位置：</p><p>　　　　middle = (left+right)/2;</p><p>2、将待查找得值与nums[middle]的值相比较。若相等，则查找成功并返回该位置，否则须确定新确定查找区间，继续查找。</p><p>3、如果nums[middle] 的值大于待查找的值，则证明在nums[middle]~nums[right]中所有的值都大于待查找的值，令right=middle，在nums[left]到nums[middle]中查找。</p><p>4、当left&gt;right时，证明nums中没有要查找的值，跳出循环，返回-1。</p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> middle;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line"></span><br><span class="line">​      middle=(right+left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">if</span>(nums[middle]==target)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">return</span> middle;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target)</span><br><span class="line"></span><br><span class="line">​        right=middle-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">​        left=middle+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、合并排序（归并排序）"><a href="#二、合并排序（归并排序）" class="headerlink" title="二、合并排序（归并排序）"></a>二、合并排序（归并排序）</h2><p>归并排序是基于递归实现的，归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用。将数据分为a，b两组，再将a，b各自再分成两组，以此类推，当每一组都只有一个数据时，认为这个小小组已经达到了有序，再将相邻两个小小组依次合并。</p><h4 id="例题：排序数组"><a href="#例题：排序数组" class="headerlink" title="例题：排序数组"></a>例题：<a href="https://leetcode.cn/problems/sort-an-array/">排序数组</a></h4><p>给你一个整数数组 nums，请你将该数组升序排列。</p><p>示例 1：</p><p>输入：nums = [5,2,3,1]<br>输出：[1,2,3,5]</p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><img src="https://img-blog.csdnimg.cn/39e5969fb4db412eb1dbe851b285fe95.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/39e5969fb4db412eb1dbe851b285fe95.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" style="zoom:50%;" /><p>1、将数组进行拆分，利用递归的方法，将数组拆分成一个个单独的元素。</p><p>2、依次对数组进行合并，依次比较数组内的元素，将较小的元素先加入新的数组，依次往下比较，如果一个数组内的值已经全都加入新数组，将另一个数组的剩下的值依次加入新数组。</p><p>3、将额外的空间覆盖掉原来的空间。</p><h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] tmp; <span class="comment">//定义临时数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        tmp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>); <span class="comment">//进入递归</span></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//当l&gt;=r时，每个区间里面只有一个数值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) /<span class="number">2</span>;<span class="comment">//均分区间</span></span><br><span class="line">        mergeSort(nums, l, mid);<span class="comment">//对左侧区间进行划分</span></span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, r); <span class="comment">//对右侧区间进行划分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123; <span class="comment">//利用循环将较两个区间内较小值依次加入临时数组</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp[cnt++] = nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[cnt++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;<span class="comment">//将数组内剩下的元素依次加入</span></span><br><span class="line">            tmp[cnt++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">            tmp[cnt++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; r - l + <span class="number">1</span>; ++k) &#123;<span class="comment">//将临时数组内的值存入nums</span></span><br><span class="line">            nums[k + l] = tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、快速排序"><a href="#三、快速排序" class="headerlink" title="三、快速排序"></a>三、快速排序</h2><p>快速排序，基于冒泡排序移动换位思想——通过遍历，判断每个数并放置在数组合适的位置。快速排序可能是应用最广泛的排序算法，适用于各种不同的输入数据且在一般应用中比其他排序都要快的多。</p><p>排序方式：</p><p>1、选定一个值，一般是数值的第一个值</p><p>2、进行分区，将该值与数组后面的数据依次进行比较，将比它小的值都放在左边，比它大的值都放在右边。</p><p>3、采用递归的方法，对该值左右区间的数组依次再进行分区操作，直到每个区间只剩一个值。</p><h4 id="例题：最小的k个数"><a href="#例题：最小的k个数" class="headerlink" title="例题：最小的k个数"></a>例题：<a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数</a></h4><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p>示例 1：</p><p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]</p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>1、选取一个基数</p><p>2、设置i，j两个指针，分别从左右两边向中间进行查找，先使j移动，当遇到arr[j]小于基数时，移动i，当遇到arr[i]大于基数时，将arr[i]与arr[j]互换位置，保证比基数小的值在左边，比基数大的值在右边</p><p>3、当i&gt;=j的时候，跳出循环，将基数与i指针所在的位置交换数值</p><p>4、当i&gt;k时，证明最小的k个数在0~(i-1)之间，在该区间查找最小的k个数</p><p>5、当i&lt;k时，证明比基数大的一些数也是最小的k个数，在比基数大的值中间属于最小的k个数的值</p><p>6、当i==k时，返回最小的k个数</p><h4 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= arr.length) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">return</span> quickSort(arr, k, <span class="number">0</span>, arr.length - <span class="number">1</span>);<span class="comment">//进入排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//令arr[l]为基数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;<span class="comment">//当i&lt;j时，</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--; </span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, l); <span class="comment">//将基础值与arr[i]交换位置，保证在基础值左边的值均小于它，右边的值均大于它</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) <span class="keyword">return</span> quickSort(arr, k, l, i - <span class="number">1</span>); <span class="comment">//当i&gt;k时，证明最小的k个数在0~(i-1)之间,该区间的数进行排序</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) <span class="keyword">return</span> quickSort(arr, k, i + <span class="number">1</span>, r);<span class="comment">//当i&lt;k时，证明比基数大的一些数是最小的k个数，在比基数大的值中间属于最小的k个数的值</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(arr, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123; <span class="comment">//将arr[i]和arr[j]中的值进行交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、快速幂"><a href="#四、快速幂" class="headerlink" title="四、快速幂"></a>四、快速幂</h2><h4 id="例题：Pow-x-n"><a href="#例题：Pow-x-n" class="headerlink" title="例题：Pow(x, n)"></a>例题：<a href="https://leetcode.cn/problems/powx-n/">Pow(x, n)</a></h4><p>实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。</p><p>示例 1：</p><p>输入：x = 2.00000, n = 10<br>输出：1024.00000</p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><img src="https://img-blog.csdnimg.cn/f6cc78ebe5094c01b15242af9a169f64.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/f6cc78ebe5094c01b15242af9a169f64.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" style="zoom:67%;" /><p>1、声明数据类型为long的b，将n赋值给它</p><p>2、当b为负数时，先将b转化为正数运算，x=1/x,b=-b</p><p>3、将b除以2，如果余数为一，将res=res*x,x等于x的平方，因为最后结果永远等于x的b次幂乘res，当b=0时，最后结果等于1乘res，即res</p><h4 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;  <span class="comment">//1、声明数据类型为long的b，将n赋值给它</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;  <span class="comment">//当b为负数时，转化为正数的运算，x=1/x，b=-b</span></span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;<span class="comment">//3、将b除以2，如果余数为一，将res=res*x，因为最后结果永远等于x的b次幂乘res，当b=0时，最后结果等于1乘res，即res</span></span><br><span class="line">            <span class="keyword">if</span>((b % <span class="number">2</span>) == <span class="number">1</span>) </span><br><span class="line">                res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            b = b/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、汉诺塔"><a href="#五、汉诺塔" class="headerlink" title="五、汉诺塔"></a>五、汉诺塔</h2><h4 id="例题：汉诺塔问题"><a href="#例题：汉诺塔问题" class="headerlink" title="例题：汉诺塔问题"></a>例题：<a href="https://leetcode.cn/problems/hanota-lcci/">汉诺塔问题</a></h4><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p><p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p><p>你需要原地修改栈。</p><p>示例1:</p><p> 输入：A = [2, 1, 0], B = [], C = []<br> 输出：C = [2, 1, 0]</p><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>假设A柱有n个盘子</p><p><img src="https://img-blog.csdnimg.cn/13d9da4188f749ba8d8363da097cd8c1.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/13d9da4188f749ba8d8363da097cd8c1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>1、B柱与C柱替换，新的C柱就是B柱。</p><p>2、将A柱上的n-1个盘子移到新C柱上，实际上都移到了B柱上。</p><p>3、将B柱与C柱换回来。</p><p>4、将A柱上的最后一个盘子移到C柱上，这个盘子不用再移动，将它和C柱看成一个整体。</p><p>5、将B柱与A柱互换位置，B柱成为新的A柱。</p><p>6、将B柱看出A柱重复1~5步，直到盘子完全移到C上。</p><h4 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> A.size();</span><br><span class="line">        dac(num,A,B,C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//num为A盘剩下的盘子数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dac</span><span class="params">(<span class="type">int</span> num,List&lt;Integer&gt; A,List&lt;Integer&gt; B,List&lt;Integer&gt; C)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;<span class="comment">//当A盘只剩下一个盘子的时候，将最后一个盘子移动到C盘</span></span><br><span class="line">            C.add(A.remove(A.size() - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dac(num - <span class="number">1</span>,A,C,B); <span class="comment">//B柱与C柱替换，新的C柱就是B柱，将A柱上的n-1个盘子移到新C柱上，实际上都移到了B柱上。</span></span><br><span class="line">            C.add(A.remove(A.size() - <span class="number">1</span>));<span class="comment">//将A柱最后一个盘子移动到C柱上</span></span><br><span class="line">            dac(num - <span class="number">1</span>,B,A,C); <span class="comment">//将B柱与A柱互换位置，B柱成为新的A柱，将B柱上的所有盘子都移到C柱上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分治和递归：</strong></p><p><strong>递归和分治本身就不是同一种东西，递归是敲代码的技巧之一，分治是算法的思想之一，两者没关系。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对称的二叉树（算法题）</title>
      <link href="/2022/08/06/dui-cheng-de-er-cha-shu-suan-fa-ti/"/>
      <url>/2022/08/06/dui-cheng-de-er-cha-shu-suan-fa-ti/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：</strong>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><a id="more"></a><p><strong>例如：</strong>二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p>    1<br>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><p>    1<br>   / \<br>  2   2<br>   \   \<br>   3    3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> n=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>||(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>||root.right==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        hui(root.left,root.right); <span class="comment">//进入递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hui</span><span class="params">(TreeNode root,TreeNode tree)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.n==<span class="literal">false</span>)  <span class="comment">//当n为false时，二叉树已经不对称，不在进行下面的判断</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>&amp;&amp;tree==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>||tree==<span class="literal">null</span>)&#123; <span class="comment">//tree和root一个为空时，二叉树不对称</span></span><br><span class="line">            <span class="built_in">this</span>.n=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val!=tree.val)&#123; </span><br><span class="line">            <span class="built_in">this</span>.n=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hui(root.left,tree.right);</span><br><span class="line">        hui(tree.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析：</strong>这个问题采用递归的方法，从最上方的根节点向下依次判断，将左节点看做root，右节点看成tree，每次root左移时，tree右移，保证root和tree一直处于对称的位置。判断root和tree是否相等，若不相等，则证明该二叉树是不对称的。如果tree和root有一项为空而另一项不为空，则该二叉树也是不对称的。</p><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/solution/dui-cheng-de-er-cha-shu-by-leetcode-solu-rgks/" title="对称的二叉树 - 对称的二叉树 - 力扣（LeetCode）">对称的二叉树 - 对称的二叉树 - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重建二叉树（算法题）</title>
      <link href="/2022/07/23/chong-jian-er-cha-shu-suan-fa-ti/"/>
      <url>/2022/07/23/chong-jian-er-cha-shu-suan-fa-ti/</url>
      
        <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>        输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>        假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><a id="more"></a><p><strong>示例：</strong></p><p><img src="https://img-blog.csdnimg.cn/f943c4611c1e4803ac87b455a1b187ef.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/f943c4611c1e4803ac87b455a1b187ef.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>        Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>        Output: [3,9,20,null,null,15,7]</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; in=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder=preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            in.put(inorder[i],i);  <span class="comment">//方便获取根节点在中序遍历的坐标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hui(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode <span class="title function_">hui</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123; <span class="comment">//递归方法</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) <span class="comment">//递归结束的条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        TreeNode node=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[root]);  <span class="comment">//创建节点</span></span><br><span class="line">        <span class="type">int</span> index=in.get(preorder[root]); <span class="comment">//获取根节点坐标</span></span><br><span class="line">        node.left=hui(root+<span class="number">1</span>,left,index-<span class="number">1</span>); <span class="comment">//获取左子树</span></span><br><span class="line">        node.right=hui(root+index-left+<span class="number">1</span>,index+<span class="number">1</span>,right); </span><br><span class="line">        <span class="comment">//root+index-left+1为当前节点+左子树个数+1</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 总结：**</p><p>        前序遍历时先是根节点，然后是左子树，右子树。</p><p>        中序遍历先是左子树，然后是根节点，最后是右子树。 <img src="https://img-blog.csdnimg.cn/6b5088b985e8419b9dace85aa9e8b803.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/6b5088b985e8419b9dace85aa9e8b803.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>        前序遍历第一个数是二叉树最上面的根节点，遍历inorder，找到根节点的位置。根节点左边是左子树的中序遍历结果，右边是右子树的遍历结果。先找左子树，在左子树的遍历结果里最上面的一个根节点就是前序遍历的第二个数，以此类推，采用递归的方式解决问题。</p><p>        这是第一次接触到有关树的算法题，开始的时候题目都没有怎么看懂，后来看题解还是有好多地方感觉有点疑问。后来花费了好多时间才把这道题理解个差不多，记录一下，希望后来再遇到这种类型的题目时我可以自己写出来。</p><p>题目链接：<a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof">https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-plus常用方法</title>
      <link href="/2022/07/02/mybatis-plus-chang-yong-fang-fa/"/>
      <url>/2022/07/02/mybatis-plus-chang-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>mybatis-plus</p><a id="more"></a><h3 id="增加："><a href="#增加：" class="headerlink" title="增加："></a>增加：</h3><p>**int insert(entity)**：插入单条数据，返回值为int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.insert(user);</span><br></pre></td></tr></table></figure><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><p><strong>int deleteById( id)：</strong>通过id进行删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.deleteById(userId);</span><br></pre></td></tr></table></figure><p>**int deleteBatchIds(Collection&lt;? extends Serializable&gt; idList)**：通过id删除多个表的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userMapper.deleteBatchIds(Arrays.asList(id));</span><br><span class="line">//Integer[] id</span><br></pre></td></tr></table></figure><h3 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h3><p><strong>updateById<code>(</code>entity<code>)</code>：</strong>通过id更新表的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.updateById(user);</span><br></pre></td></tr></table></figure><p>查询：</p><p><strong>T selectById（entity）：</strong>根据主键id查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user=userMapper.selectById(userId);</span><br></pre></td></tr></table></figure><p>**T selectOne(Wrapper&lt;T&gt; queryWrapper)**： 根据实体类封装对象 查询一条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;user_account&quot;</span>, userAccount);</span><br><span class="line">userMapper.selectOne(queryWrapper);</span><br></pre></td></tr></table></figure><p><strong>List&lt;T&gt; selectList(Wrapper&lt;T&gt; queryWrapper)：</strong> 查询多条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;user_authority&quot;</span>,<span class="number">0</span>);</span><br><span class="line">userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure><p><strong>selectPage（page，queryWrapper）：</strong>查询多条记录结果分页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IPage page=<span class="keyword">new</span> <span class="title class_">Page</span>(currentPage,pageSize);</span><br><span class="line">userMapper.selectPage(page, queryWrapper);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化</title>
      <link href="/2022/06/25/redis-chi-jiu-hua/"/>
      <url>/2022/06/25/redis-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis提供了两种持久化方式：RDB，AOF"><a href="#Redis提供了两种持久化方式：RDB，AOF" class="headerlink" title="Redis提供了两种持久化方式：RDB，AOF"></a>Redis提供了两种持久化方式：RDB，AOF</h2><a id="more"></a><h3 id="RDB："><a href="#RDB：" class="headerlink" title="RDB："></a>RDB：</h3><p>        RDB是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。</p><p>        通过保存数据库中的键值对来记录数据库的状态。</p><p>        RDB 有两种触发方式，分别是自动触发和手动触发。</p><p><strong>优点：</strong></p><p>        （1）节省磁盘空间，生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p><p>        （2）恢复速度快。</p><p>        （3）适合大规模的数据恢复。</p><p><strong>缺点：</strong></p><p>        （1）因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，fork时，内存中数据被复制了一份，大致两倍的膨胀性需要考虑</p><p>        （2）最后一次持久化之后的数据可能会丢失</p><h3 id="AOF："><a href="#AOF：" class="headerlink" title="AOF："></a><strong>AOF：</strong></h3><p>        AOF 被称为追加模式，或日志模式，是 Redis 提供的另一种持久化策略，它能够存储 Redis 服务器已经执行过的的命令，并且只记录对内存有过修改的命令，这种数据记录方法，被叫做“增量复制”，其默认存储文件为<code>appendonly.aof。</code></p><p>        通过保存Redis服务器所执行的写命令来记录数据库状态。</p><p><strong>优点：</strong></p><p>        （1）丢失数据概率低。AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失 1 秒的数据而已。</p><p>        （2）AOF 文件使用 Redis 命令追加的形式来构造，因此，即使 Redis 只能向 AOF 文件写入命令的片断，使用 redis-check-aof 工具也很容易修正 AOF 文件。</p><p><strong>缺点：</strong></p><p>        （1）比RDB占用更多磁盘空间。</p><p>        （2）恢复备份速度慢</p><p>        （3）每次读写都同步的话，有一定的性能压力。</p><p>        （4）RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 方式更健壮。官方文档也指出，AOF 的确也存在一些 BUG，这些 BUG 在 RDB 没有存在。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于redis的学习</title>
      <link href="/2022/06/18/guan-yu-redis-de-xue-xi/"/>
      <url>/2022/06/18/guan-yu-redis-de-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>        这段学习计划主要是学习redis，因为学习计划才开始的几天有专业课考试，平时我专业课总是划水，学的实在太差劲了，所以我把重心放到了专业课的复习上面，虽然复习之后考的也不太好，但是复习总比不复习好。后来又加上一系列事情，导致这一阶段的学习进度有点慢了。最近也是注意到了这个问题，正在慢慢补救。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/7795c0d5c7494ce9afeec7fea0b04ddf.jpeg" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/7795c0d5c7494ce9afeec7fea0b04ddf.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>        感觉每次在接触一个新的软件的时候我总会遇到各种各样的问题，这次也不例外，最开始安装软件遇到了好多问题，不知道该如何下手。后来在网上找了好多教程，才把软件安装好。后来在操作的时候也不知道我不小心弄错什么了，就一直报错Could not connect to Redis at 127.0.0.1:6379: Connection refused。我上网搜索原因，但是当时试了好多方法都不行，后来才发现是我不小心把防火墙开放6379端口的那个给删了，后来把端口重新开放，然后重新启动了服务端才好。感觉学习真的是一件不断遇到问题，然后解决问题的过程，至少对于我是这样子的。比起去问别人，确实自己一点点搜索记忆会更加深刻一些，进步会更大一些。</p><p>        对于下星期的规划嘛，就是继续学习Redis。现在我在看视频学习，我准备把进度赶赶，如果可以在学习计划结束之前看完视频的话就去做一些练习什么的来巩固一下，把这一段时间学习的东西学扎实。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于PS的学习</title>
      <link href="/2022/06/11/guan-yu-ps-de-xue-xi/"/>
      <url>/2022/06/11/guan-yu-ps-de-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>        因为一些原因，这学期提前放假了，所以这是在暑假学习的第一周。很明显，在假期的时候我的学习状态比不上在学校的时候，但是和在寒假的时候相比，我现在的学习状态还是比较好的。</p><a id="more"></a><p>        这一段时间我们在学习ps，可能是以前我有时候会在手机上绘画，然后对于图层什么的接触的比较多，因此我对于ps一些工具的学习还是比较快的。这一阶段我没有去跟着视频去学习，而是通过做练习去了解和掌握一些工具的运用。在学习计划开始的前两天我就开始去做PS的练习案例，在做练习的时候遇到的最大的问题就是调色，后来还是结合了学长学姐发的材料里面的那个psd文件去调的颜色。还有就是锐化，在锐化后图案的颜色就变得比较亮，开始的时候我没有用到锐化，到最后才用，导致原本调好的颜色变得很奇怪，但是最后做出来的成品我还是比较满意的。</p><p>        因为提前放假，有些专业课我们还没有进行考试，java和电子技术的考试就安排到了10号和13号，所以我提前把ps练习案例交给了学姐，然后把剩下的时间放到了考试上，因为在学校我专业课学的并不是很好，特别是电子技术，很多知识我都没有掌握，所以我就把大部分的时间放到这门学科的复习上了。</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
            <tag> Ps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关Springboot的学习</title>
      <link href="/2022/05/14/you-guan-springboot-de-xue-xi/"/>
      <url>/2022/05/14/you-guan-springboot-de-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>        由于疫情原因，这一周的学习是在宿舍中进行的。说实话我的自制力不是很高，所以这一星期的学习进度有点慢。</p><a id="more"></a><p>        在上一阶段我们写项目的时候使用的是ssm框架，这一阶段我们要把ssm框架换成SpringBoot框架。SpringBoot提供了全新的框架。在学习ssm的时候我最头疼的事情就是配置文件了，一不小心配置就会出问题。在学习了SpringBoot之后就再也没有这个烦恼了，同时也不用导入很多很多的依赖。相比之下，SpringBoot真的是比ssm简单很多，但是SpringBoot的集成度高，不容易了解它的底层。</p><p><strong>SpringBoot的优点：</strong></p><p>简化的Maven配置：Spring提供推荐的基础 POM 文件来简化Maven 配置。</p><p>自动配置Spring：Spring Boot会根据项目依赖来自动配置Spring 框架，极大地减少项目要使用的配置。</p><p>无代码生成和<a href="https://so.csdn.net/so/search?q=xml&spm=1001.2101.3001.7020" title="xml">xml</a>配置：Spring Boot不生成代码。完全不需要任何xml配置即可实现Spring的所有配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 整合mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>** yaml**</p><p>      在学习SpringBoot的过程中还学习了yaml文件：在SpringBoot<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020" title="框架">框架</a>中，resource文件夹里可以存放配置的文件有两种：properties和yml（yaml）。</p><p>        优先级：properties&gt;yml</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目考核总结</title>
      <link href="/2022/05/09/xiang-mu-kao-he-zong-jie/"/>
      <url>/2022/05/09/xiang-mu-kao-he-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>        历时一个月，我们这个项目也进入了尾声。在昨天，所有的组都完成了考核。</p><a id="more"></a><p>        和最开始的信心满满不同，在项目结束的时候，我整个人都是很颓废的。我们组的项目整体上表现得很差劲，无论是前端还是后端，在考核的时候表现的都不尽人意，这也和我这个组长有很大关联。在写项目的时候，由于我是学后端的，就没有太多地去关注前端的进度，以至于到最后交项目的时候前端的页面还没有全部连在一起。在提交仓库的最后一段时间，我们组才把播放音乐的页面连接起来，这也导致考核的时候出现了很多问题。后端的问题主要是出在代码规范上，也是因为在写项目的时候我没有过多地去关注这一点，只是一味地去赶进度。</p><p>        说实话，在考核的时候前后端之间的矛盾真的不少。特别是在最后一段时间，可能是因为我的脾气不是特别好，在最后的时候和前端的矛盾逐渐变大。我感觉我们组现在真的存在一个很严重的问题，就是无论是什么样的问题，第一时间就去找后端。就比如最后提交项目之后我们播放mv的页面出了问题，一打开那个页面CPU直接飙到40%，导致页面卡死。当时找不到原因，就有前端的孩子说是因为我录数据的原因。我听完真的是很生气，我们组里面没有人录数据，我熬到半夜两点多去录的数据，结果出问题了，就说是我的原因。然后那天中午我就把录得mv数据全删掉了，页面打开还是卡死，后来找了学长帮忙解决，才发现是前端写了一个死循环。还有点赞歌单的接口，我很明确地问过前端我传的值她可不可以交互上，她说可以。但是在考核的时候页面点赞出了问题，他们又说是我传的值有问题，可是前一天我很明确很明确地问过这个问题，说如果交互不上我就把那个接口改一下。害，我感觉这个问题真的是，很严重。项目是前后端共同的项目，为什么有bug就觉得是我们后端的原因呢？</p><p>        这个项目好像还要继续写下去，我前一阶段并没有很好地担起组长这个责任，这点我最近反思了很多。我觉得一个项目组的成员要多沟通，对于我们组存在的一些问题，我也应该多和他们沟通一下，一起商量着解决。希望继续写项目的话，我们可以一起去把上一阶段存在的问题改正吧。写项目本来就是一个遇到问题解决问题的过程，希望在最后结束的时候，我们每个人都可以收获很多。</p><p><img src="https://img-blog.csdnimg.cn/0268339c718b48bdbf723d5f82682be5.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/0268339c718b48bdbf723d5f82682be5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于下载音乐的问题</title>
      <link href="/2022/04/30/guan-yu-xia-zai-yin-le-de-wen-ti/"/>
      <url>/2022/04/30/guan-yu-xia-zai-yin-le-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>        这周写项目遇到了一个问题——怎么通过url下载音乐文件。</p><a id="more"></a><p>        因为之前写下载文件都是通过文件路径去下载的，而这一次我们用到了云存储，在数据库里面存的是url地址，所以我就不知道应该怎么去下载了。后来我在网上找到了通过url来下载文件的方法，但是又遇到了一个问题，就是我是从数据库获取的url，里面有中文会报错，这个问题困扰了我好长时间。</p><p>        我在网上查找解决中文乱码的办法的时候，知道了URLEncoder.encode（）可以使用指定的编码机制将字符串转换为 application/x-www-form-urlencoded 格式 ，从而解决中文乱码。但是我在使用了URLEncoder.encode（）之后，发现接口报错HTTP response code: 400 for URL，显示发送了异常请求，后来才发现并不能将url全部进行转化，否者会把HTTP:// 中的斜线也<a href="https://so.csdn.net/so/search?q=%E8%BD%AC%E4%B9%89&spm=1001.2101.3001.7020" title="转义">转义</a>，导致请求出现协议异常等问题。</p><p>        后来由于我找不到更好的办法对url中的中文进行处理，就将url分割成了几部分，然后对含有中文的那一部分进行转化。虽然方法有点笨，但是总算是解决了问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">download</span><span class="params">(Integer musicId,  HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Map map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Music</span> <span class="variable">music</span> <span class="operator">=</span>musicService.queryById(musicId);</span><br><span class="line">        String musicName=music.getMusicName();</span><br><span class="line">        String musicPath=music.getMusicPath();</span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        String[] str=musicPath.split(<span class="string">&quot;/&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        String[] s=str[<span class="number">3</span>].split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> musicPath;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">            <span class="comment">// 取得文件的后缀名。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">ext</span> <span class="operator">=</span> path.substring(path.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>).toLowerCase();</span><br><span class="line">            <span class="comment">//文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pdfName</span> <span class="operator">=</span> musicName+<span class="string">&quot;.&quot;</span>+ext;</span><br><span class="line">            <span class="comment">// 获取外部文件流</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(str[<span class="number">0</span>]+<span class="string">&quot;//&quot;</span>+str[<span class="number">2</span>]+<span class="string">&quot;/&quot;</span>+URLEncoder.encode(s[<span class="number">0</span>], <span class="string">&quot;UTF-8&quot;</span>)+<span class="string">&quot;.&quot;</span>+s[<span class="number">1</span>]);</span><br><span class="line">            map.put(<span class="string">&quot;2&quot;</span>,url);</span><br><span class="line">            <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">            conn.setConnectTimeout(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//防止屏蔽程序抓取而返回403错误</span></span><br><span class="line">            conn.setRequestProperty(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;</span>);</span><br><span class="line">            inputStream = conn.getInputStream();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 输出文件到浏览器</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 输出 下载的响应头，如果下载的文件是中文名，文件名需要经过url编码</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/x-download&quot;</span>);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + URLEncoder.encode(pdfName, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">            out = response.getOutputStream();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐项目总结（三）</title>
      <link href="/2022/04/23/yin-le-xiang-mu-zong-jie-san/"/>
      <url>/2022/04/23/yin-le-xiang-mu-zong-jie-san/</url>
      
        <content type="html"><![CDATA[<p>        这一段时间的状态感觉比上周的状态好点了，我也慢慢写了一些接口，虽然进度还不是很快，但很明显有了进步。</p><a id="more"></a><p>        在写项目的时候我们组遇到了好多好多bug，遇到最多次的就是更新仓库的时候出的bug，应该是terget文件和仓库里面的target文件冲突了，我们遇到这个问题的时候都是吧target文件删掉，然后就可以更新了。还有还有就是前端的一些bug，我们组前端的同学给我说他们的代码变了，但是用tomcat运行起来页面却没有变化，当时挺懵逼的，然后就上网查嘛，才发现是浏览器缓存的问题，把缓存清理之后就解决了。这周真的是遇到了好多奇葩的bug啊~</p><p>        这周在写搜索的接口的时候我最开始的想法是输入任何一个字符就可以搜索出来，就像输入“周伦”就可以搜索出来“周杰伦”。但是后来在写动态sql的时候一直搜索不出来，可能是方法有些错误吧。因为前端催接口催的比较急，我就把搜索改的简单一点了，改成了下面的样式。不过我想在后来接口写得差不多的时候回头研究一下这个问题，找一下自己开始的时候在哪出错了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;search&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;project.pojo.Music&quot;</span> &gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;musicPojo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> where</span><br><span class="line">            concat(a.music_name,b.singer_name)</span><br><span class="line">            like &#x27;%$&#123;search&#125;%&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>        上一次写项目的时候我没有用到多对多查询，前一段时间学了一下，网上说可以建一个中间表，用联合主键。</p><p><img src="https://img-blog.csdnimg.cn/a51f7f6e04f245f49e27e0054b05eb75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/a51f7f6e04f245f49e27e0054b05eb75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p> </p><p>        我们组差不多是上周末才开始交互，交互的时候前后端真的是需要好好沟通&gt;_&lt;，发现bug的话可以自己先上网搜索一下，不要一发现bug就去找人帮忙改，要学会自己去解决问题。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目总结(二)</title>
      <link href="/2022/04/17/xiang-mu-zong-jie-er/"/>
      <url>/2022/04/17/xiang-mu-zong-jie-er/</url>
      
        <content type="html"><![CDATA[<p>项目总结</p><a id="more"></a><p><strong>学习上：</strong></p><p>        这周是我们写项目的第二周。可能是因为我们两个后端的时间太紧，加上学东西有点慢，我们组后端的进度和其他组比起来是比较慢的，以后需要慢慢加油了。</p><p>        到目前为止，我们项目组还没有进行前后端的交互，原本计划的是今天交互，但是计划赶不上变化，今天课程太多了，就没有交互上。这是我们大一前后端第一次一起写项目，对于前后端怎么交互我们也不是很懂，今天晚上才把交互的细节商量好，明天应该就可以进行交互了。通过这几天写项目我感觉到交流沟通真的非常重要，因为每个人写得代码都不一样，学的东西有时候也有一些不同。就像我们组后端，虽然就两个人，但是我们也出现了一些问题，写sql语句的时候我们两个写在了不同的地方。所以在写项目的时候要多交流沟通，这样就不会到最后了才发现代码写得不一样。</p><p>        经过将近两周的时间，我感觉我们不仅仅是在写项目，也是在不断地学习。因为在写项目的时候我们会遇到很多很多地方需要我们去学习新的知识，就比如我们以前在写controller的时候，总是返回一个视图，但是这次写项目的时候我们发现不能跳转视图，所以我们学习了如何就返回了json数据，还有对于服务器的操作，对于测试文档的操作，这些都需要我们不断地去学习。</p><p><strong>生活上：</strong></p><p>这周也没有发生什么大事，就是这周团支部风采大赛的排练和我们部画展报，还有催各种各样的材料，这些事情让我感觉时间太紧了，每天都要请假，呆在小组的时间少之又少。一个项目我们后端是两个人在做，因为我天天事情太多了，所以配置服务器什么的很多事情都是我们组另一个后端的同学做的，所以感觉挺不好意思的，下周我尽量多卷卷吧，不能拉他们后腿喽。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始项目总结（一）</title>
      <link href="/2022/04/10/chu-shi-xiang-mu-zong-jie-yi/"/>
      <url>/2022/04/10/chu-shi-xiang-mu-zong-jie-yi/</url>
      
        <content type="html"><![CDATA[<p>第一次写项目</p><a id="more"></a><p><strong>学习上：</strong></p><p>        这周我们开始前后端交互写项目了。项目开始的时候我一直在整合ssm框架，但一直整合不好，浪费了好多时间，项目的进度太慢了。我们这次做的项目也是音乐网站，可能是因为上一次做过类似的项目，所以对于要实现的功能什么的我都有一点点了解，在开始写得时候也有了大致的构思，这也是比较好的一点吧。现在进度还是有点慢的，项目开始几天了，我才把数据库建好，然后我想在项目里面多用一点动态sql语句，但是对于这一方面我掌握的有点差劲，可能要抽时间去补一下了。</p><p>        经过这周和后端其他人的交流，我也发现了自己做的不够好的地方，有一点就是每次学习新东西的时候学的时间太长了，可能是我有时候理解能力比较差劲吧。还有就是对于软件的安装配置什么的，这方面我做的也不好。希望以后可以有所进步吧。</p><p>        这周参加了蓝桥杯比赛。通过这次比赛，我意识到了我的算法学的还是很差，就是才学到一些入门级的东西，还有好多好多知识我还没有接触到。还有就是我在比赛的时候犯了好大一个错误。我在eclipse上写代码的时候类名没有用Main，结果在最后复制代码的时候因为马虎忘记把类名改成Main了，所以我可能只有一道题的类名是正确的，这真的是致命性错误。虽然我才写了三道编程题，但是有的题琢磨了好久终于写出来了，结果却败在没有改类名上。嗯，多少是有点难受的，但是也没有办法了，只能明年注意了。</p><p><strong>生活上：</strong></p><p>        最近遇到了好多问题啊，首先就是篮球训练提前到早上了，这就意味着每天早上我要五点多起。以前写项目的时候我进度也总是太慢，所以有时候就会熬夜去补进度。但是现在每天早上五点多起床，每次一熬夜早上上课就会困得睁不开眼。还有就是有时候心情会很丧，也不知道怎么回事。哎，只能慢慢去调整了。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于算法学习</title>
      <link href="/2022/04/02/guan-yu-suan-fa-xue-xi/"/>
      <url>/2022/04/02/guan-yu-suan-fa-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>        这周我们主要学习了算法。我一直感觉我的算法挺差劲的，所以在假期一直在按照组长的要求写算法，虽然进步了一点点，但是通过这周的学习我还是清楚地意识到了我的算法真的很差。</p><a id="more"></a><p>        超出数据范围是我在这周的学习过程中遇到的比较多的一个问题。有一次写算法的时候我用了long型还是超出数据范围，那个时候我才知道了大数字BigIntegger，当数据很大的时候，用大数就可以解决问题，但是大数的加减乘除和Int型的不太一样：</p><p>        <strong>最常用的构造方法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi = new BigInteger(&quot;5&quot;)；</span><br></pre></td></tr></table></figure><table border="1"><caption>&nbsp; <strong>BigInteger类的常用运算方法</strong></caption><tbody><tr><th>方法名称</th><th>说明</th></tr><tr><td>add(BigInteger val)</td><td>做加法运算</td></tr><tr><td>subtract(BigInteger val)</td><td>做减法运算</td></tr><tr><td>multiply(BigInteger val)</td><td>做乘法运算</td></tr><tr><td>divide(BigInteger val)</td><td>做除法运算</td></tr><tr><td>remainder(BigInteger val)</td><td>做取余数运算</td></tr><tr><td>divideAndRemainder(BigInteger val)</td><td>做除法运算，返回数组的第一个值为商，第二个值为余数</td></tr><tr><td>pow(int exponent)</td><td>做参数的 exponent 次方运算</td></tr><tr><td>negate()</td><td>取相反数</td></tr><tr><td>shiftLeft(int n)</td><td>将数字左移 n 位，如果 n 为负数，则做右移操作</td></tr><tr><td>shiftRight(int n)</td><td>将数字右移 n 位，如果 n 为负数，则做左移操作</td></tr><tr><td>and(BigInteger val)</td><td>做与运算</td></tr><tr><td>or(BigInteger val)</td><td>做或运算</td></tr><tr><td>compareTo(BigInteger val)</td><td>做数字的比较运算</td></tr><tr><td>equals(Object obj)</td><td>当参数 obj 是 Biglnteger 类型的数字并且数值相等时返回 true,&nbsp;其他返回 false</td></tr><tr><td>min(BigInteger val)</td><td>返回较小的数值</td></tr><tr><td>max(BigInteger val)</td><td>返回较大的数值</td></tr></tbody></table><p>         除了超出数据范围之外还有超出时间限制。超出时间限制主要是因为我的代码运行起来太麻烦。我想了想，应该是我写的题太少了，掌握的解题方法什么的都不是很多，当遇到一个算法题的时候我第一时间想到的方法往往都很麻烦，所以我觉得我以后还是要多刷一点题，看一些题解，多学习一些解题方法。</p><p>        还有就是对于链表我掌握的不多，这几天的任务中布置有关于链表的题，最近要加油补一下关于链表的知识点了。</p><p>        总之就是好好加油吧，多刷点题，遇到不会的题研究一下题解，学习一下别人的解题思路，努力提升自己，加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2022/03/26/springmvc/"/>
      <url>/2022/03/26/springmvc/</url>
      
        <content type="html"><![CDATA[<p>        在第四阶段学习过程中我的进度有点慢，学习任务结束的时候我还在整合ssm，主要是前面学习的时候没有怎么注意时间，再加上课有点多，进度就跟不上了。</p><a id="more"></a><p>记录一下这个星期学习的关于SpringMVC的一些知识：</p><p><strong>1.SpringMVC</strong></p><p>M：即model模型是指模型表示业务规则。Model：Bean，Dao，Service等</p><p>V：即View视图是指用户看到并与之交互的界面。View：Html，jsp等</p><p>C：即controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。Controller</p><p><strong>2.工作流程(理解原理)</strong></p><p>（1）web.xml</p><p>Dispatcher：这是SpringMVC的核心 请求分发器 前端控制器</p><p>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;:启动级别：1和服务器一起启动</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  **配置Dispatcher**  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  Dispatcher要绑定Spring的配置文件  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  /只匹配所有请求，不匹配jsp页面</span></span><br><span class="line"><span class="comment">      /*匹配所有的请求，包括jsp页面</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（2）springmvc-servlet </span><br><span class="line"></span><br><span class="line">处理映射器和处理适配器可以不配置，这里是为了更好的理解  </span><br><span class="line">\&lt;mvc:annotation-driven/&gt; ：  </span><br><span class="line">支持mvc注解驱动：  </span><br><span class="line">                        在spring中一般采用\@RequestMapping注解来完成映射关系， 必须向上下文中注册DefaultAnnotationHandlerMapping和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理，而annotation-driven配置帮助我们自动完成上述两个实例的注入 。</span><br><span class="line"></span><br><span class="line">```XML</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">  https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  处理器映射器  --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;</span><br><span class="line">&lt;!--  处理适配器  --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  视图解析器 :模板引擎Thymeleaf Freemarker --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;/hello&quot; class=&quot;nice.controller.HelloController&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>（3）HelloController.java </p><p>平时使用@Controller注解，这里继承Controller类是为了更好地理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nice.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="comment">//业务代码</span></span><br><span class="line">        String result=<span class="string">&quot;HelloSpringMVC&quot;</span>;</span><br><span class="line">        mv.addObject(<span class="string">&quot;msg&quot;</span>,result);</span><br><span class="line">        <span class="comment">//视图跳转</span></span><br><span class="line">        mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于Maven的一个网站:</p><p>        <a href="https://mvnrepository.com/" title="Maven Repository: Search/Browse/Explore (mvnrepository.com)">Maven Repository: Search/Browse/Explore (mvnrepository.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四阶段学习总结</title>
      <link href="/2022/03/18/di-si-jie-duan-xue-xi-zong-jie/"/>
      <url>/2022/03/18/di-si-jie-duan-xue-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="这周学习的关于AOP的知识点总结："><a href="#这周学习的关于AOP的知识点总结：" class="headerlink" title="这周学习的关于AOP的知识点总结："></a>这周学习的关于AOP的知识点总结：</h1><a id="more"></a><h3 id="1-AOP概念（Aspect-Oriented-Programming）"><a href="#1-AOP概念（Aspect-Oriented-Programming）" class="headerlink" title="1.AOP概念（Aspect Oriented Programming）"></a><strong>1.AOP概念</strong>（Aspect Oriented Programming）</h3><p>        （1）面向切面编程（面向方面编程），利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑的各部分之间的耦合度降低，提高程序的可重性，同时提高了开发的效率。</p><p>        （2）不通过修改源代码，在主干功能里面添加新功能。</p><h3 id="2-AOP底层原理"><a href="#2-AOP底层原理" class="headerlink" title="2.AOP底层原理"></a><strong>2.AOP底层原理</strong></h3><p>        （1） AOP底层使用动态代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;1&gt;有两种情况动态代理</span><br><span class="line"></span><br><span class="line"> 第一种有接口，使用JDK动态代理（创建接口实现类的代理对象，增强类的方法）</span><br><span class="line"></span><br><span class="line"> 第二种没有接口，使用CGLIB动态代理（创建当前子类的代理对象，增强类的方法）</span><br></pre></td></tr></table></figure><h3 id="3-AOP-JDK动态代理"><a href="#3-AOP-JDK动态代理" class="headerlink" title="3.AOP(JDK动态代理)"></a><strong>3.AOP(JDK动态代理)</strong></h3><p>        （1）使用JDK动态代理，使用Proxy类里面的方法创建动态对象</p><p><img src="https://img-blog.csdnimg.cn/9b1c9ef07b6a4269acd5463c6897b41a.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/9b1c9ef07b6a4269acd5463c6897b41a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>        调用newProxyInstance方法</p><p><img src="https://img-blog.csdnimg.cn/d2055f57f9df432f95243e90bb408a19.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/d2055f57f9df432f95243e90bb408a19.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>方法有三个参数：</p><p>        （类加载器）</p><p>        （增强方法所在的类，这个类实现的接口，支持多个接口）</p><p>        （实现这个接口InvocationHandler，创建代理对象，写增强方法）</p><p>（2）编写JDK动态代理代码</p><p>        （创建接口，定义方法）</p><p>        （创建接口实现类，实现方法）</p><p>        （使用Proxy类创建接口代理对象）</p><h3 id="4-通知（增强）：实际增强的逻辑部分就叫通知（增强）"><a href="#4-通知（增强）：实际增强的逻辑部分就叫通知（增强）" class="headerlink" title="4.通知（增强）：实际增强的逻辑部分就叫通知（增强）"></a>4.通知（增强）：实际增强的逻辑部分就叫通知（增强）</h3><p>        （前置通知）（@Before）</p><p>        （后置通知）（@AfterReturning)</p><p>        （环绕通知）（@Around）</p><p>        （异常通知）（@AfterThrowing）</p><p>        （最终通知）finally（@After）</p><h3 id="5-AOP操作（准备）"><a href="#5-AOP操作（准备）" class="headerlink" title="5.AOP操作（准备）"></a><strong>5.AOP操作（准备）</strong></h3><p>（1）在Spring框架中一般都是基于AspectJ实现AOP操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AspectJ不是Spring组成部分，独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作。</span><br></pre></td></tr></table></figure><p>（2）基于AspectJ实现AOP操作</p><p>        （基于xml配置文件实现）</p><p>        （基于注解方式实现）</p><p>（3）在项目工程中引入AOP相关依赖</p><p><img src="https://img-blog.csdnimg.cn/d919d07110f94d39b3f55bd889044f77.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_19,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/d919d07110f94d39b3f55bd889044f77.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_19,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>· </p><p>（4）切入点表达式</p><p>        （语法结构）</p><p>        execution （[权限修饰符] [返回类型] [类全路径] [方法名称] ([参数列表])）</p><h3 id="6-AOP操作（AspectJ注解）"><a href="#6-AOP操作（AspectJ注解）" class="headerlink" title="6.AOP操作（AspectJ注解）"></a><strong>6.AOP操作（AspectJ注解）</strong></h3><p>（1）创建类，在类里面定义方法</p><p>（2）创建增强类</p><p>           在增强类里面创建方法，不同的方法代表不同的类型通知</p><p>（3）进行通知的配置</p><p>           （在Spring配置文件中开启注解扫描）</p><p>          （使用注解创建User和UserProxy对象）<br>​<br>          （在增强类上面添加注解@Aspect）<br>​<br>            (在Spring配置中开启生成代理对象)</p><p><img src="https://img-blog.csdnimg.cn/625f75ec77404b1d95d8d6c98bb5802f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/625f75ec77404b1d95d8d6c98bb5802f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>（4）配置不同类型的通知</p><p>         在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</p><p><img src="https://img-blog.csdnimg.cn/bea6447bd0f04d42bd202536c2f05a47.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/bea6447bd0f04d42bd202536c2f05a47.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>（5）相同切入点抽取</p><p><img src="https://img-blog.csdnimg.cn/6a16b5caa35146d89d7097d986fa4b6e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/6a16b5caa35146d89d7097d986fa4b6e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>（6）设置增强类的优先级</p><p>        （在增强类的上面添加注解@Order（数字类型值），数字越小，优先级越高）</p><p><strong>两个可以找jar包和依赖的网站：</strong><br><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p><p><a href="https://developer.aliyun.com/mvn/search" title="仓库服务">仓库服务</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐网站考核总结（二）</title>
      <link href="/2022/03/13/yin-le-wang-zhan-kao-he-zong-jie-er/"/>
      <url>/2022/03/13/yin-le-wang-zhan-kao-he-zong-jie-er/</url>
      
        <content type="html"><![CDATA[<h2 id="学习上："><a href="#学习上：" class="headerlink" title="学习上："></a>学习上：</h2><h3 id="这次考核考的有点差劲，学长让我们再把内容完善一下，在完善的过程中我也学到了很多知识点："><a href="#这次考核考的有点差劲，学长让我们再把内容完善一下，在完善的过程中我也学到了很多知识点：" class="headerlink" title="这次考核考的有点差劲，学长让我们再把内容完善一下，在完善的过程中我也学到了很多知识点："></a><strong>这次考核考的有点差劲，学长让我们再把内容完善一下，在完善的过程中我也学到了很多知识点：</strong></h3><a id="more"></a><h3 id="（1）在过滤器中要想调用getSession（）方法，要先对request进行类型转换，否则不能直接调用getSession（）方法。"><a href="#（1）在过滤器中要想调用getSession（）方法，要先对request进行类型转换，否则不能直接调用getSession（）方法。" class="headerlink" title="** （1）在过滤器中要想调用getSession（）方法，要先对request进行类型转换，否则不能直接调用getSession（）方法。**"></a>** （1）在过滤器中要想调用getSession（）方法，要先对request进行类型转换，否则不能直接调用getSession（）方法。**</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest req= (HttpServletRequest) request;</span><br><span class="line">Object user=req.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="（2）联表查询："><a href="#（2）联表查询：" class="headerlink" title="**   （2）联表查询：**"></a>**   （2）联表查询：**</h3><p>                                内连接（等值内联，非等值内联，自连接）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T1.name, T2.name <span class="keyword">FROM</span> T1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> T2 <span class="keyword">ON</span> T1.id <span class="operator">=</span> T2.id</span><br></pre></td></tr></table></figure><p>                                           外连接（左外连接，右外连接，全外连接）</p><p>                左外连接：将左表内容全部显示，在右表没有找到相应的数据则记录为NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM T1 LEFT JOIN T2 ON T1.id = T2.id</span><br></pre></td></tr></table></figure><p>                  右外连接：将右表内容全部显示，在左表没有找到相应的记录为NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM T1 RIGHT JOIN T2 ON T1.id = T2.id;</span><br></pre></td></tr></table></figure><p>           </p><h3 id="考核过后，新的学习任务也发布下来了，希望这一阶段我能够好好学，不能再像上一阶段一样学的那么差劲了。"><a href="#考核过后，新的学习任务也发布下来了，希望这一阶段我能够好好学，不能再像上一阶段一样学的那么差劲了。" class="headerlink" title="考核过后，新的学习任务也发布下来了，希望这一阶段我能够好好学，不能再像上一阶段一样学的那么差劲了。"></a><strong>考核过后，新的学习任务也发布下来了，希望这一阶段我能够好好学，不能再像上一阶段一样学的那么差劲了。</strong></h3><h2 id="生活中："><a href="#生活中：" class="headerlink" title="生活中："></a>生活中：</h2><h3 id="这个星期感觉压力有点大。因为最近这学期课有点多，又加上我以前参加的东西比较多，就有点协调不过来的感觉。其实这一段时间挺迷茫的，以前总是想尝试更多的东西，导致我时间分配的太满了，就会有一种很累的感觉。希望以后我可以慢慢调整自己的时间安排，将时间规划好。"><a href="#这个星期感觉压力有点大。因为最近这学期课有点多，又加上我以前参加的东西比较多，就有点协调不过来的感觉。其实这一段时间挺迷茫的，以前总是想尝试更多的东西，导致我时间分配的太满了，就会有一种很累的感觉。希望以后我可以慢慢调整自己的时间安排，将时间规划好。" class="headerlink" title="这个星期感觉压力有点大。因为最近这学期课有点多，又加上我以前参加的东西比较多，就有点协调不过来的感觉。其实这一段时间挺迷茫的，以前总是想尝试更多的东西，导致我时间分配的太满了，就会有一种很累的感觉。希望以后我可以慢慢调整自己的时间安排，将时间规划好。"></a><strong>这个星期感觉压力有点大。因为最近这学期课有点多，又加上我以前参加的东西比较多，就有点协调不过来的感觉。其实这一段时间挺迷茫的，以前总是想尝试更多的东西，导致我时间分配的太满了，就会有一种很累的感觉。希望以后我可以慢慢调整自己的时间安排，将时间规划好。</strong></h3>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【音乐网站考核总结】</title>
      <link href="/2022/03/06/yin-le-wang-zhan-kao-he-zong-jie/"/>
      <url>/2022/03/06/yin-le-wang-zhan-kao-he-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>        这次考核对于我来讲难度好像有点大，可能是我在假期太放松的原因吧。在这次考核中我遇到了好多好多问题：</p><a id="more"></a><p>        首先就是上传文件时，原本我获取表单项的时候都用“request.getParameter(“xxx”)”方法，但是“request.getParameter(“xxx”)”方法在enctype=”multipart/form-data”时就已经失效，它永远返回null。所以在上传文件的时候用getString（）方法获取普通表单项。</p><p>        上一次考核的时候我把所有代码都放在一个类里面了，代码看起来很乱，这次我把相似功能的类和接口放在一个包里面，看起来效果好了很多。</p><p><img src="https://img-blog.csdnimg.cn/aa4459358b5d46c58cc9be1a468cd9e8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_14,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/aa4459358b5d46c58cc9be1a468cd9e8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_14,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p> </p><p>        还有考核的时候学长提示的，要使用过滤器，因为要是不使用过滤器的话有的网站不登录也可以通过修改地址访问，用过滤器还可以简化很多代码。在用户修改用户信息的时候账户不能从客户端传到服务端，因为通过修改地址用户也可以修改其他用户的信息，这点是我以前没有想到的。还有就是请求重定向和请求转发，我都用的请求转发，对于请求重定向我不是很了解，学过之后就没有再用过了，学长说用请求重定向比较好，所以这部分的知识我要去好好了解一下了。</p><p>        通过这次考核，我学到了好多好多知识点，上传文件，播放音乐······总体来讲进步很大。但这次我做的还有好多好多不足的地方，很多功能都没有实现，数据库建了好多好多，但是没有用到，充vip，订单，浏览历史······害，还是要好好学习基础的知识，这样才可以把考核任务做的又快又好。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每周总结】</title>
      <link href="/2022/02/26/mei-zhou-zong-jie/"/>
      <url>/2022/02/26/mei-zhou-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>        这周一直在做考核任务，因为假期学习效率太低，知识掌握的就很不牢固，所以我在做考核任务的时候就很难受，有点做不出来。而且我写的代码还总是出错，写网站的速度就很慢，这是我一直烦恼的一点。</p><a id="more"></a><p>        在做项目的时候因为我参考了视频，所以也学到了很多的知识点，比如我开始的时候写的类和接口就很多，几乎是一个方法就要写一个Servlet类，后来学会把几个方法整合到一个类中，我的代码看起来就没有以前那么乱了。还有就是上一次写系统的时候我啥都不懂，就写了一个主类，然后我的代码就看起来很长很长。这次比上次有点进步，学会把类和接口放在不同的包中，这样我的代码有的地方出错了我也能够很快地去修改。还有就是因为我写的代码经常报错，所以我就需要经常上网查找资料，在这个过程中我对我所写的代码也加深了理解。所以我感觉代码总是出错也不是一件很坏的事情吧。</p><p>        在这一周的学习过程中我有了一些进步，但同时也发现了自己好多好多做的很差劲的地方，希望我以后在学习的时候不要再那么马马虎虎的，要静下心把知识学好，学透彻。继续加油吧！rty=”userHeadshotUrl” column=”children_user_headshot”/&gt;<br>            <result property="objectId" column="children_object_id"/><br>            <result property="objectName" column="children_user_name"/><br>            <result property="commentContent" column="children_comment_content"/><br>            <result property="commentTime" column="children_comment_time"/><br>        </collection><br></resultMap></p><select id="viewComment" resultMap="postCommentPojo" parameterType="java.lang.Integer">        select a.post_comment_id,               a.user_id,               b.user_name,               b.user_headshot_url,               a.object_id,               a.comment_content,               a.comment_time,               c.post_comment_id as children_id,               c.user_id as children_user_id,               d.user_name as children_user_name,               d.user_headshot_url as children_user_headshot,               c.object_id as children_object_id,               d.user_name as children_user_name,               c.comment_content as children_comment_content,               c.comment_time as children_comment_time        from post_comment as a        inner join user as b on a.user_id = b.user_id        left join post_comment as c on a.post_comment_id = c.object_id        inner join user as d on c.user_id = d.user_id        where a.object_id = #{postId} and a.comment_state = '0' and c.comment_state = '1'</select><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">         这一段时间我的接口也写的差不多了，就剩下登录没有写好。在接下来的时间我准备把重心放在完善接口和回顾基础知识上面。</span><br><span class="line"></span><br><span class="line">---ngBuilder.append(0);</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuilder.append(hv);</span><br><span class="line">        &#125;</span><br><span class="line">        return stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>        这一段时间也一直在进行对算法的练习，真的感觉算法好难，有时候题解我都看不懂，一个算法解很长时间也解不对也是常有的事情。虽然有时候真的对算法很崩溃，但是不得不承认的一点是每次弄懂一道算法题真的会学到很多知识。]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【寒假总结】（三）</title>
      <link href="/2022/02/20/han-jia-zong-jie-san/"/>
      <url>/2022/02/20/han-jia-zong-jie-san/</url>
      
        <content type="html"><![CDATA[<p>配置程序</p><a id="more"></a><p>        这周在学习的过程中我遇到了一个问题，我的Tomcat突然启动不了了，一直闪退。事实上开始的时候我没有配置Tomcat的环境变量，但是软件却可以启动。但这周在idea上创建web项目的时候一直弹不出网页，看了报错才知道是服务器拒绝连接。我去启动Tomcat，才发现Tomcat出问题了，然后我去DOS窗口看运行Tomcat时报错，嗯······没有报错(⊙_⊙）。我上网查了查，网上说可能是在配置环境变量的时候多配置了JRE_HOME，因为JDK11.0之后手动生成jre，jre已经在jdk内部了，所以不需要在设置一个JRE_HOME。但是我根本没有配置JRE_HOME。然后我去问了同学，他问我是不是环境变量弄错了，我就按照他的环境变量去配置了一下我的，但是还是没有解决。后来我去查了端口是不是被占用了，是不是在把Tomcat整合到idea上的时候配置出了问题······但还是没有解决好。最后去问了组长，然后我把Tomcat重装了一下。在卸载Tomcat的时候也出现了好多问题，不过最后还是被我解决了。重装Tomcat之后就可以启动了，问题大部分都解决了，但是我比较迷的一点是我还没有配置环境变量呢，它怎么就可以正常运行了？？？(。_。)虽然我没有找到Tomcat出错的原因，但我感觉我在解决问题的过程中也学到了很多了，最后问题也解决了，也算有了很大的收获吧，嘿嘿嘿~</p><p>        快开学了，假期里面学习的太差劲了，希望到学校了可以好好学吧。</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【寒假总结】（二）</title>
      <link href="/2022/02/13/han-jia-zong-jie-er/"/>
      <url>/2022/02/13/han-jia-zong-jie-er/</url>
      
        <content type="html"><![CDATA[<p>        前一段时间放了十四天的假。嗯······假期的生活真的很快乐，可以和好久不见的朋友一起出去聚聚，和好久没有一起玩的朋友一起打游戏。但事实证明，我真的是一个没有丝毫自制力的孩子，假期过后我的学习进度更跟不上了，学习状态一直调整不过来。</p><a id="more"></a><p>        这一段时间在学习servlet的相关知识，感觉学习过程中遇到了好多好多问题，还有就是有时候会有点迷茫，不知道怎么去学习新的知识，因为在网上找到的资料我很多时候都理解不了，可能是我理解能力有点差劲了，总感觉网上那些文字好抽象，好难去理解（╥﹏╥）。还有每次新安装一个软件我都要耗费好多好多的时间去配置，去学习它是怎么使用的（这一方面我也总是弄不好，学的比较慢）。</p><p>        再讲一下算法上面的问题吧。感觉好久没有写算法了，前几天去写算法的时候我竟然连一些特别特别基础的知识都忘记了o(TヘTo)，本来我的算法就不好，现在······哎，看来以后还是要多加练习啊。</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【寒假总结】</title>
      <link href="/2022/01/23/han-jia-zong-jie/"/>
      <url>/2022/01/23/han-jia-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>        这周我们开始了新一阶段的学习任务，这一阶段有好多重要的知识要进行学习。但是在家的时候学习效率比较低，我就一直跟不上学习计划，进度可慢，就只能在接下来的学习过程中慢慢赶进度了。</p><a id="more"></a><p>        上一阶段的学习我都是看着Java书进行学习的，这一阶段我开始是准备视频和书结合着学习的，书上的知识有点难理解，我觉得有时候看视频会对那些知识理解的更深刻点。但是有时候书上和视频里面讲的知识侧重点不一样，就像书上几页的知识，看视频却要好长好长时间，有时候视频里面几分钟概况的知识，书上却用了几页去讲解。所以有一段时间我就可迷，不知道是看书好还是看视频好，不过后来慢慢就可以把两者协调好了，现在学习还是以书为主的。</p><p>        还有就是算法题的问题，力扣上一道简单的算法题我就要做好久，就离谱。还有就是写的时候可以通过示例，但是一提交就错，准确率有点低。希望我可以在以后的算法练习中谨慎一点，确定无误之后再提交，提高自己的准确率。</p><p>        至于假期在家的生活就很平淡，上周我有时候会和朋友出去玩，这周几乎都在家里面没有出去过。就挺无聊的。。<img src="https://img-blog.csdnimg.cn/3469cbc9217548fb90aea6172e08b390.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/3469cbc9217548fb90aea6172e08b390.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我总结（五）</title>
      <link href="/2022/01/16/zi-wo-zong-jie-wu/"/>
      <url>/2022/01/16/zi-wo-zong-jie-wu/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>        这个星期我们开始了在假期的学习。通过一个星期的学习，我明显感觉到了在家学习的弊端。我的自制力比较差，没有了在学校的约束，学习效率是真的下降了许多。不过到后来的几天我也注意了一下这个问题，对此慢慢做出了一些改变，现在的学习效率比才放假的时候提高了一些，也算是一种进步吧。</p><p>        这一周一直在做考核的系统。因为在前几次学习阶段我并没有很好的去完成学习计划，导致我在开始做管理系统的时候发现我对于集合这一方面的知识掌握的非常差劲。所以在考核的前两天我一直在复习关于集合的知识，考核的系统做的也就比较慢。还有就是虽然我在期末考试前将异常处理和io流学的差不多了，但由于当时学的比较快，对那一部分的知识掌握的不是很牢固，再加上长时间的不复习，导致我考核的时候也要回过头去复习io流的一些知识。希望我以后可以吸取这一次的教训，注意一下及时复习的问题。</p><p>        在假期的时候我们会在力扣上练习算法题。哎，我算法不好这一点我一直都知道。这几天我也是一直按照计划在练习。在力扣上做题的时候，我也学到了我以前没有掌握的一些知识，也是收获了很多吧。希望我在假期可以好好地练一下我的算法，至少不要再那么差劲了*~*。</p><p><img src="https://img-blog.csdnimg.cn/e4ca1c0f05c24a329752faf6d4b7ca18.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/e4ca1c0f05c24a329752faf6d4b7ca18.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我总结（四）</title>
      <link href="/2021/12/18/zi-wo-zong-jie-si/"/>
      <url>/2021/12/18/zi-wo-zong-jie-si/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>        这周我们又开始了新的学习任务，异常处理和IO流。感觉这一部分没有那么难理解，虽然我有时候还是会遇到一些想不通的地方。这段时间我学的还是比较快的，以前学java的时候总是跟不上小组的学习计划，这一次感觉还可以，但是学习计划前面安排复习面向对象和集合的那一部分我没有复习。我知道我那一部分学的很差劲，但是我想等到我把新的内容学完在回头去复习，这样如果复习的时间长的话我还可以把新学的内容复习一下。我怕我要是先复习的话后面的学习任务又会学不完······所以我就选择了先学习新的内容，最后再一起进行复习。</p><p>        虽然我这次学习的比较快，不至于像以前那样到考核的时间了，还是有大把的内容没有学习，但在最近的学习过程中我也发现了学的太快的弊端–学的快，忘得也贼快！嗯······记性不好，我也没有其他办法了，只能在学后面的内容的时候和前面的学习内容串一下了，这样可能会好点。到最后我再复习一下子，应该就差不多了吧？？？</p><p>        临近期末了，C语言的老师又告诉了我们一个不幸的消息，我们班好像安排在17周实训了。这感觉有点不太妙，17周要是实训的话我们复习的时间就非常非常少了。而且我们高数考试好像安排到了第一场，愁苦······<img src="https://img-blog.csdnimg.cn/20f69ccd8c8646a5adb77de79310b44f.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20f69ccd8c8646a5adb77de79310b44f.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我总结（三）</title>
      <link href="/2021/12/12/zi-wo-zong-jie-san/"/>
      <url>/2021/12/12/zi-wo-zong-jie-san/</url>
      
        <content type="html"><![CDATA[<p>分方向</p><a id="more"></a><p>        前端的考核结束了，现在要分前后端了。对于前后端，可能是我才接触的原因，感觉都挺有意思的。学长说前端前面学着比较简单，后面就比较难。而后端，我看组长给我发的那个图片，那是劝退的图片吧？？？一遍看下来，全是难！难！难！痛苦ing（*—*）。但是前端的话，我也不知道我学的怎么样，这段时间在做考核页面，感觉学的还可以，至少不像当初学习Java时候那么迷茫了（Java是真的难）。但至于具体选择哪个方向，还是看这次前端考的怎么样吧，看看我前后端哪个学的更好一点，比较适合哪个。</p><p>        在其他方面，嗯······这周举行了新生万米越野，特别快乐。事实上在举办之前我还在想怎么办，跑那么多圈我会累死的吧。但是在比赛完，虽然被学长学姐说我严重划水，但是那满满一兜的零食就是我的快乐源泉&amp;-&amp;。</p><p>        还有就是过几周就考试了，我的高数和c语言学的不是很好，怨我以前上课的时候总是划水。还有几周时间，希望我可以在这方面多用点心，别把不会的知识一直累积到复习周去解决。 </p><p><img src="https://img-blog.csdnimg.cn/98488768524a4bb7bd1d9d8cc0a3fcf2.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/98488768524a4bb7bd1d9d8cc0a3fcf2.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>·自我总结·</title>
      <link href="/2021/12/05/zi-wo-zong-jie/"/>
      <url>/2021/12/05/zi-wo-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>前端</p><a id="more"></a><p>        这一周过的好快啊，现在我们已经开始了前端的考核。在刚开始接触前端的时候，感觉学的还可以······但在开始考核的时候我才发现我需要学的知识还有好多好多。开始看视频的时候我确实是拉下了不少进度，所以后来我就加快了速度，但后面学习的内容是比较重要的，特别是解决高度坍塌那一块。当时看视频的时候因为在赶进度，所以也没有上手实践，就只是看看视频。在后面做考核页面的时候就发现我这方面的知识几乎没有记住，然后就只能边学习边做页面······我看有的同学做页面做的真的非常快，我连框架都没有构建好，他已经把大致的页面快做完了，所以有时候就会觉得有那么一丢丢小烦。但我知道急也没有用，哎，只能在接下来的时间好好努力了。</p><p>        还有就是在接下来的学习中我希望我可以利用好自己的空闲时间，顺便就是调整好自己的状态，因为最近看视频总是瞌睡······就可困······可能是太无聊？？？我觉得我以后要注意一下这个问题了，及时把它改正过来······</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客^-^</title>
      <link href="/2021/11/28/di-yi-pian-bo-ke/"/>
      <url>/2021/11/28/di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<p>        不知不觉中，我进入大学已经有一段时间了。记得才进入大学时的我，懵懵懂懂，内心对于大学充满了幻想。到现在，我发现我当初对于大学的想象确实是幻想······</p><a id="more"></a><p>        进入大学后我真的改变了很多，开始去尝试各种新的事物，感觉自己收获了挺多的。就比如打篮球。我感觉我可能真的不是很适合这个运动，但当时为了躲避早操（真的很累），然后就跟着朋友加入了女篮。开始训练的时候，表现得真的是非常非常差劲，特别是在练习胯下运球的时候，球就一直不听指挥（≧ ﹏ ≦）。但经过了一段时间的练习，我感觉我真的进步了。前几天篮球队进行了考核，在通过考核的时候，我突然就有了一种付出就会有回报的感觉（虽然我还是不会胯下运球，考核成绩也不是很好~-~）。</p><p>        还有就是在小组的学习因为加入了小组，平时的休息时间就变得很少，我以为我这样懒散的性子可能会有些不适应，但后来看来是我想多了。在最开始学习Java的时候真的是非常痛苦&gt;_&lt;，那是真的学不会啊，一直都跟不上进度。有一段时间我还一直请假（直接请假请到不好意思）。但是当时我感觉Java挺有意思的······现在我们在学习前端，我们主要是通过看视频学习的，我看视频的速度可能是有点慢了（虽然我前面一直都用二倍速看），所以我觉得我在接下来的学习中要加快速度了，总是跟不上进度可不行。而且我感觉我对于学习的积极性可能有点差，我都要被别人卷死了······希望我以后可以慢慢做出改变吧。</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>404</title>
      <link href="/404.html"/>
      <url>/404.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>bangumis</title>
      <link href="/bangumis/index.html"/>
      <url>/bangumis/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>看似不起眼的日复一日，会在将来的某一天，突然让你看到坚持的意义</title>
      <link href="/friends/index.html"/>
      <url>/friends/index.html</url>
      
        <content type="html"><![CDATA[<div class="site-card-group">    <a class="site-card" href="https://gulingc.github.io/"><div class="img"><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/lmy/friend/QQ%E5%9B%BE%E7%89%8720230720113944.jpg" class="lazyload placeholder" data-srcset="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/lmy/friend/QQ%E5%9B%BE%E7%89%8720230720113944.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/lmy/friend/53341353DC33417CD7CE15B2EC9D9766.jpg" class="lazyload placeholder" data-srcset="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/lmy/friend/53341353DC33417CD7CE15B2EC9D9766.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">林南而瑜</span><span class="desc">林南而瑜，不期而遇</span></div></a>    <a class="site-card" href="https://qmlmood.github.io/"><div class="img"><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/lmy/friend/%7D~%7B%5D%25%29%28S%60Q%28%28PB_VCF%5D2RVG.jpg" class="lazyload placeholder" data-srcset="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/lmy/friend/%7D~%7B%5D%25%29%28S%60Q%28%28PB_VCF%5D2RVG.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">Mood</span><span class="desc">小甲子的博客</span></div></a>    <a class="site-card" href="http://www.wall-e.icu/"><div class="img"><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/lmy/friend/9222af785e9ea40034b8fe6fd4b4e5d2.jpg" class="lazyload placeholder" data-srcset="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/lmy/friend/9222af785e9ea40034b8fe6fd4b4e5d2.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/lmy/friend/f47eaedf2a15f1f146ab382d9858206a.jpg" class="lazyload placeholder" data-srcset="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/lmy/friend/f47eaedf2a15f1f146ab382d9858206a.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">是小靳的~</span><span class="desc">欲买桂花同载酒，终不似少年游</span></div></a>    <a class="site-card" href="https://www.keeplover.top/"><div class="img"><img src="https://www.keeplover.top/img/index.jpg" class="lazyload placeholder" data-srcset="https://www.keeplover.top/img/index.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://www.keeplover.top/img/avatar.jpg" class="lazyload placeholder" data-srcset="https://www.keeplover.top/img/avatar.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">逐渐呆滞</span><span class="desc">快了，快了，快要找到了……</span></div></a>​<a class="site-card" href="https://www.zhaozihao.love/"><div class="img"><img src="https://www.zhaozihao.love//image/wallhaven-jx13zp_1920x1080.png" class="lazyload placeholder" data-srcset="https://www.zhaozihao.love//image/wallhaven-jx13zp_1920x1080.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/fWagzr4qJDKn8E9.jpg" class="lazyload placeholder" data-srcset="https://lmy-1311156074.cos.ap-nanjing.myqcloud.com/test/fWagzr4qJDKn8E9.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">赵子豪</span><span class="desc">茜茜在哪，我要找茜茜</span></div></a>​<a class="site-card" href="https://www.lovelsj.com/"><div class="img"><img src=" https://img.lovelsj.com/articles/0bee7ba5ac70155766648e14ae2a821f.jpg" class="lazyload placeholder" data-srcset=" https://img.lovelsj.com/articles/0bee7ba5ac70155766648e14ae2a821f.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://img.lovelsj.com/articles/QQ%E5%9B%BE%E7%89%8720220905144438.jpg" class="lazyload placeholder" data-srcset="https://img.lovelsj.com/articles/QQ%E5%9B%BE%E7%89%8720220905144438.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">瓜兮兮的男孩</span><span class="desc">五层血怒爆杀力扣</span></div></a></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>一定要爱着点什么，恰似草木对光阴的钟情</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h1><p>姓名: 李孟瑶  |  年龄：20  |  学历：本科  |  邮箱：<a href="mailto:&#x77;&#x2d;&#x6c;&#x69;&#45;&#x79;&#111;&#117;&#64;&#x66;&#111;&#x78;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;">&#x77;&#x2d;&#x6c;&#x69;&#45;&#x79;&#111;&#117;&#64;&#x66;&#111;&#x78;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;</a></p><h2 id="我的账号"><a href="#我的账号" class="headerlink" title="我的账号"></a>我的账号</h2><div style="display: flex;"><span class='btn center cool-2'><a class="button" href='https://blog.csdn.net/Alingte7' title='csdn'><i class='fa-solid fa-keyboard'></i>csdn</a></span><span style="width:5px;"></span><span class='btn center cool-2'><a class="button" href='https://codeforces.com/profile/W_Li_You' title='Codeforces'><i class='fa-solid fa-pencil'></i>Codeforces</a></span><span style="width:5px;"></span><span class='btn center cool-2'><a class="button" href='https://ac.nowcoder.com/acm/contest/profile/753873397' title='牛客'><i class='fa-solid fa-keyboard'></i>牛客</a></span><span style="width:5px;"></span><span class='btn center cool-2'><a class="button" href='https://leetcode.cn/u/zha-bi-xiao-xin-yan-zi-d/' title='力扣'><i class='fa-solid fa-pencil'></i>力扣</a></span></div><h2 id="我的技能"><a href="#我的技能" class="headerlink" title="我的技能"></a>我的技能</h2><div class='checkbox'><input type="radio" />            <p><strong>Java：</strong>熟悉Java 基础技术 ，熟悉集合，熟悉JVM内存模型及GC过程、JMM概念。</p>            </div><div class='checkbox'><input type="radio" />            <p><strong>框架：</strong>熟悉Spring、SpringMVC、Mybatis、Mybatis-plus、SpringBoot开发框架及SpringSecurity安全框架，并有一定开发经验。熟悉分布式框架SpringCloud，了解Nacos、RabbitMQ等中间件的使用。</p>            </div><div class='checkbox'><input type="radio" />            <p><strong>数据库：</strong>熟悉MySQL数据库及SQL优化，了解索引原理及数据库分库分表技术。熟悉Redis缓存中间件，能够使用Redis实现分布式锁，了解Redis持久化机制，哨兵机制。</p>            </div><div class='checkbox'><input type="radio" />            <p><strong>数据结构：</strong>熟悉常见的数据结构和算法，如十大排序算法以及链表和数组、栈与队列、二叉树等数据结构。</p>            </div><div class='checkbox'><input type="radio" />            <p><strong>并发：</strong>熟悉Java并发编程、synchronized和volatie、线程池。</p>            </div><div class='checkbox'><input type="radio" />            <p><strong>工具：</strong>熟悉使用Git版本管理工具、Maven、ApiFox等。</p>            </div><h2 id="我的项目"><a href="#我的项目" class="headerlink" title="我的项目"></a>我的项目</h2><div class="link-group"><div class="tagLink"><a class="link-card" title="项目一" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目一</p><p class="url">http://www.baidu.com</p></div></a></div><div class="tagLink"><a class="link-card" title="项目二" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目二</p><p class="url">http://www.baidu.com</p></div></a></div><div class="tagLink"><a class="link-card" title="项目三" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目三</p><p class="url">http://www.baidu.com</p></div></a></div><div class="tagLink"><a class="link-card" title="项目四" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目四</p><p class="url">http://www.baidu.com</p></div></a></div></div><h2 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a><strong>教育经历</strong></h2><p>2021.09-至今                计算机科学与技术（统招一本，1%~5%）                河南科技学院</p><p><strong>主修课程</strong>：数据结构、计算机组成原理、操作系统、算法设计与分析、电子技术基础等。</p><h2 id="校内经历"><a href="#校内经历" class="headerlink" title="校内经历"></a>校内经历</h2><p><strong>未来软件工作室</strong>                     后端负责人                 2021.10~至今</p><div class="note "><p>大一加入了院长和老师共同创办的未来软件工作室，利用课余时间进行 Java 学习和项目开发。 大二多次主导软件项目开发，获得了三项软件著作权。参加蓝桥杯，并获得了国赛三等奖。 大三担任工作室的后端负责人，负责后端学习的规划和学科竞赛相关的事情，并参与了校企合作</p></div><h2 id="我的荣誉"><a href="#我的荣誉" class="headerlink" title="我的荣誉"></a>我的荣誉</h2><p>第十四届蓝桥杯 Java 软件开发国赛三等奖</p><p>第十四届蓝桥杯 Java 软件开发省赛一等奖</p><p>第十三届蓝桥杯 Java 软件开发省赛二等奖</p><h2 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a><strong>自我评价</strong></h2><p>沟通能力强，有优秀的团队合作能力，在校与同学多次合作进行项目开发。</p><p>有一定的自学能力，在校期间利用课外时间自学编程相关知识。</p><p>具有良好的抗压能力，能够在紧张的环境下保持较好的工作效率。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>gallery</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>shuoshuo</title>
      <link href="/shuoshuo/index.html"/>
      <url>/shuoshuo/index.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://unpkg.com/artitalk"></script><div id="artitalk_main"></div><script>new Artitalk({    appId: 'eJbW6E6e9SRU5t1jE7Jno2Z3-gzGzoHsz',     appKey: 'W7kpeWkmV0dhfvj94ZmOtnRf' ,    serverURL: 'http://localhost:4000/shuoshuo/',    bgImg: ''})</script>]]></content>
      
    </entry>
    
    
  
</search>
