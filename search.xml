<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>中位数为key的子序列</title>
      <link href="/2023/03/19/%E5%92%8C%E4%B8%BAk/"/>
      <url>/2023/03/19/%E5%92%8C%E4%B8%BAk/</url>
      
        <content type="html"><![CDATA[<h3 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">和为 K 的子数组</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的连续子数组的个数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-107 &lt;= k &lt;= 107</code></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">​    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">​    map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> sum[i], d = t - k;</span><br><span class="line"></span><br><span class="line">​      ans += map.getOrDefault(d, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">​      map.put(t, map.getOrDefault(t, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>利用前缀和的思想，求出每一个元素到第一个元素的和，两个元素前缀和相减就是两个元素之间所有元素的和。</p><p>1、定义一个数组，用于存储所有元素的前缀和。</p><p>2、定义map集合，以前缀和为key</p><p>3、遍历sum，如果map中有（当前前缀和-k）为key的元素，就使得结果加上该key的value。再将当前元素前缀和存入map集合，如果不存在就存入0，存在就加一。</p><h3 id="统计中位数为-K-的子数组"><a href="#统计中位数为-K-的子数组" class="headerlink" title="统计中位数为 K 的子数组"></a><a href="https://leetcode.cn/problems/count-subarrays-with-median-k/">统计中位数为 K 的子数组</a></h3><p>给你一个长度为 <code>n</code> 的数组 <code>nums</code> ，该数组由从 <code>1</code> 到 <code>n</code> 的 <strong>不同</strong> 整数组成。另给你一个正整数 <code>k</code> 。</p><p>统计并返回 <code>nums</code> 中的 <strong>中位数</strong> 等于 <code>k</code> 的非空子数组的数目。</p><p><strong>注意：</strong></p><ul><li>数组的中位数是按递增顺序排列后位于中间的那个元素，如果数组长度为偶数，则中位数是位于中间靠左的那个元素。<ul><li>例如，<code>[2,3,1,4]</code> 的中位数是 <code>2</code> ，<code>[8,4,3,5,1]</code> 的中位数是 <code>4</code> 。</li></ul></li><li>子数组是数组中的一个连续部分。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,4,5], k = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：中位数等于 4 的子数组有：[4]、[4,5] 和 [1,4,5] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1], k = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：[3] 是唯一一个中位数等于 3 的子数组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= nums[i], k &lt;= n</code></li><li><code>nums</code> 中的整数互不相同</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span> t=n+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[pos] != k) ++pos;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;k)&#123;</span><br><span class="line">                count+=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;k)&#123;</span><br><span class="line">                count+=-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                count+=t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=pos)&#123;</span><br><span class="line">                res+=map.getOrDefault(count-t,<span class="number">0</span>);</span><br><span class="line">                res+=map.getOrDefault(count-t-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(count,map.getOrDefault(count,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这个思路和上面那道题思路差不多，求中位数为k的子序列，可以将大于k的元素都设为1，小于k的元素都设为-1，将等于k的元素都设为t，和为t或者t+1的序列排序后中位数就为key。注意t要大于序列的长度，否则当为一的元素多的话和也会为t。</p><p>1、遍历数组，找到值为k的元素的下标。</p><p>2、声明一个map，以前缀和为key，该前缀和出现的次数为value。</p><p>3、遍历数组，当元素大于k时前缀和加一，小于时加0，等于时加t。</p><p>4、进行比较，如果当前元素下标小于所找的元素下标，证明该元素前面所有子序列没有k出现，直接将前缀和存入map加一就行。如果大于所找元素下标，寻找有没有符合当前前缀和-t的map，将结果加上该key的value。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杨辉三角（算法）</title>
      <link href="/2023/03/11/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
      <url>/2023/03/11/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="链接：https-www-lanqiao-cn-problems-1457-learning"><a href="#链接：https-www-lanqiao-cn-problems-1457-learning" class="headerlink" title="链接：https://www.lanqiao.cn/problems/1457/learning/"></a>链接：<a href="https://www.lanqiao.cn/problems/1457/learning/">https://www.lanqiao.cn/problems/1457/learning/</a></h3><p>下面的图形是著名的杨辉三角形：</p><p><img src="https://dn-simplecloud.shiyanlou.com/courses/uid1357404-20210910-1631247098135" alt="image"></p><p>如果我们按从上到下、从左到右的顺序把所有数排成一列，可以得到如下数列： 1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,⋯1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,⋯</p><p>给定一个正整数 <em>N</em>，请你输出数列中第一次出现 <em>N</em> 是在第几个数？</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入一个整数 <em>N</em>。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出一个整数代表答案。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><blockquote><p>输入</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><blockquote><p>输出</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>对于 20的评测用例，1≤N≤10； 对于所有评测用例，1≤N≤10000000000。</p><h3 id="运行限制"><a href="#运行限制" class="headerlink" title="运行限制"></a>运行限制</h3><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对杨辉三角形进行仔细观察可知道，其中有很多数是重复的，因此我们只需要记录其有效部分。具体规律如下图所示：</p><p><img src=""></p><p>还可以发现，对于同一行，列数越大对应的数值也越大。而且某一行的某一列的值为x，在列数不变的情况下，无论行数怎么变大都不会再出现比x小的数；同理再行数不变的情况下列数怎么变大也不会出现比x小的数。并且得知n小于等于10的0次方时，有效列数为0-16列。因此我们可以一列一列的考虑，由于随着行号的变大，数值时单调递增的，其知道了行号、列号对应的数值也就知道了，于是便可以二分行号，使用二分查找的方法来计算本题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">16</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pan(i,n))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">pan</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=k*<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> right=Math.max(left,n);</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">suan</span> <span class="operator">=</span> suan(mid, k, n);</span><br><span class="line">            <span class="keyword">if</span>(suan&gt;=n)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">suan</span> <span class="operator">=</span> suan(right, k, n);</span><br><span class="line">        <span class="keyword">if</span>(suan==n)&#123;</span><br><span class="line">            System.out.println((<span class="type">long</span>)(right+<span class="number">1</span>)*right/<span class="number">2</span>+k+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">suan</span><span class="params">(<span class="type">long</span> mid,<span class="type">long</span> k,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">long</span> res=<span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> i=mid,j=<span class="number">1</span>;j&lt;=k;j++,i--)&#123;</span><br><span class="line">            res=res*i/j;</span><br><span class="line">            <span class="keyword">if</span>(res&gt;n)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-垃圾回收算法</title>
      <link href="/2023/03/01/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
      <url>/2023/03/01/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="判断对象已死："><a href="#判断对象已死：" class="headerlink" title="判断对象已死："></a>判断对象已死：</h1><h3 id="1、引用计数算法"><a href="#1、引用计数算法" class="headerlink" title="1、引用计数算法"></a>1、引用计数算法</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加一，当引用失效时，计数器就减一。任何时刻计数器为零的对象就是不可能再被使用的。</p><p><strong>优缺点：</strong></p><p>占用了一些额外的内存空间来计数，但它的原理简单，判定效率也高。</p><p>主流的Java虚拟机没有选用引用计数法来管理内存。主要原因时这个算法有很多例外情况要考虑，必须配合大量的额外处理才能保证正确的工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。</p><h3 id="2、可达性分析算法"><a href="#2、可达性分析算法" class="headerlink" title="2、可达性分析算法"></a>2、可达性分析算法</h3><p>通过一系列称为”GC Roots“的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为”引用链“。如果这个对象多GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象时不能再被使用的。</p><p><strong>可以作为GC Roots的对象包括以下几种：</strong></p><p>1、在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆中使用到的参数、局部变量、临时变量等。</p><p>2、在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 </p><p>3、在方法区中常量引用的对象，譬如字符串常量池里的引用。</p><p>4、在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</p><p>5、Java虚拟机内部的引用，如基本数据类型对饮的Class对象，一些常驻的异常对象等，还有系统类加载器。</p><p>6、所有被同步锁（synchronized关键字）持有的对象。</p><p>7、反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p><p><strong>被可达性分析算法判定为不可达时一定”非死不可“吗？</strong></p><p>不是”非死不可“。要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那么它将会被第一次标记。随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。假如对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为”没有必要执行“。</p><p>如果这个对象被判定为确有必要执行finalize（）方法，该对象会被放入一个F-Queue的队列中，然后在一条由一条虚拟机自动创建的，低调度优先级的Finalizer线程去执行它们的finalize（）方法。但是”执行“并不承诺一定会等待它运行结束。因为如果某个对象的finalize（）方法执行很慢，或者是发生死循环，会导致队列中其他对象处于等待状态，甚至导致整个内存回收子系统崩溃。</p><p>finalize（）方法是对象拯救自己的最后一次机会，随后收集器会对F-Queue中的对象进行第二次标记。如果对象在finalize（）方法中重新与引用链上的任何一个对象建立关联，成功拯救自己，那第二次标记时它就会被移出”即将回收”的集合。</p><p>值得注意的是，finalize（）方法只能被系统自动调用一次，如果对象面对下一次回收，它的finalize（）方法不回被再次执行，不能再次自救。</p><h1 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h1><h3 id="1、强引用"><a href="#1、强引用" class="headerlink" title="1、强引用"></a>1、强引用</h3><p>是最传统的”引用“的定义，是指在程序代码之中普遍存在的引用赋值，当用new创建对象的时候就是强引用。无论任何情况下，只要强引用的关系还在，垃圾回收器永远不会回收掉被引用的对象。</p><h3 id="2、软引用"><a href="#2、软引用" class="headerlink" title="2、软引用"></a>2、软引用</h3><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进收回范围之中进行二次回收。就是内存不满的时候不会回收，在内存满了之后会进行回收操作。</p><h3 id="3、弱引用"><a href="#3、弱引用" class="headerlink" title="3、弱引用"></a>3、弱引用</h3><p>弱引用也用来描述那些非必须的对象，但是他的强度比软引用更弱一些。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><h3 id="4、虚引用"><a href="#4、虚引用" class="headerlink" title="4、虚引用"></a>4、虚引用</h3><p>它是最弱的一种引用关系。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p><h1 id="垃圾收集算法："><a href="#垃圾收集算法：" class="headerlink" title="垃圾收集算法："></a>垃圾收集算法：</h1><h3 id="分代收集理论："><a href="#分代收集理论：" class="headerlink" title="分代收集理论："></a>分代收集理论：</h3><p>当前商用虚拟机的垃圾收集器，大多数遵循了“分代收集”的理论进行设计。他建立在分代假说之上：</p><p><strong>1）弱分代假说：</strong>绝大多数对象都是朝生夕灭的。</p><p><strong>2）强分代假说：</strong>熬过越多次垃圾收集过程的对象就越难以消亡。</p><p><strong>3）跨代引用假说：</strong>跨代引用相对于同代引用来说仅占极少数。</p><p>收集器应该将Java堆中划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之后存储。</p><p><strong>优缺点：</strong>同时兼顾了垃圾收集的时间开销和内存空间的有效利用。</p><h3 id="标记-清除算法："><a href="#标记-清除算法：" class="headerlink" title="标记-清除算法："></a>标记-清除算法：</h3><p>算法分为“标记”和“清除”两个阶段：首先标记出所有要被回收的对象，在标记完成后，同意回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记的过程就是对象是否属于垃圾的判定过程。</p><p><strong>优缺点：</strong></p><p>1、执行效率不稳定：如果Java堆中包含大量对象，而且其中大部分是要被回收的，这是必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量的增长而降低。</p><p>2、内存空间碎片化：标记、清除之后回产生大量不连续的内存碎片，空间碎片太多可能会导致当以后再程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发了一次垃圾收集动作。</p><h3 id="标记-复制算法："><a href="#标记-复制算法：" class="headerlink" title="标记-复制算法："></a>标记-复制算法：</h3><p>标记-复制算法常被简称为复制算法。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次性清理掉。</p><p><strong>优缺点：</strong></p><p>1、如果内存中多数对象是存活的话，这种算法将会产生大量的内存空间复制的开销。</p><p>2、对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存的时候也不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。实现简单，运行高效。</p><p>3、可用内存缩小为了原来的一半，内存浪费未免太多了。</p><h3 id="标记-整理算法："><a href="#标记-整理算法：" class="headerlink" title="标记-整理算法："></a>标记-整理算法：</h3><p>标记的过程和“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。</p><p><strong>优缺点：</strong></p><p>1、如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象的移动操作必须全程暂停用户应用程序才能进行，这就让使用者不得不小心翼翼地权衡其弊端，像这种的停顿被最初的虚拟机设计者形象地描述为“Stop The World”。</p><p>2、不像标记-复制算法那样浪费额外的空间，也不会像标记-清除算法一样产生空间碎片。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-Java内存区域</title>
      <link href="/2023/02/24/JVM-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
      <url>/2023/02/24/JVM-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="运行时数据区："><a href="#运行时数据区：" class="headerlink" title="运行时数据区："></a>运行时数据区：</h1><h3 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h3><p>当前线程所执行的字节码指令的行号指示器。在Java虚拟机的概念模型里，字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>线程私有，不会出现OutOfMemoryError异常。</p><h3 id="Java虚拟机栈："><a href="#Java虚拟机栈：" class="headerlink" title="Java虚拟机栈："></a>Java虚拟机栈：</h3><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候，Java虚拟机都会创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。</p><p>线程私有。如果线程请求的栈深度大于虚拟机栈所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈的容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p><h3 id="本地方法栈："><a href="#本地方法栈：" class="headerlink" title="本地方法栈："></a>本地方法栈：</h3><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><h3 id="Java堆："><a href="#Java堆：" class="headerlink" title="Java堆："></a>Java堆：</h3><p>Java堆是虚拟机所管理的内存中最大的一块。“几乎”所有的对象实例和数组都在这里分配内存。Java堆是垃圾收集器管理的内存区域，因此一些资料中把它称作“GC堆”。</p><p>线程共享。如果在Java堆中没有内存完成实例分配，并且堆也无法扩展时，Java虚拟机会抛出OutOfMemoryError异常。</p><h3 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h3><p>方法区用来存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。这块内存回收的主要目标是针对常量池的回收和对类型的卸载。</p><p>线程共享。如果方法区无法满足新的内存分配的需求时，将会抛出OutOfMemoryError异常。</p><p><strong>永久代：</strong></p><p>在JDK8之前，许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称为“永久代”。但本质上二者是不等价的。</p><p><strong>元空间：</strong></p><p>在JDK6，HotSpot团队逐步改为采用本地内存的方法来实现方法区的计划了。到了JDK8，终于完全废除了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间来代替，把JDK7中永久代还剩余的内容（主要是内存信息）全部移到元空间中。</p><p><strong>为什么用元空间代替永久代？</strong></p><p>1、避免OOM。使用永久代导致Java应用更容易遇到内存溢出的问题：永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小。元空间存在本地内存中，有系统实际可用空间来控制，当然也可以控制大小-XX：MaxMetaSpaceSize。</p><p>2、提高GC性能：永久代会位GC带来不必要的复杂度，而且回收效率偏低。</p><p>3、合并HotSpot和JRockit：在Oracle收购BEA取得JRockit的所有权后，准备把JRockit中的优秀功能移植到HotSpot虚拟机时，因为两者都对方法区的实现的差异而面临很多困难。</p><h1 id="对象的创建："><a href="#对象的创建：" class="headerlink" title="对象的创建："></a>对象的创建：</h1><h3 id="类加载："><a href="#类加载：" class="headerlink" title="类加载："></a>类加载：</h3><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h3 id="分配内存："><a href="#分配内存：" class="headerlink" title="分配内存："></a>分配内存：</h3><p>在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后就可以完全确定，为对象分配空间的任务实际上便等于把一块确定大小的内存块从Java堆中划分出来。</p><p><strong>分配内存的方法：</strong></p><p><strong>指针碰撞</strong>：如果Java堆中的内存是绝对规整的，所有被使用过内存都被放到一边，空闲的内存被放到另一遍，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个指针向空闲空间的方向挪动一段与对象大小相等的距离。</p><p><strong>空闲列表：</strong>如果Java堆中的内存并不是规整的，已经使用过内存和空闲的内存交错在一起，虚拟机必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</p><p><strong>并发情况下产生的问题：</strong></p><p>1、对分配内存空间的动作进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。</p><p>2、把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程需要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，通过-XX+：-UseTLAB参数来设定。</p><h3 id="初始化零值："><a href="#初始化零值：" class="headerlink" title="初始化零值："></a>初始化零值：</h3><p>内存分配完后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值，如果使用了TLAB，这项工作也可以提前到TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中不赋初值也可以直接使用。</p><h3 id="设置对象头："><a href="#设置对象头：" class="headerlink" title="设置对象头："></a>设置对象头：</h3><p>接下来Java虚拟机堆对象进行必要的设置，例如这个对象时哪个类的实例等。</p><h3 id="执行（）方法："><a href="#执行（）方法：" class="headerlink" title="执行（）方法："></a>执行<init>（）方法：</h3><p>上述操作完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象的创建才刚刚开始。一般来说，new指令之后会接着执行<init>（）方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p><h1 id="对象的内存布局："><a href="#对象的内存布局：" class="headerlink" title="对象的内存布局："></a>对象的内存布局：</h1><p>对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据和对齐填充。</p><h3 id="对象头："><a href="#对象头：" class="headerlink" title="对象头："></a>对象头：</h3><p>HotSpot虚拟机的对象头包括两类信息：</p><p><strong>用于存储对象自身的运行时数据：</strong>如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p><p><strong>类型指针：</strong>即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。但并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。</p><h3 id="实例数据："><a href="#实例数据：" class="headerlink" title="实例数据："></a>实例数据：</h3><p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p><h3 id="对齐填充："><a href="#对齐填充：" class="headerlink" title="对齐填充："></a>对齐填充：</h3><p>对齐填充并不是必然存在的，也没有特殊的含义，仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象的起始位置必须是8字节的证书倍，换句话说就是任何对象的大小都必须是8字节的整数倍。因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h1 id="对象的访问定位："><a href="#对象的访问定位：" class="headerlink" title="对象的访问定位："></a>对象的访问定位：</h1><p>我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。主流的访问方式主要有使用句柄和直接指针两种：</p><h3 id="使用句柄："><a href="#使用句柄：" class="headerlink" title="使用句柄："></a>使用句柄：</h3><p>如果使用句柄访问的话，Java堆中可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p><p><strong>优点：</strong>使用句柄来访问最大的好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><h3 id="直接指针："><a href="#直接指针：" class="headerlink" title="直接指针："></a>直接指针：</h3><p>如果使用直接指针访问的话，Java堆中的对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象的地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</p><p><strong>优点：</strong>使用直接指针来访问的最大好处就是速度更快，它节省了一次指针定位的时间开销。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM面试题</title>
      <link href="/2023/02/19/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/02/19/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="1、什么情况下会发生栈内存溢出。"><a href="#1、什么情况下会发生栈内存溢出。" class="headerlink" title="1、什么情况下会发生栈内存溢出。"></a>1、什么情况下会发生栈内存溢出。</h3><p>1、栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型<br>2、如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，方法递归调用产生这种结果。<br>3、如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多)<br>4、参数 -Xss 去调整JVM栈的大小</p><h3 id="2、详解JVM内存模型"><a href="#2、详解JVM内存模型" class="headerlink" title="2、详解JVM内存模型"></a>2、详解JVM内存模型</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzIyLzE2YzFhNDI2ZWQ5YWI0OGI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ?x-oss-process=image/format,png"></p><p>程序计数器：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有。</p><p>Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有。</p><p>Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有。</p><p>Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享。</p><p>方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。回收目标主要是常量池的回收和类型的卸载，各线程共享</p><h3 id="3、JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor？"><a href="#3、JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor？" class="headerlink" title="3、JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor？"></a>3、JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor？</h3><h5 id="1）共享内存区划分"><a href="#1）共享内存区划分" class="headerlink" title="1）共享内存区划分"></a><strong>1）共享内存区划分</strong></h5><p>共享内存区 = 持久带 + 堆<br>持久带 = 方法区 + 其他<br>Java堆 = 老年代 + 新生代<br>新生代 = Eden + S0 + S1</p><h5 id="2）一些参数的配置"><a href="#2）一些参数的配置" class="headerlink" title="2）一些参数的配置"></a><strong>2）一些参数的配置</strong></h5><p>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。<br>默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定)<br>Survivor区中的对象被复制次数为15(对应虚拟机参数 -XX:+MaxTenuringThreshold)</p><h5 id="3）为什么要分为Eden和Survivor-为什么要设置两个Survivor区？"><a href="#3）为什么要分为Eden和Survivor-为什么要设置两个Survivor区？" class="headerlink" title="3）为什么要分为Eden和Survivor?为什么要设置两个Survivor区？"></a>3）为什么要分为Eden和Survivor?为什么要设置两个Survivor区？</h5><p>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。<br>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。<br>设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）</p><h3 id="4、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？"><a href="#4、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？" class="headerlink" title="4、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？"></a>4、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？</h3><p>Java堆 = 老年代 + 新生代<br>新生代 = Eden + S0 + S1<br>当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。<br>大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；<br>如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。<br>老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。<br>Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。</p><h3 id="5、你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"><a href="#5、你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。" class="headerlink" title="5、你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"></a>5、你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</h3><h5 id="1）几种垃圾收集器："><a href="#1）几种垃圾收集器：" class="headerlink" title="1）几种垃圾收集器："></a><strong>1）几种垃圾收集器：</strong></h5><p><strong>Serial收集器：</strong> 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。<br><strong>ParNew收集器：</strong> Serial收集器的多线程版本，也需要stop the world，复制算法。<br><strong>Parallel Scavenge收集器：</strong> 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。<br><strong>Serial Old收集器：</strong> 是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。<br><strong>Parallel Old收集器：</strong> 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。<br><strong>CMS(Concurrent Mark Sweep) 收集器：</strong> 是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片。<br><strong>G1收集器：</strong> 标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记。不会产生空间碎片，可以精确地控制停顿。</p><h5 id="2）CMS收集器和G1收集器的区别："><a href="#2）CMS收集器和G1收集器的区别：" class="headerlink" title="2）CMS收集器和G1收集器的区别："></a><strong>2）CMS收集器和G1收集器的区别：</strong></h5><p>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；<br>G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；<br>CMS收集器以最小的停顿时间为目标的收集器；<br>G1收集器可预测垃圾回收的停顿时间<br>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片<br>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。</p><h3 id="6、JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。"><a href="#6、JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。" class="headerlink" title="6、JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。"></a>6、JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzIzLzE2YzFjMTk4MmUzNjA5YjE_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ?x-oss-process=image/format,png"></p><h3 id="7、简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"><a href="#7、简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。" class="headerlink" title="7、简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"></a>7、简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。</h3><h5 id="1）什么是类加载器？"><a href="#1）什么是类加载器？" class="headerlink" title="1）什么是类加载器？"></a>1）什么是类加载器？</h5><p>类加载器 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。</p><p>启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。<br>其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：<br>扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。<br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p><h5 id="2）双亲委派模型"><a href="#2）双亲委派模型" class="headerlink" title="2）双亲委派模型"></a>2）双亲委派模型</h5><p>双亲委派模型工作过程是：</p><p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p><p>双亲委派模型图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzIzLzE2YzFjNTRjZjRhZDg4NmI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ?x-oss-process=image/format,png"></p><h5 id="3）为什么需要双亲委派模型？"><a href="#3）为什么需要双亲委派模型？" class="headerlink" title="3）为什么需要双亲委派模型？"></a>3）为什么需要双亲委派模型？</h5><p>在这里，先想一下，如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么类之间的比较结果及类的唯一性将无法保证，因此，为什么需要双亲委派模型？防止内存中出现多份同样的字节码</p><h5 id="4）怎么打破双亲委派模型？"><a href="#4）怎么打破双亲委派模型？" class="headerlink" title="4）怎么打破双亲委派模型？"></a>4）怎么打破双亲委派模型？</h5><p>打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法。</p><h3 id="8、强引用、软引用、弱引用、虚引用的区别？"><a href="#8、强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="8、强引用、软引用、弱引用、虚引用的区别？"></a>8、强引用、软引用、弱引用、虚引用的区别？</h3><p><strong>1、</strong> 强引用，就是普通的对象引用关系，如 String s = new String(“ConstXiong”)</p><p><strong>2、</strong> 软引用，用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。SoftReference 实现</p><p><strong>3、</strong> 弱引用，相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。WeakReference 实现</p><p><strong>4、</strong> 虚引用是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来跟踪对象被垃圾回收的活动。PhantomReference 实现。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EasyExcel</title>
      <link href="/2023/02/05/easyexcel/"/>
      <url>/2023/02/05/easyexcel/</url>
      
        <content type="html"><![CDATA[<p>​        前一段时间在写一个灌溉系统的项目，项目要求有数据导入导出，这一块正好分配给我去完成了，所以我上网学了一下EasyExcel的使用。</p><a id="more"></a><h2 id="pom导入："><a href="#pom导入：" class="headerlink" title="pom导入："></a>pom导入：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;最新版本&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="实体类："><a href="#实体类：" class="headerlink" title="实体类："></a>实体类：</h2><p>@ColumnWidth：定义列宽</p><p>@ExcelProperty：value：用于匹配excel中的头，必须全匹配,如果有多行头，会匹配最后一行头</p><p>@ExcelIgnore：加了该注解的字段会被忽略</p><p>@DateTimeFormat：日期转换</p><p>@NumberFormat：数字转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ColumnWidth(20)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Field</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;地块编号&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String fieldId;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;冠层温度&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal canopyTemp;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;土壤含水量&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal soilMoisture;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;灌溉决策结果&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer result;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;灌溉情况&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String irrigationInfo;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;其他情况&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="导入："><a href="#导入：" class="headerlink" title="导入："></a>导入：</h2><h4 id="监听器："><a href="#监听器：" class="headerlink" title="监听器："></a>监听器：</h4><p>如果想在抛出异常时跳过异常的地方继续读接下来的数据，可以查看官方文档，在监听器中配置一个异常的方法。因为我写的时候想的是导入数据错误的话让他导入失败，所以没有进行配置这一项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelDataListener</span> <span class="keyword">implements</span> <span class="title class_">ReadListener</span>&lt;Field&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以100条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_COUNT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Field&gt; cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> FieldService fieldService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExcelDataListener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是demo，所以随便new一个。实际使用如果到了spring,请使用下面的有参构造函数</span></span><br><span class="line">        fieldService = <span class="keyword">new</span> <span class="title class_">FieldServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExcelDataListener</span><span class="params">(FieldService fieldService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fieldService = fieldService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个每一条数据解析都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Field data, AnalysisContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(data));</span><br><span class="line">        cachedDataList.add(data);</span><br><span class="line">        <span class="comment">// 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span></span><br><span class="line">        <span class="keyword">if</span> (cachedDataList.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">            saveData();</span><br><span class="line">            <span class="comment">// 存储完成清理 list</span></span><br><span class="line">            cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有数据解析完成了 都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里也要保存数据，确保最后遗留的数据也存储到数据库</span></span><br><span class="line">        saveData();</span><br><span class="line">        log.info(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上存储数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveData</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;条数据，开始存储数据库！&quot;</span>, cachedDataList.size());</span><br><span class="line">        fieldService.saveData(cachedDataList);</span><br><span class="line">        log.info(<span class="string">&quot;存储数据库成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="service："><a href="#service：" class="headerlink" title="service："></a>service：</h4><p>importData：调用接口传入文件，然后调用这个方法。</p><p>saveData：监听器存数据库时调用的方法，可以自定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ReturnUtil&lt;String&gt; <span class="title function_">importData</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EasyExcel.read(file.getInputStream(), Field.class, <span class="keyword">new</span> <span class="title class_">ExcelDataListener</span>(<span class="built_in">this</span>)).sheet().doRead();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> ReturnUtil.error(<span class="string">&quot;导入数据错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReturnUtil.success(<span class="string">&quot;导入数据完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveData</span><span class="params">(List&lt;Field&gt; fieldList)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Field field : fieldList) &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    &#125;</span><br><span class="line">    fieldDao.insertMore(fieldList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="导出数据："><a href="#导出数据：" class="headerlink" title="导出数据："></a>导出数据：</h2><p>因为我是导出为一个文件，所以将官方文档中的导出数据和下载文件结合到了一起。</p><p>按下面那个代码导出的文件名为”田间实时数据.xlsx”，然后表格头是在实体类中定义的。</p><p>这里我用了重复多次写入，因为我看官方文档中写的不能一次写入太多数据，否则会出错，所以我用分页的操作进行了多次写入，防止写入时出错。</p><p>注意：在测试的时候不能用swagger测试，不然下载的文件名是乱码，要把后缀名修改后才能查看。建议用postman或者在网页上直接测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ReturnUtil&lt;String&gt; <span class="title function_">exportData</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;</span>);</span><br><span class="line">    response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> EasyExcel.write(response.getOutputStream(), Field.class).build()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;田间实时数据&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename*=utf-8&#x27;&#x27;&quot;</span> + fileName + <span class="string">&quot;.xlsx&quot;</span>);</span><br><span class="line">        <span class="type">WriteSheet</span> <span class="variable">writeSheet</span> <span class="operator">=</span> EasyExcel.writerSheet(<span class="string">&quot;田间实时数据&quot;</span>).build();</span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> fieldDao.selectCount(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> total / <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">50</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            IPage&lt;Field&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(i, <span class="number">50</span>);</span><br><span class="line">            <span class="comment">// 分页去数据库查询数据 这里可以去数据库查询每一页的数据</span></span><br><span class="line">            List&lt;Field&gt; data = fieldDao.selectPage(page, <span class="literal">null</span>).getRecords();</span><br><span class="line">            excelWriter.write(data, writeSheet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">            List&lt;Field&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            excelWriter.write(data,writeSheet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;导出数据错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ReturnUtil.error(<span class="string">&quot;导出数据错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReturnUtil.success(<span class="string">&quot;导出数据完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2023/01/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>        给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><a id="more"></a><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1<br>示例 2：</p><p>输入：coins = [2], amount = 3<br>输出：-1<br>示例 3：</p><p>输入：coins = [1], amount = 0<br>输出：0</p><p>链接：<a href="https://leetcode.cn/problems/coin-change">https://leetcode.cn/problems/coin-change</a></p><p>思路：</p><p>我们采用自下而上的方式进行思考。仍定义 F(i)F(i) 为组成金额 ii 所需最少的硬币数量，假设在计算 F(i)F(i) 之前，我们已经计算出 F(0)-F(i-1)F(0)−F(i−1) 的答案。 则 F(i)F(i) 对应的转移方程应为</p><p><img src="https://appdocs.wpscdn.cn/api/v3/office/copy/QkNuTjJ6VGZLakFZbnA5dkVKNTdyV2dTNzRpNTR5Z2lJdmN5MWJ3bTJJTjArQ2pGTW43YjFrWi8rRUx4RGVtaFJINWJnaEFuQWxYTzVXekJ0a2lmd1kvTGhlMVBGZzM3OUFsOGRrb1pFclRsZG5yZWFLaWVnYmNnSUFxK0RIajhCQ1NWamxVRXo2OC9POW9xaStoWkh3WGFFMHVMc045Q0wzc01oNDVkZEV5YlNTODlseFlZS1VoV2Z2WE1OazVzVWVvL2U3QXpQTFo5Z0oxbHh0SmJkN1hKV29zcGNWdFF1SjZ3Z3lUbnZsWTRlMEtUYW95WUJvK1Y1bFl6MGdPMzRweEsyQjg1b0FocnVVV1Y5bFkwRE9wVlhuYjZxbDRicGNqY1J0RkFnZVRuRi9ranEzZFFsK1lBdjEyRQ==/attach/object/VEVNMAYATU" alt="img"></p><p>其中 cj代表的是第 j 枚硬币的面值，即我们枚举最后一枚硬币面额是 cj，那么需要从 i-cjj这个金额的状态 F(i-cj) 转移过来，再算上枚举的这枚硬币数量 1 的贡献，由于要硬币数量最少，所以 F(i)为前面能转移过来的状态的最小值加上枚举的硬币数量 1 。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> amount + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全排列（算法）</title>
      <link href="/2022/12/11/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%89/"/>
      <url>/2022/12/11/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><a id="more"></a><p>示例 1：</p><p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br>示例 2：</p><p>输入：nums = [0,1]<br>输出：[[0,1],[1,0]]<br>示例 3：</p><p>输入：nums = [1]<br>输出：[[1]]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/permutations">https://leetcode.cn/problems/permutations</a></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            output.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        backtrack(n, output, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//n:小链表长度</span></span><br><span class="line"><span class="comment">//output:链表</span></span><br><span class="line"><span class="comment">//res:返回的链表</span></span><br><span class="line"><span class="comment">//frist: 表示从左往右填到第first 个位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> first)</span> &#123;</span><br><span class="line">        <span class="comment">// 所有数都填完了，将列表放到结果集中</span></span><br><span class="line">        <span class="keyword">if</span> (first == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(output));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// Collections.swap()交换集合中两个位置的元素</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">            <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">            backtrack(n, output, res, first + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 撤销交换</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p><img src="https://img-blog.csdnimg.cn/5b700828f40741269d332c1db9327d66.png" alt="image-20221211134609207"></p><p>采用回溯法，从左往右每一个位置都依此尝试填入一个数，看能不能填完这 n个空格。</p><p>如果first=n，代表已经填完n个数，将队列放到结果集中。否则，填入一个之前没有填入过的数，使i=first，在first后的数字都没有填入过队列中，所以遍历first以后的数字，将数字填入first位置上，填完继续填下一位置。将全部的位置填完后，回到上一次递归的位置，将交换的两个数交换回来，即i与first位置上的数，继续for循环，一直到最后，全部的可能都排列出来。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本周小结</title>
      <link href="/2022/12/04/%E6%9C%AC%E5%91%A8%E5%B0%8F%E7%BB%93/"/>
      <url>/2022/12/04/%E6%9C%AC%E5%91%A8%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>​        因为疫情原因，学校提前放假了，我们也开始了在家的学习。这周总体来讲是招新的事情比较多，在家学习的话，我感觉我的学习效率不是特别高。</p><p>​        <a id="more"></a></p><p>​        前两天新分配了一个项目，和上次我们写的项目差不多，都是商城项目。我们上一次的话我主要写的是用户相关的东西，这次把订单相关的部分分给我了，感觉还挺不错的。虽然两次项目是差不多的，但是我两次写的东西是完全不同的，不用担心和上次的撞了。这次的话我想借鉴一下别人的源码，因为事实上平时我是很少看别人源码的，这次仿着其他项目写，也可以看出来我写的不好的地方，进行一下改善。当然借鉴源码不是准备完全照搬，只是看一下别人项目有什么亮点，完善完善自己的代码。</p><p>​        这一段时间还是在学习JVM，说实话这段时间的学习不是很好，视频看过了忘得太快了，而且太多了，看完一遍差不多学习计划就要截止了。感觉我需要转化一下学习的方法了，要不跟着视频看一遍，估计什么都记不住。到时候考核的话我还要留出一段时间去复习源码，因为上一次学习源码的时候学的有点偏了，有一些地方根本没有学到，面试的时候回答的挺差劲的，所以需要这次去留出时间去复习。</p><p>​        因为这一段时间在进行招新活动，也招进来了一部分人了，我们组也进了几个学弟学妹。虽然感觉他们基础不是特别好，但是态度都挺好的，我说什么事情他们也都可听话，挺欣慰的。</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合面试题</title>
      <link href="/2022/11/27/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/11/27/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ArrayList："><a href="#ArrayList：" class="headerlink" title="ArrayList："></a>ArrayList：</h1><h4 id="（1）JDK1-7和JDK1-8下ArrayList-底层数组的默认长度？"><a href="#（1）JDK1-7和JDK1-8下ArrayList-底层数组的默认长度？" class="headerlink" title="（1）JDK1.7和JDK1.8下ArrayList()底层数组的默认长度？"></a>（1）JDK1.7和JDK1.8下ArrayList()底层数组的默认长度？</h4><p>jdk1.7时使用ArrayList的无参构造，初始化后的长度是10，jdk1.8时使用无参构造，构造一个空数组，初始长度是0。</p><h4 id="（2）-如何复制某个ArrayList到另一个ArrayList中去？"><a href="#（2）-如何复制某个ArrayList到另一个ArrayList中去？" class="headerlink" title="（2） 如何复制某个ArrayList到另一个ArrayList中去？"></a>（2） 如何复制某个ArrayList到另一个ArrayList中去？</h4><p>使用clone()方法<br>使用ArrayList构造方法<br>使用addAll方法</p><h4 id="（3）arraylist怎么保证线程安全？"><a href="#（3）arraylist怎么保证线程安全？" class="headerlink" title="（3）arraylist怎么保证线程安全？"></a>（3）arraylist怎么保证线程安全？</h4><p>&lt;1&gt;、使用Vector</p><p>&lt;2&gt;、使用Collections.synchronizedList()</p><p>&lt;3&gt;、使用CopyOnWriteArrayList，涉及线程安全的部分，是通过写时复制的方式来实现。它内部有个volatile数组来保持数据。在“添加/修改/删除”数据时，会先获取互斥锁，再新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给volatile数组，然后再释放互斥锁。</p><p>1.在做修改操作的时候加锁</p><p>2.每次修改都是将元素copy到一个新的数组中，并且将数组赋值到成员变量array中。</p><p>3.利用volatile关键字修饰成员变量array，这样就可以保证array的引用的可见性，每次修改之前都能够拿到最新的array引用。</p><p>迭代器的弱一致性:弱一致性是指返回迭代器后，其他线程对list的增删改对迭代器是不可见的。</p><h4 id="（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？"><a href="#（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？" class="headerlink" title="（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？"></a>（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？</h4><p>使用ArrayList时，可以使用有参构造方法根据业务实际指定集合大小，以减少扩容的次数，提高写入效率。</p><h4 id="（5）Java集合的快速失败机制-“fail-fast”和安全失败机制“fail-safe”？"><a href="#（5）Java集合的快速失败机制-“fail-fast”和安全失败机制“fail-safe”？" class="headerlink" title="（5）Java集合的快速失败机制 “fail-fast”和安全失败机制“fail-safe”？"></a>（5）Java集合的快速失败机制 “fail-fast”和安全失败机制“fail-safe”？</h4><p>“fail-fast”是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。</p><p>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>“fail-safe”采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有的集合内容，在拷贝的集合上进行遍历。</p><p>原理：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><h4 id="（6）扩容机制？"><a href="#（6）扩容机制？" class="headerlink" title="（6）扩容机制？"></a>（6）扩容机制？</h4><p>首先判断当前数组是不是空数组，如果是空数组，那么将数据由0扩容到需求长度minCapacity，此时有参构造生成的空数组扩容到1，无参构造扩容到10，因为在计算minCapacity时，如果是无参构造，取默认长度和需求长度 minCapacity 中比较大的值，返回10。如果是有参构造的空数组，minCapacity返回1。</p><p>如果不是空数组，创建一个长度为原来数组长度1.5倍的新数组，当新数组长度大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于Integer的最大值，也就是溢出为负数，那么抛出内存溢出异常。否则的话根据与MAX_ARRAY_SIZE的比较情况确定返回Integer的最大值还是MAX_ARRAY_SIZE。最后将旧数组的值用Arrays.copyOf（）方法拷贝到新数组。</p><h4 id="（6）Iterator-和-ListIterator-有什么区别？"><a href="#（6）Iterator-和-ListIterator-有什么区别？" class="headerlink" title="（6）Iterator 和 ListIterator 有什么区别？"></a>（6）Iterator 和 ListIterator 有什么区别？</h4><p>（1）Iterator可以在所有集合中使用，而ListIterator只能在List类型和其子类型中使用</p><p>（2）ListIterator和Iterator都有hasnext（）和next（）方法可以实现顺序向后遍历，但是ListIterator有hasPrevious（）方法和previous（）方法，可以实现逆向遍历，Iterator不可以。</p><p>（3）ListIterator有add（）方法，可以向List中添加对象，而Iterator不能。</p><p>（4）ListIterator可以定位当前索引的位置，next Index（）和previous Index（）可以实现，Iterator没用此功能。</p><p>（5）两个都可以实现删除操作，但是ListIterator可以实现对象的修改，set（）方法可以实现，Iterator不能修改。</p><h4 id="（7）迭代器Iterator是什么？"><a href="#（7）迭代器Iterator是什么？" class="headerlink" title="（7）迭代器Iterator是什么？"></a>（7）迭代器Iterator是什么？</h4><p>Iterator是可以遍历集合的对象，为各种容器提供了公共的操作接口，隔离对容器的遍历操作和底层实现（解耦）。</p><p>迭代器是java23种设计模式之一，用于顺序访问集合对象的元素，无需知道集合对象的底层实现。</p><h4 id="（8）Array和ArrayList的区别？"><a href="#（8）Array和ArrayList的区别？" class="headerlink" title="（8）Array和ArrayList的区别？"></a>（8）Array和ArrayList的区别？</h4><p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</p><p>Array大小是固定的，所以需要事前确定合适的空间大小。ArrayList的大小是动态变化的，在每次添加新的元素的时候都会检查内部数组空间是否足够。</p><p>ArrayList提供了更多的方法和特性，比如：all All（），removeAll（），iterator（）等。</p><p>对于基本数据类型，ArrayList使用自动装箱来减少编码工作量；而当处理固定大小的基本数据类型的时候，这种方式相对比较慢，这时候应该使用Array。</p><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList:"></a>LinkedList:</h1><h4 id="（1）LinkedList-可以存储-null-值吗？元素可以重复吗？"><a href="#（1）LinkedList-可以存储-null-值吗？元素可以重复吗？" class="headerlink" title="（1）LinkedList 可以存储 null 值吗？元素可以重复吗？"></a>（1）LinkedList 可以存储 null 值吗？元素可以重复吗？</h4><p>LinkedList 底层是由双向链表实现的，并且在添加元素的时候，没有对元素进行值校验，所以可以存储 null 值，并且存储的元素是可以重复的。</p><h4 id="（2）LinkedList和ArrayList的相同点与不同点"><a href="#（2）LinkedList和ArrayList的相同点与不同点" class="headerlink" title="（2）LinkedList和ArrayList的相同点与不同点?"></a>（2）LinkedList和ArrayList的相同点与不同点?</h4><p><strong>相同点：</strong></p><p>都是List集合的实现类，允许出现重复的元素，元素有序。</p><p>都是不同步的，线程都不安全。</p><p><strong>不同点：</strong></p><p>ArratList集合的底层采用的是Object数组结构，LinkedList底层采用的是双向链表结构。</p><p>查询时，ArrayList实现了RandomAccess接口，支持随机访问，时间复杂度是O（1），LinkedList需要进行遍历，时间复杂度是O（n）。</p><p>在插入元素时，ArrayList插入和删除元素时，原数组该插入或者删除位置已经它之后的元素都要进行移位操作，时间复杂度都是O（n），而且增加的时候可能还会引起扩容。LinkedList只要遍历找到该索引在的位置然后改变指针指向即可，如果是添加到头节点前或者链表末尾的位置，时间复杂度就是O（1），如果是指定了索引位置，时间复杂度就是O（n），总体来讲LinkedList增加和删除时性能比ArrayList好。</p><p>空间占用方面，ArrayList存在一定的空间浪费，因为每次扩容都是以前的1.5倍。但是LinkedList每个元素都要存放它的前驱节点的位置和后继节点的位置，所以对每个元素的存储要比ArrayList消耗更大的空间。</p><p>ArrayList适合多读，增删少的情况，Linked适合少读，增删多的情况。</p><h4 id="（3）LinkedList版本前后变化？"><a href="#（3）LinkedList版本前后变化？" class="headerlink" title="（3）LinkedList版本前后变化？"></a>（3）LinkedList版本前后变化？</h4><p>LinkedList在1.6时底层是带头节点的双向循环列表，在1.7之后是不带头节点的双向链表。</p><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector:"></a>Vector:</h1><h4 id="（1）ArrayList和Vector的区别？"><a href="#（1）ArrayList和Vector的区别？" class="headerlink" title="（1）ArrayList和Vector的区别？"></a>（1）ArrayList和Vector的区别？</h4><p><strong>相同点：</strong></p><p>都实现了List接口。</p><p>底层数据结构都是数组。</p><p><strong>不同点：</strong></p><p>Verctor使用了Synchronized关键字来实现线程同步，所以线程是安全的，而ArrayList是线程不安全的。</p><p>在性能方面，因为Verctor很多方法使用了Synchronized关键字进行了加锁操作，所以性能不如ArrayList。</p><p>在扩容的时候，ArrayList扩容到原来的1.5倍，而Verctor扩容到原来的2倍。</p><p>Vector可以设置增长因子，而ArrayList不可以。</p><h4 id="（2）为什么不推荐使用Verctor？"><a href="#（2）为什么不推荐使用Verctor？" class="headerlink" title="（2）为什么不推荐使用Verctor？"></a>（2）为什么不推荐使用Verctor？</h4><p>Verctor每个操作方法都加的有synchronized关键字，针对性能来说会比较大的影响，导致它性能很差。</p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap:"></a>HashMap:</h1><h4 id="（1）HashMap-jdk1-7和1-8的区别？"><a href="#（1）HashMap-jdk1-7和1-8的区别？" class="headerlink" title="（1）HashMap jdk1.7和1.8的区别？"></a>（1）HashMap jdk1.7和1.8的区别？</h4><p>底层数据结构不一样，jdk1.7是链表加数组，数组用来存储数据，链表用来防止hash冲突。1.8是链表加数组加红黑树，数组用来存储数据，链表和红黑树用来防止hash冲突。在链表长度大于等于8并且数组长度大于64时链表会变成红黑树（数组长度小于64会进行扩容）。避免单条链表过长而影响查询效率，提高查询效率。</p><p>1.7新增链表节点会采用头插法，1.8新增链表节点采用尾插法，所以1.8不容易形成环形链表。</p><p>1.7在扩容后会按原来的方法重新计算扩容后元素的位置，1.8在扩容后元素计算在新数组中的位置时按规律计算，扩容后的位置=原来的位置或者原数组的长度+原位置。节省了重新计算hash值的时间。</p><p>1.7是先扩容后插入的，1.8是先插入后扩容。</p><p>在计算hash值的时候，1.7经过了四次位运算和五次异或运算一共九次扰动，1.8经过了一次异或运算和一次位运算一共两次扰动。（两次扰动分别是key.hashCode()与key.hashCode右移16位进行异或，这样子做的目的是高16位不变，低16位与高16位进行异或操作，进而减少碰撞的发生，高低位都参与到Hash的运算。如果不进行hash扰动，因为hash有32位，直接对数组长度取余，起作用的只是hash值的几个低位）。</p><h4 id="（2）为什么要增加红黑树？为什么不一直用红黑树？为什么到8转化为红黑树？到6转化为链表？"><a href="#（2）为什么要增加红黑树？为什么不一直用红黑树？为什么到8转化为红黑树？到6转化为链表？" class="headerlink" title="（2）为什么要增加红黑树？为什么不一直用红黑树？为什么到8转化为红黑树？到6转化为链表？"></a>（2）为什么要增加红黑树？为什么不一直用红黑树？为什么到8转化为红黑树？到6转化为链表？</h4><p>因为链表结构的查询效率是非常低的，他不像数组，能够通过索引开始找到想要的值，只能挨个遍历。当hash冲突很严重的时候，会严重影响查询的性能。当链化后链化特别严重，查询效率会退化到O（n），为了解决这个问题，jdk8中添加了红黑树来解决这个问题（时间复杂度O（logn））。</p><p>之所以不一直用红黑树，是为了权衡时间和空间，因为红黑树的节点占用空间是普通链表节点的两倍。</p><p>理想情况下随机hashCode算法下所有节点的分布频率会遵循泊松分布，链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。</p><p>因为转化成树和生成树的时间不会太短，为了避免频繁的转化。</p><h4 id="（3）为什么不用AVL树？为什么不用b树？为什么要用红黑树？"><a href="#（3）为什么不用AVL树？为什么不用b树？为什么要用红黑树？" class="headerlink" title="（3）为什么不用AVL树？为什么不用b树？为什么要用红黑树？"></a>（3）为什么不用AVL树？为什么不用b树？为什么要用红黑树？</h4><p>1、二叉排序树（二叉查找树）</p><p>1）若左子树不为空，则左子树上所有节点均小于根节点</p><p>2）若右子树不为空，则右子树上所有节点均大于根节点</p><p>3）左右子树也为二叉排序树</p><p>2、平衡二叉树（AVL树）：是一种二叉查找树，当且仅当两个子树的高度差不超过1时，这个树是二叉平衡树。</p><p>3、红黑树：是许多二叉查找树中的一种，它能保证在最坏的情况下，基本动态集合操作的时间为O（logn）。</p><p>每个节点非红即黑</p><p>根节点总是黑色的</p><p>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</p><p>每个叶子节点都是黑色的空节点（NIL节点）</p><p>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</p><h5 id="【1】为什么不用二叉排序树？"><a href="#【1】为什么不用二叉排序树？" class="headerlink" title="【1】为什么不用二叉排序树？"></a>【1】为什么不用二叉排序树？</h5><p>二叉排序树在添加元素的时候极端情况下会出现线性结构。（因为二叉排序树左子树所有的节点的值均小于根节点的特点，如果添加的元素都比根节点小，会导致左子树线性增长，这样就失去了用树型结构替换链表的初衷，导致查询时间增长），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p><h5 id="【2】为什么不用二叉平衡树（AVL树）？"><a href="#【2】为什么不用二叉平衡树（AVL树）？" class="headerlink" title="【2】为什么不用二叉平衡树（AVL树）？"></a>【2】为什么不用二叉平衡树（AVL树）？</h5><p>红黑树不追求完全平衡，他只要求部分达到平衡。红黑树是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数要比红黑树多。</p><p>在CurrentHashMap中是加锁了的，实际上是读写锁，如果写冲突就会等待，如果插入时间过程等待时间就更长，而红黑树相对于AVL树插入速度更快。</p><p>红黑树更加通用，它在添加，删除方面表现相对较好，但是AVL树的查找速度更快，代价是添加/删除速度较慢。</p><h5 id="【3】为什么不用B-B-树？"><a href="#【3】为什么不用B-B-树？" class="headerlink" title="【3】为什么不用B/B+树？"></a>【3】为什么不用B/B+树？</h5><p>B和B+树主要用于数据存储在磁盘上的场景，比如数据库索引就是用B+树实现的。这两种数据结构的特点就是树比较矮胖，每个结点存放一个磁盘大小的数据，这样一次可以把一个磁盘的数据读入内存，减少磁盘转动的耗时，提高效率。而红黑树多用于内存中排序，也就是内部排序。</p><h4 id="（4）HashMap-的方法？"><a href="#（4）HashMap-的方法？" class="headerlink" title="（4）HashMap 的方法？"></a>（4）HashMap 的方法？</h4><h5 id="【1】put方法？"><a href="#【1】put方法？" class="headerlink" title="【1】put方法？"></a>【1】put方法？</h5><p>调用hash函数获取key对应的hash值，再计算其数组下标。</p><p>如果没有出现hash冲突，则直接放入数组，如果出现hash冲突，则以链表的方式放在链表后面。如果链表的长度已经大于等于8，数组长度小于64进行扩容，数组长度大于64就把链表转化为红黑树。</p><p>如果节点的key已经存在，则替换value就行。</p><p>如果集合中的键值对大于数组长度*负载因子，调用resize（）方法进行扩容。</p><h5 id="【2】get方法？"><a href="#【2】get方法？" class="headerlink" title="【2】get方法？"></a>【2】get方法？</h5><p>通过hash&amp;（数组.length-1）获取该key对应的数据节点的hash值。</p><p>判断首节点是否为空，为空则直接返回空。</p><p>再判断首节点的key和目标值是否相同，相同则直接返回（首节点不用区分链表还是红黑树）。</p><p>首节点的next为空，则直接返回空。</p><p>首节点是树形节点，则进入红黑树的取值流程，并返回结果。</p><p>进入链表的取值流程，链表结构进行顺序遍历查找操作，每次用 == 符号 和 equals( ) 方法来判断 key 是否相同，满足条件则直接返回该结点。链表遍历完都没有找到则返回空。</p><h5 id="【3】resize方法（扩容）？"><a href="#【3】resize方法（扩容）？" class="headerlink" title="【3】resize方法（扩容）？"></a>【3】resize方法（扩容）？</h5><p>首先判断数组长度，如果大于0说明已经被初始化过，那么按当前数组长度的2倍进行扩容，阈值也变为原来的二倍。</p><p>若数组未被初始化过，且阈值大于0说明调用了HashMap的有参构造方法，那么就把数组大小设为阈值。</p><p>若数组未被初始化过，且阈值为0说明调用了HashMap的无参构造方法，那么就把数组的大小设为16，阈值设为16*负载因子。</p><p>接着需要判断如果不是第一次初始化，那么扩容之后1，要通过hash&amp;旧数组中的位置重新计算键值对的位置，若为0索引位置不变，不为0则并把他们新的位置=旧位置+旧数组长度，如果节点是红黑树类型的化则需要进行红黑树的拆分。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PC寄存器</title>
      <link href="/2022/11/20/pc%E5%AF%84%E5%AD%98%E5%99%A8/"/>
      <url>/2022/11/20/pc%E5%AF%84%E5%AD%98%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>使用PC寄存器存储字节码指令地址有什么用呢?为什么使用PC寄存器记原当前线程的执行地址呢?</strong><br>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。<br>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="https://img-blog.csdnimg.cn/90e5e881b0e24efd9a388500454e70d4.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>PC寄存器为什么会被设定为线程私有?</strong><br>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢﹖为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个Pc寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互千扰的情况。<br>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。<br>这样必然导致经常中断或恢复，如何保证分毫无差呢﹖每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒杀功能</title>
      <link href="/2022/11/12/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E7%A7%92%E6%9D%80%E5%8A%9F%E8%83%BD/"/>
      <url>/2022/11/12/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E7%A7%92%E6%9D%80%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>这次完善项目的时候加入了秒杀功能。这个功能要考虑的地方挺多的，我在网上找了一些资料，然后把这个功能大致完成了。但是还有很多地方我没考虑到，有些地方实现的不是很好，等以后再回头看对这个功能进行进一步的完善吧。</p><a id="more"></a><h2 id="记录一下我现在实现的一些功能："><a href="#记录一下我现在实现的一些功能：" class="headerlink" title="记录一下我现在实现的一些功能："></a>记录一下我现在实现的一些功能：</h2><h3 id="redis做缓存"><a href="#redis做缓存" class="headerlink" title="redis做缓存:"></a>redis做缓存:</h3><p>因为秒杀这个功能并发性是很大的，所以如果在秒杀的时候直接对mysql数据库进行操作，数据库可能承受不住，所以一般情况下都会用redis做缓存，将秒杀商品的信息存到redis里面，当redis里面查不到数据的时候再进入mysql查询，如果查询到数据，就将mysql中的数据写入到redis。</p><img src="https://img-blog.csdnimg.cn/495b19609c4a4e37a53dab3da59a9c91.png" style="zoom: 67%;" /><h3 id="库存问题："><a href="#库存问题：" class="headerlink" title="库存问题："></a>库存问题：</h3><p>在扣减内存时，要先判断一个用户是否已经购买过，确定未购买再进行扣减内存。但因为查询数据库和更新数据库不是原子性操作，在并发性很高的情况下，可能会出现超卖的情况。这时候可以使用lua脚本，查询和扣减内存的操作均在lua中进行，可以保证原子性。</p><p>key[1]:用来存储已经进行秒杀过的用户id</p><p>key[2]:存储秒杀商品内存</p><p>ARGV[1]:用户id</p><p>ARGV[2]:订单信息类转化为的Json</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> userKey=KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> stockKey=KEYS[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">local</span> userId=ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> orderMsg=ARGV[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">local</span> userExists=redis.call(<span class="string">&#x27;sismember&#x27;</span>,userKey,userId)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(userExists)==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, stockKey) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>,stockKey));</span><br><span class="line">    <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>);</span><br><span class="line">        redis.call(<span class="string">&#x27;sadd&#x27;</span>,userKey,userId);</span><br><span class="line">        redis.call(<span class="string">&#x27;lpush&#x27;</span>,<span class="string">&#x27;orderList&#x27;</span>,orderMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>-2:用户已经秒杀过，不能再进行秒杀</p><p>-1:秒杀商品在redis里面不存在，返回后对数据库进行查询，如果商品存在将商品信息存入redis，不存在直接返回</p><p>0:库存不足，直接返回</p><p>1:秒杀成功，将库存减一，用户id存入已经秒杀过的用户中</p><h3 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h3><p>在秒杀时先从redis数据库中查询数据，如果数据不存在就进入mysql查询。但是在高并发的情况下，一瞬间有很多请求同时进行，此时在redis中查询不到数据，就会全部进入mysql查询，会造成缓存击穿。解决缓存击穿有好几种方案，例如：热数据设置永不过期、加分布式锁。这里我使用了分布式锁，就是让很多请求同时查询不到数据的时候，只允许一个请求对mysql进行操作，这个请求将mysql中的数据读取到redis之后，其他请求再进入redis进行查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(result.equals(MagicIntegerEnum.STOCK_NO_EXIST.getKey()))&#123;</span><br><span class="line">    String lockKey=<span class="string">&quot;killLock&quot;</span>;</span><br><span class="line">    result = luaUtil.runLuaScript(<span class="string">&quot;Stock.lua&quot;</span>,keyList,userId.toString(),orderJson);</span><br><span class="line">    <span class="type">String</span> <span class="variable">userValue</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisUtil.setNx(lockKey, userValue, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        <span class="type">SecKill</span> <span class="variable">kill</span> <span class="operator">=</span> killDao.getByProId(proId, <span class="number">1</span>);</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(lockKey);</span><br><span class="line">        <span class="keyword">if</span>(kill==<span class="literal">null</span>)&#123;</span><br><span class="line">            luaUtil.runLockLua(<span class="string">&quot;Lock.lua&quot;</span>,list,userValue);</span><br><span class="line">            <span class="keyword">return</span> ReturnUtil.error(<span class="string">&quot;无秒杀商品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(redisUtil.hasKey(userKey)) &#123;</span><br><span class="line">            size = redisUtil.setMembers(userKey).size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> stock=kill.getKillStock()-size;</span><br><span class="line">        redisUtil.set(killKey, Integer.toString(stock));</span><br><span class="line">        luaUtil.runLockLua(<span class="string">&quot;Lock.lua&quot;</span>,list,userId.toString());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*只有在 key 不存在时设置 key 的值,将值 value 关联到 key ,设置过期时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setNx</span><span class="params">(String key,String value,<span class="type">long</span> timeout,TimeUnit unit)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForValue().setIfAbsent(key, value, timeout, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置过期时间，防止死锁。</p><p>如果在进行删除操作之前，一个锁刚好到过期时间，此时另一个请求正好加锁，就会释放掉别人的锁，所以加锁的时候要加userValue，在释放锁的时候判断一下是否是自己的锁，如果是，再将锁释放。因为在get和del之间可能也会出现异常，所以也要保证原子性，就在使用了lua脚本。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lockKey=KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> userValue=ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> exist=redis.call(<span class="string">&#x27;exists&#x27;</span>, lockKey);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(exist)==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;get&#x27;</span>,lockKey)==userValue) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;del&#x27;</span>,lockKey));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="异步下单："><a href="#异步下单：" class="headerlink" title="异步下单："></a>异步下单：</h3><p>在秒杀之后下单的操作其实并发性并没有那么高，我在网上找了一些资料，发现很多时候秒杀下单的时候会采用mq消息队列进行异步处理。但是因为我对这个不是很了解，就使用了redis的list做消息队列，这一部分完成的不是很理想，因为目前我对线程这一块的知识了解的特别特别特别模糊，等以后我学习了更多知识后再对这一部分进行完善。</p><p>目前的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        SKILL_ORDER.submit(<span class="keyword">new</span> <span class="title class_">OrderHandle</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderHandle</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            String queue=<span class="string">&quot;orderList&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">orderJson</span> <span class="operator">=</span> redisUtil.lBRightPop(queue, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">                    <span class="keyword">if</span> (orderJson == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(orderJson)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> JSON.parseObject(orderJson, Order.class);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) ((Math.random() * <span class="number">9</span> + <span class="number">1</span>) * <span class="number">100000</span>);</span><br><span class="line">                    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">                    <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMss&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> localDateTime.format(formatter);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> format + order.getUserId() + order.getProId() + order.getAddId() + i;</span><br><span class="line">                    <span class="type">SecKill</span> <span class="variable">kill</span> <span class="operator">=</span> killDao.getByProId(order.getProId(), <span class="number">1</span>);</span><br><span class="line">                    order.setOrderCode(code);</span><br><span class="line">                    order.setOrderPrice(kill.getKillPrice());</span><br><span class="line">                    orderDao.insertOrder(order);</span><br><span class="line">                    String orderKey=<span class="string">&quot;killOrder:&quot;</span>+order.getOrderId();</span><br><span class="line">                    redisUtil.setEx(orderKey,<span class="string">&quot;1&quot;</span>,<span class="number">10</span>,TimeUnit.MINUTES);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>@PostConstruct：在类启动的时候运行。</p><p>构造方法 ——&gt; @Autowired —— &gt; @PostConstruct ——&gt; 静态方法 （按此顺序加载）</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>客服功能</title>
      <link href="/2022/11/05/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%AE%A2%E6%9C%8D%E5%8A%9F%E8%83%BD/"/>
      <url>/2022/11/05/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%AE%A2%E6%9C%8D%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>最近一段时间我们在完善项目，我们在写的项目是一个商城项目。上次考核的时候考虑到进度问题，客服功能只做了一半，这次项目我对它进行了完善。</p><a id="more"></a><p>客服功能因为要实现即时通信，我主要是基于websocket实现的，它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。因为是第一次去写类似的功能，所以在实现过程中遇到了很多问题。</p><h3 id="离线消息："><a href="#离线消息：" class="headerlink" title="离线消息："></a><strong>离线消息</strong>：</h3><p>因为客服和用户并不是一直在线的，但是在用户离线的时候别人向他发送的消息他也应该接收到。所以在发送信息的时候我加了一个判断，当用户离线的时候将接收到的信息存到redis里面，在用户连接websocket的查询redis判断用户是否有离线的信息，如果有，在登录的时候一起发送过来。</p><p>发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Session</span> <span class="variable">userSession</span> <span class="operator">=</span> map.get(<span class="string">&quot;user:&quot;</span> + userId);</span><br><span class="line"><span class="keyword">if</span> (userSession != <span class="literal">null</span>) &#123;</span><br><span class="line">            userSession.getAsyncRemote().sendText(msgJson);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;msg@&quot;</span> + message.getUserId() + <span class="string">&quot;:offLine&quot;</span>;</span><br><span class="line">            redisUtil.lLeftPush(userKey, msgJson);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>登录时判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String chatKey= <span class="string">&quot;msg@&quot;</span> +userId + <span class="string">&quot;:offLine&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(redisUtil.hasKey(chatKey)&amp;&amp;redisUtil.lLen(chatKey)!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> redisUtil.lRightPop(chatKey);</span><br><span class="line">    session.getAsyncRemote().sendText(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="角色绑定："><a href="#角色绑定：" class="headerlink" title="角色绑定："></a>角色绑定：</h3><p>因为店铺与客服是一对多的关系，一个店铺里面可以有多个客服在线，当用户与客服进行聊天时，要保证一个客服和一个用户进行聊天，否则不符合逻辑。所以写项目的时候我给聊天列表设置了一个状态，客服可以查看所有的聊天列表，然后选择性进行接取业务，当一个聊天列表被一个客服接取后，其他客服不能进入这个聊天列表与用户进行聊天。</p><p>因为店铺与客服的一对多的关系，所以在用户反馈的时候该店铺的所有客服都可以看到聊天记录。我在用户给店铺发送信息的时候，先查询店铺里面有哪些客服，再查询客服的session，遍历给客服发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(value = &quot;/websocket/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketUtil&gt; webSocketSet = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;WebSocketUtil&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Session&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//    private static Map&lt;Integer, List&lt;Integer&gt;&gt; storeMap=new HashMap&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChatDao chatDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRedisUtil</span><span class="params">(RedisUtil redisUtil)</span>&#123;</span><br><span class="line">        WebSocketUtil.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChatDao</span><span class="params">(ChatDao chatDao)</span>&#123;</span><br><span class="line">        WebSocketUtil.chatDao = chatDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session,<span class="meta">@PathParam(&quot;userId&quot;)</span>Integer userId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.session = session;</span><br><span class="line">        <span class="built_in">this</span>.key=<span class="string">&quot;user:&quot;</span>+userId;</span><br><span class="line">        map.put(key, session);</span><br><span class="line">        String chatKey= <span class="string">&quot;msg@&quot;</span> +userId + <span class="string">&quot;:offLine&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(redisUtil.hasKey(chatKey)&amp;&amp;redisUtil.lLen(chatKey)!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> redisUtil.lRightPop(chatKey);</span><br><span class="line">            session.getAsyncRemote().sendText(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        webSocketSet.add(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//加入set中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;有新连接加入:&quot;</span>+userId+<span class="string">&quot;,当前在线人数为&quot;</span> + webSocketSet.size());</span><br><span class="line">        <span class="built_in">this</span>.session.getAsyncRemote().sendText(<span class="string">&quot;恭喜&quot;</span>+userId+<span class="string">&quot;成功连接上WebSocket(其频道号：&quot;</span>+userId+<span class="string">&quot;)--&gt;当前在线人数为：&quot;</span>+webSocketSet.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span> &#123;</span><br><span class="line">        webSocketSet.remove(<span class="built_in">this</span>);  <span class="comment">//从set中删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;有一连接关闭！当前在线人数为&quot;</span> + webSocketSet.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息*/</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message,<span class="meta">@PathParam(&quot;id&quot;)</span> String id)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生错误时调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">( Throwable error)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发生错误&quot;</span>);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 群发自定义消息</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">broadcast</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (WebSocketUtil item : webSocketSet) &#123;</span><br><span class="line">            <span class="comment">//同步异步说明参考：http://blog.csdn.net/who_is_xiaoming/article/details/53287691</span></span><br><span class="line">            <span class="comment">//this.session.getBasicRemote().sendText(message);</span></span><br><span class="line">            item.session.getAsyncRemote().sendText(message);<span class="comment">//异步发送消息.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(Integer userId, Integer storeId, Message message)</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">userSession</span> <span class="operator">=</span> map.get(<span class="string">&quot;user:&quot;</span> + userId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msgJson</span> <span class="operator">=</span> JSON.toJSONString(message);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userListKey</span> <span class="operator">=</span> <span class="string">&quot;userList:&quot;</span> + userId + <span class="string">&quot;@chat&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">storeListKey</span> <span class="operator">=</span> <span class="string">&quot;storeList:&quot;</span> + storeId + <span class="string">&quot;@chat&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">userList</span> <span class="operator">=</span> (<span class="type">int</span>) Double.parseDouble(redisUtil.zScore(userListKey, storeId + <span class="string">&quot;&quot;</span>) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">storeList</span> <span class="operator">=</span> (<span class="type">int</span>) Double.parseDouble(redisUtil.zScore(storeListKey, userId + <span class="string">&quot;&quot;</span>) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//发送给用户.</span></span><br><span class="line">        <span class="keyword">if</span> (userSession != <span class="literal">null</span>) &#123;</span><br><span class="line">            userSession.getAsyncRemote().sendText(msgJson);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;msg@&quot;</span> + message.getUserId() + <span class="string">&quot;:offLine&quot;</span>;</span><br><span class="line">            redisUtil.lLeftPush(userKey, msgJson);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        List&lt;Integer&gt; list = storeMap.get(storeId);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;msg@&quot;</span> + userList + <span class="string">&quot;:message&quot;</span>;</span><br><span class="line">        redisUtil.lLeftPush(userKey, msgJson);</span><br><span class="line">        <span class="type">String</span> <span class="variable">storeKey</span> <span class="operator">=</span> <span class="string">&quot;msg@&quot;</span> + storeList + <span class="string">&quot;:message&quot;</span>;</span><br><span class="line">        redisUtil.lLeftPush(storeKey, msgJson);</span><br><span class="line">        Integer chatListId;</span><br><span class="line">        <span class="keyword">if</span> (message.getMessageStatus() == <span class="number">0</span>) &#123;</span><br><span class="line">            chatListId = storeId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chatListId = userId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">numKey</span> <span class="operator">=</span> <span class="string">&quot;chat@No:&quot;</span> + chatListId + <span class="string">&quot;num&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (redisUtil.hasKey(numKey)) &#123;</span><br><span class="line">            redisUtil.incrBy(numKey, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisUtil.set(numKey, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(redisUtil.hasKey(<span class="string">&quot;chatService:&quot;</span>+storeId))&#123;</span><br><span class="line">            Set&lt;String&gt; strings = redisUtil.setMembers(<span class="string">&quot;chatService:&quot;</span> + storeId);</span><br><span class="line">             list = strings.stream().map(Integer::parseInt).collect(Collectors.toList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer id :</span><br><span class="line">                    list) &#123;</span><br><span class="line">                <span class="type">Session</span> <span class="variable">chatSession</span> <span class="operator">=</span> map.get(<span class="string">&quot;user:&quot;</span> + id);</span><br><span class="line">                String chatKey;</span><br><span class="line">                <span class="keyword">if</span> (chatSession != <span class="literal">null</span>) &#123;</span><br><span class="line">                    chatSession.getAsyncRemote().sendText(msgJson);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    chatKey = <span class="string">&quot;msg@&quot;</span> + message.getUserId() + <span class="string">&quot;:offLine&quot;</span>;</span><br><span class="line">                    redisUtil.lLeftPush(chatKey, msgJson);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引</title>
      <link href="/2022/10/30/mysql%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/10/30/mysql%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>mysql索引</p><a id="more"></a><h3 id="索引类型："><a href="#索引类型：" class="headerlink" title="索引类型："></a>索引类型：</h3><h4 id="按逻辑："><a href="#按逻辑：" class="headerlink" title="按逻辑："></a>按逻辑：</h4><p>普通索引：普通索引是mysql中最基本的索引，允许在列中插入重复值和空值，唯一的任务就是加快数据访问速度。</p><p>唯一索引：避免数据重复，唯一索引列的值必须唯一，允许有空值，如果是组合索引，则列值的组合必须唯一。</p><p>主键索引：主键索引是专门为主键字段创建的索引，一个表只能有一个主键，不允许有空值。</p><p>组合索引：在多个字段上创建的索引，只有在查询的时候使用了创建索引时的第一个字段，才会使用索引，遵循最左前缀原则。</p><p>全文索引：全文索引主要用来查询文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。只能在 CHAR、VARCHAR 或 TEXT 类型的列上创建。在mysql引擎中只有MyISAM引擎支持全文索引。</p><h3 id="索引优缺点："><a href="#索引优缺点：" class="headerlink" title="索引优缺点："></a>索引优缺点：</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>通过创建唯一索引，可以保持数据库中数据的唯一性。</p><p>使用索引可以大幅度提升系统性能，提高查询速度。</p><p>可以降低查询中分组和排序的时间。</p><p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>索引需要占用额外的物理空间。</p><p>当数据量非常大时，维护和创建索引也所耗费的时间也是非常大的。</p><p>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降<br>低了数据的维护速度。</p><h4 id="什么样的字段适合创建索引？"><a href="#什么样的字段适合创建索引？" class="headerlink" title="什么样的字段适合创建索引？"></a>什么样的字段适合创建索引？</h4><p>在经常需要搜索的列上，可以加快搜索的速度。</p><p>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。</p><p>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。</p><p>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p><h4 id="什么样的字段不适合创建索引？"><a href="#什么样的字段不适合创建索引？" class="headerlink" title="什么样的字段不适合创建索引？"></a>什么样的字段不适合创建索引？</h4><p>在查询中很少使用的列不应该创建索引。因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>数据值很少的表格也不应该创建索引。因为，当数据太少的时候，全盘搜索可能都比索引查找还快，就没有必要创建索引了，反而还会降低磁盘空间和性能。</p><p>定义为text、image和bit数据类型的列不应该创建索引。因为，这种列要么是数据相当大要么是数据相当少。</p><p>当修改性能远大于检索性能时不应该创建索引。因为，修改性能和检索性能是相矛盾的，两者只会一增一减。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vector源码</title>
      <link href="/2022/10/19/Vector/"/>
      <url>/2022/10/19/Vector/</url>
      
        <content type="html"><![CDATA[<p>Vector是基于数组实现的随机访问的同步的List结构，其public方法都是加锁的（加锁后不再需要临时变量保持原子性）</p><a id="more"></a><h2 id="Vector的继承关系"><a href="#Vector的继承关系" class="headerlink" title="Vector的继承关系:"></a>Vector的继承关系:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>继承了 AbstractList 抽象类，实现了 List 接口，实现了 RandomAccess, Cloneable, java.io.Serializabl e接口，所以支持快速访问、复制(拷贝)、序列化。</p><p>查和改操作速度非常快【时间复杂度：O(1)】,增和删操作相对较慢【时间复杂度：最快O(1)最慢O(n)】。</p><p>相比于 ArrayList 其效率低，因为加入了 synchronized 操作。</p><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized:"></a>Synchronized:</h4><p>线程安全是并发编程中的重要关注点，应该注意到的是，造成线程安全问题的主要诱因有两点:</p><ul><li>一是存在共享数据(也称临界资源)</li><li>二是存在多条线程共同操作共享数据</li></ul><p>为了解决这个问题，我们可能需要这样一个方案，当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行，这种方式有个高尚的名称叫互斥锁，即能达到互斥访问目的的锁，也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。在 Java 中，关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到synchronized另外一个重要的作用，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能），这点确实也是很重要的。</p><p>synchronized 是悲观锁的实现，因为 synchronized 修饰的代码，每次执行时都会进行加锁操作，同时只允许一个线程进行操作，所以它是悲观锁的实现。</p><p>synchronized 是非公平锁，并且是不可设置的。这是因为非公平锁的吞吐量大于公平锁，并且是主流操作系统线程调度的基本选择，所以这也是 synchronized 使用非公平锁原因。</p><p>同时，synchronized是一个典型的可重入锁，可重入锁最大的作用是避免死锁。</p><p><strong>三大特性：</strong><br><strong>synchronized保证原子性：</strong><br>1.通过monitorenter和monitorexit指令，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。<br>2.即使在执行过程中，由于某种原因，比如CPU时间片用完，线程1放弃了CPU，但是它并没有进行解锁。而由于synchronized的锁是可重入的，这就保证下一个时间片还是只能被他自己获取到，还是会继续执行代码。直到所有代码执行完为止。</p><p><strong>synchronized保证可见性：</strong><br>对于一个被synchronized修饰的变量，在其解锁之前，必须先把此变量同步回主存当中。</p><p><strong>synchronized保证有序性：</strong><br> 尽管synchronized无法禁止指令重排和处理器优化，但是可以通过单线程机制来保证有序性。由于synchronized修饰的代码，在同一时刻只能被同一线程访问，从根本上避免了多线程的情况。而单线程环境下，在本线程内观察到的所有操作都是天然有序的，所以synchronized可以通过单线程的方式来保证程序的有序性。</p><h2 id="LinkList主要方法分析："><a href="#LinkList主要方法分析：" class="headerlink" title="LinkList主要方法分析："></a>LinkList主要方法分析：</h2><h4 id="（一）字段"><a href="#（一）字段" class="headerlink" title="（一）字段"></a>（一）字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//储存Vector元素的数组</span></span><br><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Vector元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> elementCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Vector扩容增加的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> capacityIncrement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2767605614048989439L</span>;</span><br></pre></td></tr></table></figure><h4 id="（二）构造方法"><a href="#（二）构造方法" class="headerlink" title="（二）构造方法"></a>（二）构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  <span class="comment">//如果容量不合法，则抛出非法参数异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity]; <span class="comment">//设置新数组</span></span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;  <span class="comment">//赋值增加的容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造方法，initialCapacity数组容量，调用另一个有参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造方法，调用一个有参构造方法，容量设为10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造方法，构造指定列表内的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();  <span class="comment">//将集合转化为数组</span></span><br><span class="line">    elementCount = a.length;  <span class="comment">//赋值元素数量</span></span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;  <span class="comment">//如果c的类型是ArrayList，则直接对elementData赋值</span></span><br><span class="line">        elementData = a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elementData = Arrays.copyOf(a, elementCount, Object[].class); <span class="comment">//如果不是，进行转化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（三）常用方法"><a href="#（三）常用方法" class="headerlink" title="（三）常用方法"></a>（三）常用方法</h4><p><strong>扩容算法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部可以调用的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        modCount++; <span class="comment">//修改次数加一</span></span><br><span class="line">        ensureCapacityHelper(minCapacity);  <span class="comment">//调用ensureCapacityHelper()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)  <span class="comment">//如果最小长度大于数组长度，进行扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果capacityIncrement &gt; 0，则每次扩容增加capacityIncrement，否则，容量翻倍</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">  <span class="comment">//如果新容量还是小于最小容量，则容量取最小容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">     <span class="comment">//如果扩容的容量大于整型的最大值，则进行异常处理或者赋值为整型最大值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity); </span><br><span class="line">    <span class="comment">//调用Arrays.copyOf() 创建一个新的数组并将数据拷贝到新数组中，最后让 elementData 进行引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">//如果最小容量小于0，抛出内存溢出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="comment">//如果最小容量大于最大容量，取Integer最大值，否则取最大容量</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? </span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一般情况下，扩容分为两种情况，第一种是初始化Vector指定capacityIncrement，且为正数，则每次扩容增加capacityIncrement；另一种情况是，初始化未指定capacityIncrement，则每次扩容的容量翻倍。</p><p><strong>转为数组：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">copyInto</span><span class="params">(Object[] anArray)</span> &#123;</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, anArray, <span class="number">0</span>, elementCount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, elementCount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; elementCount)</span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());</span><br><span class="line"></span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, elementCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; elementCount)</span><br><span class="line">        a[elementCount] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数的方法实现思路与ArrayList如出一辙，Vector和ArrayList都是操作数组来实现列表，因此其实现的逻辑基本一致。</p><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h4 id="（1）ArrayList和Vector的区别？"><a href="#（1）ArrayList和Vector的区别？" class="headerlink" title="（1）ArrayList和Vector的区别？"></a>（1）ArrayList和Vector的区别？</h4><p><strong>相同点：</strong></p><p>都实现了List接口。</p><p>底层数据结构都是数组。</p><p><strong>不同点：</strong></p><p>Verctor使用了Synchronized关键字来实现线程同步，所以线程是安全的，而ArrayList是线程不安全的。</p><p>在性能方面，因为Verctor很多方法使用了Synchronized关键字进行了加锁操作，所以性能不如ArrayList。</p><p>在扩容的时候，ArrayList扩容到原来的1.5倍，而Verctor扩容到原来的2倍。</p><p>Vector可以设置增长因子，而ArrayList不可以。</p><h4 id="（2）为什么不推荐使用Verctor？"><a href="#（2）为什么不推荐使用Verctor？" class="headerlink" title="（2）为什么不推荐使用Verctor？"></a>（2）为什么不推荐使用Verctor？</h4><p>Verctor每个操作方法都加的有synchronized关键字，针对性能来说会比较大的影响，导致它性能很差。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkList源码</title>
      <link href="/2022/10/17/LinkList/"/>
      <url>/2022/10/17/LinkList/</url>
      
        <content type="html"><![CDATA[<p>LinkedList是一个双向链表的数据结构。</p><a id="more"></a><h2 id="LinkList的继承关系"><a href="#LinkList的继承关系" class="headerlink" title="LinkList的继承关系:"></a>LinkList的继承关系:</h2><p>LinkedList继承了AbstractSequentialList，从<em>Sequential</em>这个单词可以看出，该抽象类实现的是顺序访问的结构，因为可以推测可能和链表有关。ArrayList底层是由数组支持，而LinkedList是由双向链表实现的，其中的每个对象包含数据的同时还包含指向链表中前一个与后一个元素的引用。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7c77b61e791b55845538c2215f60844f.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><h4 id="AbstractSequentialList："><a href="#AbstractSequentialList：" class="headerlink" title="AbstractSequentialList："></a><strong>AbstractSequentialList：</strong></h4><p><img src="https://img-blog.csdnimg.cn/50b0d46e8acf42fda6fe44d16a8fe55b.png" alt="img" style="zoom:50%;" /><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>AbstractSequentialList 是Java中位于 java.util 包下的一个抽象类，它继承了 AbstractList 类，，并实现了AbstractList没实现的get(int)方法。但是保留了listIterator(int)，获取迭代器方法。以最大限度地减少实现由“顺序访问”数据存储（如链表）接口所需的工作。对于随机访问数据（如数组），应优先使用 AbstractList<br>而非此类。</p><h4 id="Deque："><a href="#Deque：" class="headerlink" title="Deque："></a><strong>Deque</strong>：</h4><p>这个接口，这个类名字的由来是“double ended queue”，也就是双向队列，即从头部和尾部都可以进行队列的操作。</p><p><img src="https://img-blog.csdnimg.cn/7c936d6fd9c5447dace493c2c7567193.png#pic_center" alt="在这里插入图片描述"></p><h2 id="LinkList主要方法分析："><a href="#LinkList主要方法分析：" class="headerlink" title="LinkList主要方法分析："></a>LinkList主要方法分析：</h2><h4 id="（一）字段"><a href="#（一）字段" class="headerlink" title="（一）字段"></a>（一）字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个linklist的大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头结点，永远指向第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾节点，永远指向最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item; </span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">//指向后一个元素</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">//指向前一个元素</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>transient关键字：</strong></p><p>transient是短暂的意思。对于transient 修饰的成员变量，在类的实例对象的序列化处理过程中会被忽略。 因此，transient变量不会贯穿对象的序列化和反序列化，生命周期仅存于调用者的内存中而不会写到磁盘里进行持久化。</p><p><strong>为什么要用transient关键字？</strong></p><p>在持久化对象时，对于一些特殊的数据成员（如用户的密码，银行卡号等），我们不想用序列化机制来保存它。为了在一个特定对象的一个成员变量上关闭序列化，可以在这个成员变量前加上关键字transient。</p><p><strong>transient的作用：</strong></p><p>transient是Java语言的关键字，用来表示一个成员变量不是该对象序列化的一部分。当一个对象被序列化的时候，transient型变量的值不包括在序列化的结果中。而非transient型的变量是被包括进去的。  注意static修饰的静态变量天然就是不可序列化的。</p><p><strong>transient使用总结:</strong></p><p>（1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法被访问。</p><p>（2） transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</p><p>（3）一个静态变量不管是否被transient修饰，均不能被序列化(如果反序列化后类中static变量还有值，则值为当前JVM中对应static变量的值)。序列化保存的是对象状态，静态变量保存的是类状态，因此序列化并不保存静态变量。</p><h4 id="（二）构造方法"><a href="#（二）构造方法" class="headerlink" title="（二）构造方法"></a>（二）构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将集合变成一个双向链表linklist</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（三）常用方法"><a href="#（三）常用方法" class="headerlink" title="（三）常用方法"></a>（三）常用方法</h4><p><strong>add:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">     checkPositionIndex(index); <span class="comment">//检查索引是否越界</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (index == size) <span class="comment">//如果索引等于链表长度，则在尾节点后面插入</span></span><br><span class="line">         linkLast(element);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         linkBefore(element, node(index));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index)) <span class="comment">//检查是否可以插入</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//检查是否可以插入</span></span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将节点插入链表尾部（最后一个节点后面）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//将尾节点的值赋值给l</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);  <span class="comment">//新建节点，以l为前驱节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++; <span class="comment">//长度加一</span></span><br><span class="line">    modCount++; <span class="comment">//修好次数加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将节点插入链表头部（第一个结点前面）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;  <span class="comment">//将第一个节点的值赋值给f</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f); <span class="comment">//新建节点，以头结点为后继节点</span></span><br><span class="line">    first = newNode;<span class="comment">//将第一个节点赋值为新建节点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>) <span class="comment">//如果链表为空，最后一个尾节点也应该是新建的节点</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode; <span class="comment">//如果链表不为空，将原先头节点的前驱节点设为新建节点</span></span><br><span class="line">    size++; <span class="comment">//长度加一</span></span><br><span class="line">    modCount++; <span class="comment">//修好次数加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个节点前插入</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;  <span class="comment">//将succ节点的前驱节点赋值给pred</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ); <span class="comment">//创建新节点</span></span><br><span class="line">    succ.prev = newNode; <span class="comment">//设新节点为succ的前驱节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>) <span class="comment">//如果原本succ的前驱节点为空，则可以认为插入后头节点就是新节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode; <span class="comment">//否则，将pred的后继节点设为新节点</span></span><br><span class="line">    size++; <span class="comment">//长度加一</span></span><br><span class="line">    modCount++; <span class="comment">//修好次数加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addAll：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将集合从指定位置开始插入</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    checkPositionIndex(index); <span class="comment">//检查index是否在size之内</span></span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray(); <span class="comment">//将集合转化为数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)  <span class="comment">//如果数组长度为0，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;  <span class="comment">//得到插入节点的前驱节点和后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;<span class="comment">//如果插入节点为尾部，前驱节点就是last，后继节点就是null</span></span><br><span class="line">        succ = <span class="literal">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则，调用node获取后继节点，再获取前驱节点</span></span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;  <span class="comment">//遍历数据将数据插入</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>); <span class="comment">//创建新节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="literal">null</span>)<span class="comment">//如果前驱节点是null，证明新节点就是头节点</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;  <span class="comment">//更新前驱节点为新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="literal">null</span>) &#123; <span class="comment">//如果后继节点为空，那么尾节点就是集合最后一个节点，即最后更新为pred的新节点</span></span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则，将后继节点与前面的节点连接起来</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;<span class="comment">//扩大链表长度</span></span><br><span class="line">    modCount++; <span class="comment">//增加修改次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>remove：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除第一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first; <span class="comment">//获取第一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)<span class="comment">//如果为空，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(); <span class="comment">//没有这样的元素异常</span></span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f); <span class="comment">//调用unlinkFirst()方法对元素进行删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123; <span class="comment">//私有方法，只能类内调用</span></span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element= f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next; <span class="comment">//获取f的后继节点赋值给next</span></span><br><span class="line">    f.item = <span class="literal">null</span>;<span class="comment">//将f的值赋为空</span></span><br><span class="line">    f.next = <span class="literal">null</span>; <span class="comment">// 依靠GC回收</span></span><br><span class="line">    first = next;  <span class="comment">//将头节点赋值为f的后继节点next</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) <span class="comment">//如果后继节点为空，那么尾节点也为空</span></span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="literal">null</span>; <span class="comment">//否则，将后继节点的前驱节点赋值为空</span></span><br><span class="line">    size--;<span class="comment">//将链表长度减一</span></span><br><span class="line">    modCount++;  <span class="comment">//操作数加一</span></span><br><span class="line">    <span class="keyword">return</span> element;  <span class="comment">//返回删除元素的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;<span class="comment">//删除尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;  <span class="comment">//删除尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> &#123;  <span class="comment">//和删除头节点相似</span></span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="literal">null</span>;</span><br><span class="line">    l.prev = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;  <span class="comment">//遍历链表找到null</span></span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;  <span class="comment">//遍历链表找到o</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unlink(Node&lt;E&gt; x) &#123;<span class="comment">//删除一个元素x</span></span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next; <span class="comment">//将节点的下一个位置赋值给next</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;  <span class="comment">//将节点的上一个位置赋值给prev</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123; <span class="comment">//如果prev等于null，证明头节点为next</span></span><br><span class="line">        first = next; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//否则上一个位置的后继节点为next，删除节点的前驱节点赋值为null</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123; <span class="comment">//和前面相似</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="literal">null</span>;  <span class="comment">//要删除的节点赋值为null</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p><p><strong>get:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item; <span class="comment">//调用node()方法</span></span><br><span class="line">&#125;</span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;<span class="comment">//这里采用了索引分开搜索的方法，缩小一半的搜寻量</span></span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123; <span class="comment">//如果索引小于size的一半</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) <span class="comment">//for循环</span></span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)  <span class="comment">//如果索引大于size的一半</span></span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h4 id="（1）LinkedList-可以存储-null-值吗？元素可以重复吗？"><a href="#（1）LinkedList-可以存储-null-值吗？元素可以重复吗？" class="headerlink" title="（1）LinkedList 可以存储 null 值吗？元素可以重复吗？"></a><strong>（1）LinkedList 可以存储 null 值吗？元素可以重复吗？</strong></h4><p>LinkedList 底层是由双向链表实现的，并且在添加元素的时候，没有对元素进行值校验，所以可以存储 null 值，并且存储的元素是可以重复的。</p><h4 id="（2）LinkedList和ArrayList的相同点与不同点"><a href="#（2）LinkedList和ArrayList的相同点与不同点" class="headerlink" title="（2）LinkedList和ArrayList的相同点与不同点?"></a>（2）LinkedList和ArrayList的相同点与不同点?</h4><p><strong>相同点：</strong></p><p>都是List集合的实现类，允许出现重复的元素，元素有序。</p><p>都是不同步的，线程都不安全。</p><p><strong>不同点：</strong></p><p>ArratList集合的底层采用的是Object数组结构，LinkedList底层采用的是双向链表结构。</p><p>查询时，ArrayList实现了RandomAccess接口，支持随机访问，时间复杂度是O（1），LinkedList需要进行遍历，时间复杂度是O（n）。</p><p>在插入元素时，ArrayList插入和删除元素时，原数组该插入或者删除位置已经它之后的元素都要进行移位操作，时间复杂度都是O（n），而且增加的时候可能还会引起扩容。LinkedList只要遍历找到该索引在的位置然后改变指针指向即可，如果是添加到头节点前或者链表末尾的位置，时间复杂度就是O（1），如果是指定了索引位置，时间复杂度就是O（n），总体来讲LinkedList增加和删除时性能比ArrayList好。</p><p>空间占用方面，ArrayList存在一定的空间浪费，因为每次扩容都是以前的1.5倍。但是LinkedList每个元素都要存放它的前驱节点的位置和后继节点的位置，所以对每个元素的存储要比ArrayList消耗更大的空间。</p><p>ArrayList适合多读，增删少的情况，Linked适合少读，增删多的情况。</p><h4 id="（3）LinkedList版本前后变化？"><a href="#（3）LinkedList版本前后变化？" class="headerlink" title="（3）LinkedList版本前后变化？"></a>（3）LinkedList版本前后变化？</h4><p>LinkedList在1.6时底层是带头节点的双向循环列表，在1.7之后是不带头节点的双向链表。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList源码</title>
      <link href="/2022/10/14/ArrayList/"/>
      <url>/2022/10/14/ArrayList/</url>
      
        <content type="html"><![CDATA[<p>ArrayList 是一个用数组实现的集合，支持随机访问，元素有序且可以重复。ArrayList继承AbstractList 并且实现了List和RandomAccess，Cloneable, Serializable接口。</p><a id="more"></a><h2 id="ArrayList继承关系："><a href="#ArrayList继承关系：" class="headerlink" title="ArrayList继承关系："></a>ArrayList继承关系：</h2><p><img src="https://img-blog.csdnimg.cn/2f2ba4f144434a548342fe7997fe4338.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><h4 id="RandomAccess："><a href="#RandomAccess：" class="headerlink" title="RandomAccess："></a><strong>RandomAccess：</strong></h4><p><img src="https://img-blog.csdnimg.cn/93ccf2e44b284bb19af3b02bd6e0c63f.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>Linked并没有实现RandomAccess接口，RandomAccess接口是一个标志接口。</p><p>只要List集合实现这个接口，就能支持快速随机访问。随机访问就是表示我们可以在常量时间复杂度内访问数据，也就是时间复杂度是O(1)。而链表是不可以随机访问的，比如说我们想通过下标访问链表当中的某个数据，需要从头结点或者尾节点开始遍历，直到遍历到下标对应的数据，时间复杂度为O(n)。</p><p>当一个List拥有快速访问功能时，其遍历方法采用for循环最快速。而没有快速访问功能的List，遍历的时候采用Iterator迭代器最快速。</p><p>在这个类的JavaDoc中，描述了ArrayList的一些特征，主要如下：</p><p>允许 put null 值，会自动扩容；<br>size、isEmpty、get、set、add 等方法时间复杂度都是 O(1)；<br>是非线程安全的，多线程情况下，推荐使用线程安全类：Collections#synchronizedList；<br>增强 for 循环，或者使用迭代器迭代过程中，如果数组大小被改变，会快速失败，抛出异常。<br>JavaDoc中还提到了fail-fast机制，这个会在下面将迭代器时提到。</p><p>实现这个接口的一些类：</p><p>ArrayList，Vector，CopyOnWriteArrayList，RandomAccessSubList，UnmodifiableArrayList</p><h4 id="Serializable："><a href="#Serializable：" class="headerlink" title="Serializable："></a>Serializable：</h4><p>这个接口主要用于序列化，所谓序列化就是能将对象写入磁盘，反序列化就是能够将对象从磁盘当中读取出来，如果想序列化和反序列化<code>ArrayList</code>的实例对象就必须实现这个接口，如果没有实现这个接口，在实例化的时候程序执行会报错。</p><h4 id="Cloneable："><a href="#Cloneable：" class="headerlink" title="Cloneable："></a>Cloneable：</h4><p>和serializable一样是标志接口。实现Cloneable接口那么实现Cloneable的类就能够调用clone这个方法，如果没有实现Cloneable接口就调用方法，则会抛出异常java.lang.CloneNotSupportedException。</p><p>(1)浅克隆（shallow clone），在拷贝一个对象时，对对象的基本数据类型的成员变量进行拷贝，但对引用类型的成员变量只进行引用的传递，并没有创建一个新的对象，当对引用类型的内容修改会影响被拷贝的对象。</p><p>(2)深克隆（deep clone），在拷贝一个对象时，除了对基本数据类型的成员变量进行拷贝，对引用类型的成员变量进行拷贝时，创建一个新的对象来保存引用类型的成员变量。</p><p>1.为什么Object类中的clone方法定义为protected，而不是public?</p><p>因为不是每个对象都可以被克隆的。Java的设计者故意强制子类在其对象可克隆的情况下重写表方法。</p><p>2.为什么clone方法不是定义在Cloneable接口中呢?</p><p>因为Java提供了一个本地方法来执行一个浅复制以克隆一个对象。由于接口中的方法是抽象的，该本地方法不能在接口中实现。因此，Java的设计者决定在Object类中定义和实现本地clone方法。</p><h4 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h4><p>这个接口主要定义了一些集合常用的方法让ArrayList进行实现，比如add，addAll，contains，remove，set，size，indexOf等等方法。</p><p>AbstractList，这个抽象类也实现了List接口里面的方法，并且为其提供了默认代码实现。</p><h2 id="ArrayList主要方法分析："><a href="#ArrayList主要方法分析：" class="headerlink" title="ArrayList主要方法分析："></a>ArrayList主要方法分析：</h2><h4 id="（一）字段"><a href="#（一）字段" class="headerlink" title="（一）字段"></a>（一）字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">serialVersionUID属性是用来序列的标识符/反序列化的对象序列化类。我们使用serialVersionUID属性记住Serializable类的版本，以验证加载的类和序列化的对象是否兼容。</span></span><br><span class="line"><span class="comment">序列化运行时与每个可序列化的类关联一个版本号，称为serialVersionUID，在反序列化期间使用该版本号来验证序列化对象的发送者和接收者是否已加载了该对象的与序列化兼容的类。如果接收者为对象加载的类serialVersionUID与相应的发送者的类不同，则反序列化将导致 InvalidClassException。可序列化的类可以serialVersionUID通过声明一个serialVersionUID必须为static，final和type的字段来显式声明其自身long。不同类的serialVersionUID属性是独立的。因此，不同的类不必具有唯一的值。</span></span><br><span class="line"><span class="comment">如果可序列化的类未显式声明一个 serialVersionUID，则序列化运行时将根据serialVersionUID该类的各个方面为该类计算默认值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ArrayList 当中默认初始化容量，也就是初始化数组的大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用于空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用于默认大小的空实例的共享空数组实例。 </span></span><br><span class="line"><span class="comment">们将其与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时扩容多少。</span></span><br><span class="line"><span class="comment">无参构造函数 使用该数组初始化 与EMPTY_ELEMENTDATA的区别主要是区分作用，用来减少空数组的存在，优化内存使用 1.8后的优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存放具体数据的数组 ArrayList 底层就是使用数组进行存储的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">size 表示容器当中数据的个数 注意和容器的长度区分开来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure><p>private static final Object[] EMPTY_ELEMENTDATA = {};</p><p>private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</p><p>这两个是用来共享给空数组的，无参构造函数的空数组会用DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋值，有参构造函数的空数组会用EMPTY_ELEMENTDATA赋值。</p><h4 id="（二）构造方法"><a href="#（二）构造方法" class="headerlink" title="（二）构造方法"></a>（二）构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传入一个初始化容量，如果传入的数字大于零，则创建一个容量为 initialCapacity 的Object类型的数组</span></span><br><span class="line"><span class="comment">如果等于零，则引用一个空数组</span></span><br><span class="line"><span class="comment">因为容量不能小于零，所以当传入的数字小于零时，抛出一个异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity]; <span class="comment">//构造数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA; <span class="comment">//引入空数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);<span class="comment">//抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空参构造器，直接用DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传入了一个集合，如果这个集合的为空，直接传一个空数组</span></span><br><span class="line"><span class="comment">不为空，就判断是不是一个数组，是的话直接拷贝到elementData</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;        <span class="comment">//不为空</span></span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">            elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA; <span class="comment">//集合为空，直接传一个空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（三）常用方法"><a href="#（三）常用方法" class="headerlink" title="（三）常用方法"></a>（三）常用方法</h4><h4 id="add："><a href="#add：" class="headerlink" title="add："></a>add：</h4><p>放置新元素的时候没有进行任何的判断，所以ArrayList是允许null值的，且放置是没有加锁，使得ArrayList是线程不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接将待添加的元素放在数组末尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个函数的主要目的是确保 elementData 的容量有 size + 1</span></span><br><span class="line"><span class="comment">否则存储数据的时候数组就会越界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">//扩容</span></span><br><span class="line"><span class="comment">//size 表示容器当中数据的个数 注意和容器的长度区分开来,加入数据之后 容器当中数据的个数也要 + 1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在要求的位置放置某个元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">检查index位置是否可用,判断下是否超出数组范围，超出的话就会抛出IndexOutOfBoundsException异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);<span class="comment">//用ensureCapacityInternal()方法检查数组容量</span></span><br><span class="line"><span class="comment">//使用System.arraycopy方法将index位置及其之后的元素向后拷贝一个单位，再将待插入元素放置在index处即可。</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/img_convert/c067fed59830ddd05ca797cca4ded171.jpeg" alt="img" style="zoom: 67%;" /><h4 id="ensureCapacityInternal（扩容部分的核心实现）"><a href="#ensureCapacityInternal（扩容部分的核心实现）" class="headerlink" title="ensureCapacityInternal（扩容部分的核心实现）:"></a>ensureCapacityInternal（扩容部分的核心实现）:</h4><img src="https://img-blog.csdnimg.cn/img_convert/deb6bbc2d7011c18712266c978d3e9ee.png" alt="img" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line"><span class="comment">// 如果是无参构造的话，取默认长度和需求长度 minCapacity 中比较大的值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该ArrayList是使用无参构造构建的，那么我们就需要返回DEFAULT_CAPACITY和minCapacity中较大的值。那么在第一次插入的时候，显然DEFAULT_CAPACITY较大，默认值为10，那么我们第一次插入，数组就会扩容为10。而使用有参构造参数为0的方法的话，在这一步返回的仅仅是1。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//调用了ensureExplicitCapacity方法</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++; <span class="comment">//将modCount自增一,这个表示容器发生改变的次数,它跟容器扩容没关系</span></span><br><span class="line">    <span class="comment">//如果最小的需求容量 minCapacity 大于现在容器当中数组的长度，则需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);<span class="comment">//调用grow()方法将底层数组扩容到minCapacity</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 新数组的长度为原数组的长度的1.5倍，右移一位相当于除以2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果新数组的长度，小于需要的最小的容量，则更新数组的长度为 minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line"><span class="comment">//将新的大小和MAX_ARRAY_SIZE的值比较，如果超过了这个值，那么newCapacity就会被赋为hugeCapacity()</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这个函数的主要目的是判断整数是否发生溢出</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 将旧数组的元素拷贝到新数组即可</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// 如果溢出，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果最少需要的值大于MAX_ARRAY_SIZE的话，就只会扩容到Integer.MAX_VALUE，否则就扩容到MAX_ARRAY_SIZE。这里就说明了ArrayList的容量上限为Integer.MAX_VALUE。如果达到了该值，就不会再为ArrayList分配空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove:"></a>remove:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据下标删除元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">//检查是否越界</span></span><br><span class="line"></span><br><span class="line">    modCount++;  <span class="comment">//将modCount自增一,这个表示容器发生改变的次数</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index); <span class="comment">//获取要删除的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>; <span class="comment">//判断数组后面还有多少元素</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) <span class="comment">//将删除元素后面的元素往前copy一份</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// 将最后一个元素设为null，可以进行垃圾回收了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除list中第一个等于o的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                fastRemove(index); <span class="comment">//调用fastRemove()删除指定下标的元素</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有方法，外部不能调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get:"></a>get:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">//检查是否越界</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size) <span class="comment">//越界抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h2><h4 id="（1）JDK1-7和JDK1-8下ArrayList-底层数组的默认长度？"><a href="#（1）JDK1-7和JDK1-8下ArrayList-底层数组的默认长度？" class="headerlink" title="（1）JDK1.7和JDK1.8下ArrayList()底层数组的默认长度？"></a>（1）JDK1.7和JDK1.8下ArrayList()底层数组的默认长度？</h4><p>jdk1.7时使用ArrayList的无参构造，初始化后的长度是10，jdk1.8时使用无参构造，构造一个空数组，初始长度是0。</p><h4 id="（2）-如何复制某个ArrayList到另一个ArrayList中去？"><a href="#（2）-如何复制某个ArrayList到另一个ArrayList中去？" class="headerlink" title="（2） 如何复制某个ArrayList到另一个ArrayList中去？"></a>（2） 如何复制某个ArrayList到另一个ArrayList中去？</h4><p>使用clone()方法<br>使用ArrayList构造方法<br>使用addAll方法</p><h4 id="（3）arraylist怎么保证线程安全？"><a href="#（3）arraylist怎么保证线程安全？" class="headerlink" title="（3）arraylist怎么保证线程安全？"></a>（3）arraylist怎么保证线程安全？</h4><p>&lt;1&gt;、使用Vector</p><p>&lt;2&gt;、使用Collections.synchronizedList()</p><p>&lt;3&gt;、使用CopyOnWriteArrayList，涉及线程安全的部分，是通过写时复制的方式来实现。它内部有个volatile数组来保持数据。在“添加/修改/删除”数据时，会先获取互斥锁，再新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给volatile数组，然后再释放互斥锁。</p><p>1.在做修改操作的时候加锁</p><p>2.每次修改都是将元素copy到一个新的数组中，并且将数组赋值到成员变量array中。</p><p>3.利用volatile关键字修饰成员变量array，这样就可以保证array的引用的可见性，每次修改之前都能够拿到最新的array引用。</p><p>迭代器的弱一致性:弱一致性是指返回迭代器后，其他线程对list的增删改对迭代器是不可见的。</p><h4 id="（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？"><a href="#（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？" class="headerlink" title="（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？"></a>（4）ArrayList频繁扩容导致添加性能急剧下降，如何处理？</h4><p>使用ArrayList时，可以使用有参构造方法根据业务实际指定集合大小，以减少扩容的次数，提高写入效率。</p><h4 id="（5）Java集合的快速失败机制-“fail-fast”和安全失败机制“fail-safe”？"><a href="#（5）Java集合的快速失败机制-“fail-fast”和安全失败机制“fail-safe”？" class="headerlink" title="（5）Java集合的快速失败机制 “fail-fast”和安全失败机制“fail-safe”？"></a>（5）Java集合的快速失败机制 “fail-fast”和安全失败机制“fail-safe”？</h4><p>“fail-fast”是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。</p><p>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>“fail-safe”采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有的集合内容，在拷贝的集合上进行遍历。</p><p>原理：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><h4 id="（6）扩容机制？"><a href="#（6）扩容机制？" class="headerlink" title="（6）扩容机制？"></a>（6）扩容机制？</h4><p>首先判断当前数组是不是空数组，如果是空数组，那么将数据由0扩容到需求长度minCapacity，此时有参构造生成的空数组扩容到1，无参构造扩容到10，因为在计算minCapacity时，如果是无参构造，取默认长度和需求长度 minCapacity 中比较大的值，返回10。如果是有参构造的空数组，minCapacity返回1。</p><p>如果不是空数组，创建一个长度为原来数组长度1.5倍的新数组，当新数组长度大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于Integer的最大值，也就是溢出为负数，那么抛出内存溢出异常。否则的话根据与MAX_ARRAY_SIZE的比较情况确定返回Integer的最大值还是MAX_ARRAY_SIZE。最后将旧数组的值用Arrays.copyOf（）方法拷贝到新数组。</p><h4 id="（6）Iterator-和-ListIterator-有什么区别？"><a href="#（6）Iterator-和-ListIterator-有什么区别？" class="headerlink" title="（6）Iterator 和 ListIterator 有什么区别？"></a>（6）Iterator 和 ListIterator 有什么区别？</h4><p>（1）Iterator可以在所有集合中使用，而ListIterator只能在List类型和其子类型中使用</p><p>（2）ListIterator和Iterator都有hasnext（）和next（）方法可以实现顺序向后遍历，但是ListIterator有hasPrevious（）方法和previous（）方法，可以实现逆向遍历，Iterator不可以。</p><p>（3）ListIterator有add（）方法，可以向List中添加对象，而Iterator不能。</p><p>（4）ListIterator可以定位当前索引的位置，next Index（）和previous Index（）可以实现，Iterator没用此功能。</p><p>（5）两个都可以实现删除操作，但是ListIterator可以实现对象的修改，set（）方法可以实现，Iterator不能修改。</p><h4 id="（7）迭代器Iterator是什么？"><a href="#（7）迭代器Iterator是什么？" class="headerlink" title="（7）迭代器Iterator是什么？"></a>（7）迭代器Iterator是什么？</h4><p>Iterator是可以遍历集合的对象，为各种容器提供了公共的操作接口，隔离对容器的遍历操作和底层实现（解耦）。</p><p>迭代器是java23种设计模式之一，用于顺序访问集合对象的元素，无需知道集合对象的底层实现。</p><h4 id="（8）Array和ArrayList的区别？"><a href="#（8）Array和ArrayList的区别？" class="headerlink" title="（8）Array和ArrayList的区别？"></a>（8）Array和ArrayList的区别？</h4><p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</p><p>Array大小是固定的，所以需要事前确定合适的空间大小。ArrayList的大小是动态变化的，在每次添加新的元素的时候都会检查内部数组空间是否足够。</p><p>ArrayList提供了更多的方法和特性，比如：all All（），removeAll（），iterator（）等。</p><p>对于基本数据类型，ArrayList使用自动装箱来减少编码工作量；而当处理固定大小的基本数据类型的时候，这种方式相对比较慢，这时候应该使用Array。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String,StringBuilder,StringBuffer</title>
      <link href="/2022/09/15/String,StringBuilder,StringBuffer/"/>
      <url>/2022/09/15/String,StringBuilder,StringBuffer/</url>
      
        <content type="html"><![CDATA[<p>区别：</p><a id="more"></a><p><strong>1，是否可变</strong></p><p>String对象创建后，一旦初始化就不能修改，因为String类中的所有数据都是常量。对String类的任何改变，都返回一个新的String类对象，效率低，浪费内存空间。</p><p>StringBuilder和StringBuffer的对象是可变的。</p><p>StringBuilder：是在Java5中被提出来的。StringBuilder是一个可变的字符序列，可以用append()方法进行对字符串的追加，insert()插入，StringBuilder的原理和StringBuffer一样，但是线程是不安全的。</p><p>StringBuffer：StringBuffer是使用缓冲区的，本身也是操作字符串，但与String类不同，String类中的内容一旦声明就无法改变，改变的只是其内存地址的指向。但是StringBuffer中的内存是可以改变的。append()追加方法，reverse()反转，replace()代替，delete()删除，insert()插入。</p><p><strong>2，构造</strong></p><p>String类是引用数据类型</p><p>StringBuilder和StringBuffer本身是一个具体的操作类，所以不能像String那样用直接赋值的方法进行对象实例化，必须要通过构造方法来完成。（为了获得更好性能，在构造StringBuilder和StringBuffer时要指定其容量，当不指定容量时会默认构造一个容量为16的对象）</p><p><strong>3，线程与速度</strong></p><p>StringBuilder在大多数实现中比StringBuffer快，将StringBuilder用于多个线程是不安全的（不能同步访问），但是在单个线程里StringBuilder比StringBuffer性能好。</p><p>StringBuffer线程是安全的。</p><p>StringBuilder相对于StringBuffer有速度优势，所以一般情况下推荐使用StringBuilder，但是在程序要求线程安全的情况下必须使用StringBuffer。</p><p>速度：StringBuilder&gt;StringBuffer&gt;String</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql引擎</title>
      <link href="/2022/09/15/mysql%E5%BC%95%E6%93%8E/"/>
      <url>/2022/09/15/mysql%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p><strong>常用的mysql引擎：MyISAM、InnoDB、Memory。</strong></p><a id="more"></a><p>MyISAM：MyISAM是mysql5.5之前的默认引擎。不支持事务，只支持表锁，不支持行锁。但是访问速度快。如果操作主要以读取和插入为主，修改和删除的操作很少，对数据的并发性和完整性要求并不是很强的情况下可以用该引擎，比如用户日志，评论等。</p><p>InnoDB：mysql5.5之后的默认引擎。支持事务和行锁，支持外键。是一种兼顾高可靠性和高性能的通用存储引擎。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，包含很多更新、删除操作，那么innodb是比较合适的选择。（B-Tree索引）</p><p>Memory：Memory是在内存中存储所有的数据。由于受到硬件的问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。（Hash索引）</p><p><strong>查看数据库是否支持引擎：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> ENGINES ;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/e8d45acb76514a03bab54c4cd9c9a334.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>suport：是否支持引擎（default是默认引擎）</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治法(算法)</title>
      <link href="/2022/09/08/%E5%88%86%E6%B2%BB%E6%B3%95(%E7%AE%97%E6%B3%95)/"/>
      <url>/2022/09/08/%E5%88%86%E6%B2%BB%E6%B3%95(%E7%AE%97%E6%B3%95)/</url>
      
        <content type="html"><![CDATA[<p>分治法是算法常用的解题方法之一，是将一个大的问题拆分为若干小的问题。二分法就是常用的分治法。</p><a id="more"></a><h2 id="可以采用分治法解决的一些问题："><a href="#可以采用分治法解决的一些问题：" class="headerlink" title="可以采用分治法解决的一些问题："></a>可以采用分治法解决的一些问题：</h2><p>1.二分查找</p><p>2.合并排序（归并排序）</p><p>3.快速排序</p><p>4.快速幂</p><p>5.汉诺塔</p><h2 id="一、二分查找"><a href="#一、二分查找" class="headerlink" title="一、二分查找"></a>一、二分查找</h2><p>二分查找对要查找的序列有两个要求：</p><p>​    一是该序列必须是有序的（即该序列中的所有元素都是按照大小关系排好序的，升序和降序都可以）</p><p>​    二是该序列必须是顺序存储的。</p><h4 id="例题：二分查找"><a href="#例题：二分查找" class="headerlink" title="例题：二分查找"></a>例题：<a href="https://leetcode.cn/problems/binary-search/">二分查找</a></h4><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1、先确定中间位置：</p><p>　　　　middle = (left+right)/2;</p><p>2、将待查找得值与nums[middle]的值相比较。若相等，则查找成功并返回该位置，否则须确定新确定查找区间，继续查找。</p><p>3、如果nums[middle] 的值大于待查找的值，则证明在nums[middle]~nums[right]中所有的值都大于待查找的值，令right=middle，在nums[left]到nums[middle]中查找。</p><p>4、当left&gt;right时，证明nums中没有要查找的值，跳出循环，返回-1。</p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> middle;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line"></span><br><span class="line">​      middle=(right+left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">if</span>(nums[middle]==target)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">return</span> middle;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target)</span><br><span class="line"></span><br><span class="line">​        right=middle-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">​        left=middle+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、合并排序（归并排序）"><a href="#二、合并排序（归并排序）" class="headerlink" title="二、合并排序（归并排序）"></a>二、合并排序（归并排序）</h2><p>归并排序是基于递归实现的，归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用。将数据分为a，b两组，再将a，b各自再分成两组，以此类推，当每一组都只有一个数据时，认为这个小小组已经达到了有序，再将相邻两个小小组依次合并。</p><h4 id="例题：排序数组"><a href="#例题：排序数组" class="headerlink" title="例题：排序数组"></a>例题：<a href="https://leetcode.cn/problems/sort-an-array/">排序数组</a></h4><p>给你一个整数数组 nums，请你将该数组升序排列。</p><p>示例 1：</p><p>输入：nums = [5,2,3,1]<br>输出：[1,2,3,5]</p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><img src="https://img-blog.csdnimg.cn/39e5969fb4db412eb1dbe851b285fe95.png" style="zoom:50%;" /><p>1、将数组进行拆分，利用递归的方法，将数组拆分成一个个单独的元素。</p><p>2、依次对数组进行合并，依次比较数组内的元素，将较小的元素先加入新的数组，依次往下比较，如果一个数组内的值已经全都加入新数组，将另一个数组的剩下的值依次加入新数组。</p><p>3、将额外的空间覆盖掉原来的空间。</p><h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] tmp; <span class="comment">//定义临时数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        tmp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>); <span class="comment">//进入递归</span></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//当l&gt;=r时，每个区间里面只有一个数值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) /<span class="number">2</span>;<span class="comment">//均分区间</span></span><br><span class="line">        mergeSort(nums, l, mid);<span class="comment">//对左侧区间进行划分</span></span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, r); <span class="comment">//对右侧区间进行划分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123; <span class="comment">//利用循环将较两个区间内较小值依次加入临时数组</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp[cnt++] = nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[cnt++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;<span class="comment">//将数组内剩下的元素依次加入</span></span><br><span class="line">            tmp[cnt++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">            tmp[cnt++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; r - l + <span class="number">1</span>; ++k) &#123;<span class="comment">//将临时数组内的值存入nums</span></span><br><span class="line">            nums[k + l] = tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、快速排序"><a href="#三、快速排序" class="headerlink" title="三、快速排序"></a>三、快速排序</h2><p>快速排序，基于冒泡排序移动换位思想——通过遍历，判断每个数并放置在数组合适的位置。快速排序可能是应用最广泛的排序算法，适用于各种不同的输入数据且在一般应用中比其他排序都要快的多。</p><p>排序方式：</p><p>1、选定一个值，一般是数值的第一个值</p><p>2、进行分区，将该值与数组后面的数据依次进行比较，将比它小的值都放在左边，比它大的值都放在右边。</p><p>3、采用递归的方法，对该值左右区间的数组依次再进行分区操作，直到每个区间只剩一个值。</p><h4 id="例题：最小的k个数"><a href="#例题：最小的k个数" class="headerlink" title="例题：最小的k个数"></a>例题：<a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数</a></h4><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p>示例 1：</p><p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]</p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>1、选取一个基数</p><p>2、设置i，j两个指针，分别从左右两边向中间进行查找，先使j移动，当遇到arr[j]小于基数时，移动i，当遇到arr[i]大于基数时，将arr[i]与arr[j]互换位置，保证比基数小的值在左边，比基数大的值在右边</p><p>3、当i&gt;=j的时候，跳出循环，将基数与i指针所在的位置交换数值</p><p>4、当i&gt;k时，证明最小的k个数在0~(i-1)之间，在该区间查找最小的k个数</p><p>5、当i&lt;k时，证明比基数大的一些数也是最小的k个数，在比基数大的值中间属于最小的k个数的值</p><p>6、当i==k时，返回最小的k个数</p><h4 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= arr.length) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">return</span> quickSort(arr, k, <span class="number">0</span>, arr.length - <span class="number">1</span>);<span class="comment">//进入排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//令arr[l]为基数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;<span class="comment">//当i&lt;j时，</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--; </span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, l); <span class="comment">//将基础值与arr[i]交换位置，保证在基础值左边的值均小于它，右边的值均大于它</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) <span class="keyword">return</span> quickSort(arr, k, l, i - <span class="number">1</span>); <span class="comment">//当i&gt;k时，证明最小的k个数在0~(i-1)之间,该区间的数进行排序</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) <span class="keyword">return</span> quickSort(arr, k, i + <span class="number">1</span>, r);<span class="comment">//当i&lt;k时，证明比基数大的一些数是最小的k个数，在比基数大的值中间属于最小的k个数的值</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(arr, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123; <span class="comment">//将arr[i]和arr[j]中的值进行交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、快速幂"><a href="#四、快速幂" class="headerlink" title="四、快速幂"></a>四、快速幂</h2><h4 id="例题：Pow-x-n"><a href="#例题：Pow-x-n" class="headerlink" title="例题：Pow(x, n)"></a>例题：<a href="https://leetcode.cn/problems/powx-n/">Pow(x, n)</a></h4><p>实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。</p><p>示例 1：</p><p>输入：x = 2.00000, n = 10<br>输出：1024.00000</p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><img src="https://img-blog.csdnimg.cn/f6cc78ebe5094c01b15242af9a169f64.png" style="zoom:67%;" /><p>1、声明数据类型为long的b，将n赋值给它</p><p>2、当b为负数时，先将b转化为正数运算，x=1/x,b=-b</p><p>3、将b除以2，如果余数为一，将res=res*x,x等于x的平方，因为最后结果永远等于x的b次幂乘res，当b=0时，最后结果等于1乘res，即res</p><h4 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;  <span class="comment">//1、声明数据类型为long的b，将n赋值给它</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;  <span class="comment">//当b为负数时，转化为正数的运算，x=1/x，b=-b</span></span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;<span class="comment">//3、将b除以2，如果余数为一，将res=res*x，因为最后结果永远等于x的b次幂乘res，当b=0时，最后结果等于1乘res，即res</span></span><br><span class="line">            <span class="keyword">if</span>((b % <span class="number">2</span>) == <span class="number">1</span>) </span><br><span class="line">                res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            b = b/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、汉诺塔"><a href="#五、汉诺塔" class="headerlink" title="五、汉诺塔"></a>五、汉诺塔</h2><h4 id="例题：汉诺塔问题"><a href="#例题：汉诺塔问题" class="headerlink" title="例题：汉诺塔问题"></a>例题：<a href="https://leetcode.cn/problems/hanota-lcci/">汉诺塔问题</a></h4><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p><p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p><p>你需要原地修改栈。</p><p>示例1:</p><p> 输入：A = [2, 1, 0], B = [], C = []<br> 输出：C = [2, 1, 0]</p><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>假设A柱有n个盘子</p><p><img src="https://img-blog.csdnimg.cn/13d9da4188f749ba8d8363da097cd8c1.png"></p><p>1、B柱与C柱替换，新的C柱就是B柱。</p><p>2、将A柱上的n-1个盘子移到新C柱上，实际上都移到了B柱上。</p><p>3、将B柱与C柱换回来。</p><p>4、将A柱上的最后一个盘子移到C柱上，这个盘子不用再移动，将它和C柱看成一个整体。</p><p>5、将B柱与A柱互换位置，B柱成为新的A柱。</p><p>6、将B柱看出A柱重复1~5步，直到盘子完全移到C上。</p><h4 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> A.size();</span><br><span class="line">        dac(num,A,B,C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//num为A盘剩下的盘子数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dac</span><span class="params">(<span class="type">int</span> num,List&lt;Integer&gt; A,List&lt;Integer&gt; B,List&lt;Integer&gt; C)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;<span class="comment">//当A盘只剩下一个盘子的时候，将最后一个盘子移动到C盘</span></span><br><span class="line">            C.add(A.remove(A.size() - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dac(num - <span class="number">1</span>,A,C,B); <span class="comment">//B柱与C柱替换，新的C柱就是B柱，将A柱上的n-1个盘子移到新C柱上，实际上都移到了B柱上。</span></span><br><span class="line">            C.add(A.remove(A.size() - <span class="number">1</span>));<span class="comment">//将A柱最后一个盘子移动到C柱上</span></span><br><span class="line">            dac(num - <span class="number">1</span>,B,A,C); <span class="comment">//将B柱与A柱互换位置，B柱成为新的A柱，将B柱上的所有盘子都移到C柱上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分治和递归：</strong></p><p><strong>递归和分治本身就不是同一种东西，递归是敲代码的技巧之一，分治是算法的思想之一，两者没关系。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对称的二叉树（算法题）</title>
      <link href="/2022/08/06/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%89/"/>
      <url>/2022/08/06/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>问题：</strong>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><a id="more"></a><p><strong>例如：</strong>二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p>    1<br>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><p>    1<br>   / \<br>  2   2<br>   \   \<br>   3    3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> n=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>||(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>||root.right==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        hui(root.left,root.right); <span class="comment">//进入递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hui</span><span class="params">(TreeNode root,TreeNode tree)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.n==<span class="literal">false</span>)  <span class="comment">//当n为false时，二叉树已经不对称，不在进行下面的判断</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>&amp;&amp;tree==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>||tree==<span class="literal">null</span>)&#123; <span class="comment">//tree和root一个为空时，二叉树不对称</span></span><br><span class="line">            <span class="built_in">this</span>.n=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val!=tree.val)&#123; </span><br><span class="line">            <span class="built_in">this</span>.n=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hui(root.left,tree.right);</span><br><span class="line">        hui(tree.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析：</strong>这个问题采用递归的方法，从最上方的根节点向下依次判断，将左节点看做root，右节点看成tree，每次root左移时，tree右移，保证root和tree一直处于对称的位置。判断root和tree是否相等，若不相等，则证明该二叉树是不对称的。如果tree和root有一项为空而另一项不为空，则该二叉树也是不对称的。</p><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/solution/dui-cheng-de-er-cha-shu-by-leetcode-solu-rgks/" title="对称的二叉树 - 对称的二叉树 - 力扣（LeetCode）">对称的二叉树 - 对称的二叉树 - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重建二叉树（算法题）</title>
      <link href="/2022/07/23/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%89/"/>
      <url>/2022/07/23/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>        输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>        假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><a id="more"></a><p><strong>示例：</strong></p><p><img src="https://img-blog.csdnimg.cn/f943c4611c1e4803ac87b455a1b187ef.png"></p><p>        Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>        Output: [3,9,20,null,null,15,7]</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; in=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder=preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            in.put(inorder[i],i);  <span class="comment">//方便获取根节点在中序遍历的坐标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hui(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode <span class="title function_">hui</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123; <span class="comment">//递归方法</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) <span class="comment">//递归结束的条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        TreeNode node=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[root]);  <span class="comment">//创建节点</span></span><br><span class="line">        <span class="type">int</span> index=in.get(preorder[root]); <span class="comment">//获取根节点坐标</span></span><br><span class="line">        node.left=hui(root+<span class="number">1</span>,left,index-<span class="number">1</span>); <span class="comment">//获取左子树</span></span><br><span class="line">        node.right=hui(root+index-left+<span class="number">1</span>,index+<span class="number">1</span>,right); </span><br><span class="line">        <span class="comment">//root+index-left+1为当前节点+左子树个数+1</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 总结：**</p><p>        前序遍历时先是根节点，然后是左子树，右子树。</p><p>        中序遍历先是左子树，然后是根节点，最后是右子树。 <img src="https://img-blog.csdnimg.cn/6b5088b985e8419b9dace85aa9e8b803.png"></p><p>        前序遍历第一个数是二叉树最上面的根节点，遍历inorder，找到根节点的位置。根节点左边是左子树的中序遍历结果，右边是右子树的遍历结果。先找左子树，在左子树的遍历结果里最上面的一个根节点就是前序遍历的第二个数，以此类推，采用递归的方式解决问题。</p><p>        这是第一次接触到有关树的算法题，开始的时候题目都没有怎么看懂，后来看题解还是有好多地方感觉有点疑问。后来花费了好多时间才把这道题理解个差不多，记录一下，希望后来再遇到这种类型的题目时我可以自己写出来。</p><p>题目链接：<a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof">https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-plus常用方法</title>
      <link href="/2022/07/02/Mybatis-plus%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/02/Mybatis-plus%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>mybatis-plus</p><a id="more"></a><h3 id="增加："><a href="#增加：" class="headerlink" title="增加："></a>增加：</h3><p>**int insert(entity)**：插入单条数据，返回值为int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.insert(user);</span><br></pre></td></tr></table></figure><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><p><strong>int deleteById( id)：</strong>通过id进行删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.deleteById(userId);</span><br></pre></td></tr></table></figure><p>**int deleteBatchIds(Collection&lt;? extends Serializable&gt; idList)**：通过id删除多个表的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userMapper.deleteBatchIds(Arrays.asList(id));</span><br><span class="line">//Integer[] id</span><br></pre></td></tr></table></figure><h3 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h3><p><strong>updateById<code>(</code>entity<code>)</code>：</strong>通过id更新表的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.updateById(user);</span><br></pre></td></tr></table></figure><p>查询：</p><p><strong>T selectById（entity）：</strong>根据主键id查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user=userMapper.selectById(userId);</span><br></pre></td></tr></table></figure><p>**T selectOne(Wrapper&lt;T&gt; queryWrapper)**： 根据实体类封装对象 查询一条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;user_account&quot;</span>, userAccount);</span><br><span class="line">userMapper.selectOne(queryWrapper);</span><br></pre></td></tr></table></figure><p><strong>List&lt;T&gt; selectList(Wrapper&lt;T&gt; queryWrapper)：</strong> 查询多条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;user_authority&quot;</span>,<span class="number">0</span>);</span><br><span class="line">userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure><p><strong>selectPage（page，queryWrapper）：</strong>查询多条记录结果分页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IPage page=<span class="keyword">new</span> <span class="title class_">Page</span>(currentPage,pageSize);</span><br><span class="line">userMapper.selectPage(page, queryWrapper);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化</title>
      <link href="/2022/06/25/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2022/06/25/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis提供了两种持久化方式：RDB，AOF"><a href="#Redis提供了两种持久化方式：RDB，AOF" class="headerlink" title="Redis提供了两种持久化方式：RDB，AOF"></a>Redis提供了两种持久化方式：RDB，AOF</h2><a id="more"></a><h3 id="RDB："><a href="#RDB：" class="headerlink" title="RDB："></a>RDB：</h3><p>        RDB是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。</p><p>        通过保存数据库中的键值对来记录数据库的状态。</p><p>        RDB 有两种触发方式，分别是自动触发和手动触发。</p><p><strong>优点：</strong></p><p>        （1）节省磁盘空间，生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p><p>        （2）恢复速度快。</p><p>        （3）适合大规模的数据恢复。</p><p><strong>缺点：</strong></p><p>        （1）因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，fork时，内存中数据被复制了一份，大致两倍的膨胀性需要考虑</p><p>        （2）最后一次持久化之后的数据可能会丢失</p><h3 id="AOF："><a href="#AOF：" class="headerlink" title="AOF："></a><strong>AOF：</strong></h3><p>        AOF 被称为追加模式，或日志模式，是 Redis 提供的另一种持久化策略，它能够存储 Redis 服务器已经执行过的的命令，并且只记录对内存有过修改的命令，这种数据记录方法，被叫做“增量复制”，其默认存储文件为<code>appendonly.aof。</code></p><p>        通过保存Redis服务器所执行的写命令来记录数据库状态。</p><p><strong>优点：</strong></p><p>        （1）丢失数据概率低。AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失 1 秒的数据而已。</p><p>        （2）AOF 文件使用 Redis 命令追加的形式来构造，因此，即使 Redis 只能向 AOF 文件写入命令的片断，使用 redis-check-aof 工具也很容易修正 AOF 文件。</p><p><strong>缺点：</strong></p><p>        （1）比RDB占用更多磁盘空间。</p><p>        （2）恢复备份速度慢</p><p>        （3）每次读写都同步的话，有一定的性能压力。</p><p>        （4）RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 方式更健壮。官方文档也指出，AOF 的确也存在一些 BUG，这些 BUG 在 RDB 没有存在。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于redis的学习</title>
      <link href="/2022/06/18/%E5%85%B3%E4%BA%8Eredis%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/18/%E5%85%B3%E4%BA%8Eredis%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>        这段学习计划主要是学习redis，因为学习计划才开始的几天有专业课考试，平时我专业课总是划水，学的实在太差劲了，所以我把重心放到了专业课的复习上面，虽然复习之后考的也不太好，但是复习总比不复习好。后来又加上一系列事情，导致这一阶段的学习进度有点慢了。最近也是注意到了这个问题，正在慢慢补救。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/7795c0d5c7494ce9afeec7fea0b04ddf.jpeg"></p><p>        感觉每次在接触一个新的软件的时候我总会遇到各种各样的问题，这次也不例外，最开始安装软件遇到了好多问题，不知道该如何下手。后来在网上找了好多教程，才把软件安装好。后来在操作的时候也不知道我不小心弄错什么了，就一直报错Could not connect to Redis at 127.0.0.1:6379: Connection refused。我上网搜索原因，但是当时试了好多方法都不行，后来才发现是我不小心把防火墙开放6379端口的那个给删了，后来把端口重新开放，然后重新启动了服务端才好。感觉学习真的是一件不断遇到问题，然后解决问题的过程，至少对于我是这样子的。比起去问别人，确实自己一点点搜索记忆会更加深刻一些，进步会更大一些。</p><p>        对于下星期的规划嘛，就是继续学习Redis。现在我在看视频学习，我准备把进度赶赶，如果可以在学习计划结束之前看完视频的话就去做一些练习什么的来巩固一下，把这一段时间学习的东西学扎实。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于PS的学习</title>
      <link href="/2022/06/11/%E5%85%B3%E4%BA%8EPS%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/11/%E5%85%B3%E4%BA%8EPS%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>        因为一些原因，这学期提前放假了，所以这是在暑假学习的第一周。很明显，在假期的时候我的学习状态比不上在学校的时候，但是和在寒假的时候相比，我现在的学习状态还是比较好的。</p><a id="more"></a><p>        这一段时间我们在学习ps，可能是以前我有时候会在手机上绘画，然后对于图层什么的接触的比较多，因此我对于ps一些工具的学习还是比较快的。这一阶段我没有去跟着视频去学习，而是通过做练习去了解和掌握一些工具的运用。在学习计划开始的前两天我就开始去做PS的练习案例，在做练习的时候遇到的最大的问题就是调色，后来还是结合了学长学姐发的材料里面的那个psd文件去调的颜色。还有就是锐化，在锐化后图案的颜色就变得比较亮，开始的时候我没有用到锐化，到最后才用，导致原本调好的颜色变得很奇怪，但是最后做出来的成品我还是比较满意的。</p><p>        因为提前放假，有些专业课我们还没有进行考试，java和电子技术的考试就安排到了10号和13号，所以我提前把ps练习案例交给了学姐，然后把剩下的时间放到了考试上，因为在学校我专业课学的并不是很好，特别是电子技术，很多知识我都没有掌握，所以我就把大部分的时间放到这门学科的复习上了。</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
            <tag> Ps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关Springboot的学习</title>
      <link href="/2022/05/14/%E6%9C%89%E5%85%B3Springboot%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/14/%E6%9C%89%E5%85%B3Springboot%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>        由于疫情原因，这一周的学习是在宿舍中进行的。说实话我的自制力不是很高，所以这一星期的学习进度有点慢。</p><a id="more"></a><p>        在上一阶段我们写项目的时候使用的是ssm框架，这一阶段我们要把ssm框架换成SpringBoot框架。SpringBoot提供了全新的框架。在学习ssm的时候我最头疼的事情就是配置文件了，一不小心配置就会出问题。在学习了SpringBoot之后就再也没有这个烦恼了，同时也不用导入很多很多的依赖。相比之下，SpringBoot真的是比ssm简单很多，但是SpringBoot的集成度高，不容易了解它的底层。</p><p><strong>SpringBoot的优点：</strong></p><p>简化的Maven配置：Spring提供推荐的基础 POM 文件来简化Maven 配置。</p><p>自动配置Spring：Spring Boot会根据项目依赖来自动配置Spring 框架，极大地减少项目要使用的配置。</p><p>无代码生成和<a href="https://so.csdn.net/so/search?q=xml&spm=1001.2101.3001.7020" title="xml">xml</a>配置：Spring Boot不生成代码。完全不需要任何xml配置即可实现Spring的所有配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 整合mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>** yaml**</p><p>      在学习SpringBoot的过程中还学习了yaml文件：在SpringBoot<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020" title="框架">框架</a>中，resource文件夹里可以存放配置的文件有两种：properties和yml（yaml）。</p><p>        优先级：properties&gt;yml</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目考核总结</title>
      <link href="/2022/05/09/%E9%A1%B9%E7%9B%AE%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/09/%E9%A1%B9%E7%9B%AE%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>        历时一个月，我们这个项目也进入了尾声。在昨天，所有的组都完成了考核。</p><a id="more"></a><p>        和最开始的信心满满不同，在项目结束的时候，我整个人都是很颓废的。我们组的项目整体上表现得很差劲，无论是前端还是后端，在考核的时候表现的都不尽人意，这也和我这个组长有很大关联。在写项目的时候，由于我是学后端的，就没有太多地去关注前端的进度，以至于到最后交项目的时候前端的页面还没有全部连在一起。在提交仓库的最后一段时间，我们组才把播放音乐的页面连接起来，这也导致考核的时候出现了很多问题。后端的问题主要是出在代码规范上，也是因为在写项目的时候我没有过多地去关注这一点，只是一味地去赶进度。</p><p>        说实话，在考核的时候前后端之间的矛盾真的不少。特别是在最后一段时间，可能是因为我的脾气不是特别好，在最后的时候和前端的矛盾逐渐变大。我感觉我们组现在真的存在一个很严重的问题，就是无论是什么样的问题，第一时间就去找后端。就比如最后提交项目之后我们播放mv的页面出了问题，一打开那个页面CPU直接飙到40%，导致页面卡死。当时找不到原因，就有前端的孩子说是因为我录数据的原因。我听完真的是很生气，我们组里面没有人录数据，我熬到半夜两点多去录的数据，结果出问题了，就说是我的原因。然后那天中午我就把录得mv数据全删掉了，页面打开还是卡死，后来找了学长帮忙解决，才发现是前端写了一个死循环。还有点赞歌单的接口，我很明确地问过前端我传的值她可不可以交互上，她说可以。但是在考核的时候页面点赞出了问题，他们又说是我传的值有问题，可是前一天我很明确很明确地问过这个问题，说如果交互不上我就把那个接口改一下。害，我感觉这个问题真的是，很严重。项目是前后端共同的项目，为什么有bug就觉得是我们后端的原因呢？</p><p>        这个项目好像还要继续写下去，我前一阶段并没有很好地担起组长这个责任，这点我最近反思了很多。我觉得一个项目组的成员要多沟通，对于我们组存在的一些问题，我也应该多和他们沟通一下，一起商量着解决。希望继续写项目的话，我们可以一起去把上一阶段存在的问题改正吧。写项目本来就是一个遇到问题解决问题的过程，希望在最后结束的时候，我们每个人都可以收获很多。</p><p><img src="https://img-blog.csdnimg.cn/0268339c718b48bdbf723d5f82682be5.png"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于下载音乐的问题</title>
      <link href="/2022/04/30/%E5%85%B3%E4%BA%8E%E4%B8%8B%E8%BD%BD%E9%9F%B3%E4%B9%90%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/30/%E5%85%B3%E4%BA%8E%E4%B8%8B%E8%BD%BD%E9%9F%B3%E4%B9%90%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>        这周写项目遇到了一个问题——怎么通过url下载音乐文件。</p><a id="more"></a><p>        因为之前写下载文件都是通过文件路径去下载的，而这一次我们用到了云存储，在数据库里面存的是url地址，所以我就不知道应该怎么去下载了。后来我在网上找到了通过url来下载文件的方法，但是又遇到了一个问题，就是我是从数据库获取的url，里面有中文会报错，这个问题困扰了我好长时间。</p><p>        我在网上查找解决中文乱码的办法的时候，知道了URLEncoder.encode（）可以使用指定的编码机制将字符串转换为 application/x-www-form-urlencoded 格式 ，从而解决中文乱码。但是我在使用了URLEncoder.encode（）之后，发现接口报错HTTP response code: 400 for URL，显示发送了异常请求，后来才发现并不能将url全部进行转化，否者会把HTTP:// 中的斜线也<a href="https://so.csdn.net/so/search?q=%E8%BD%AC%E4%B9%89&spm=1001.2101.3001.7020" title="转义">转义</a>，导致请求出现协议异常等问题。</p><p>        后来由于我找不到更好的办法对url中的中文进行处理，就将url分割成了几部分，然后对含有中文的那一部分进行转化。虽然方法有点笨，但是总算是解决了问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">download</span><span class="params">(Integer musicId,  HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Map map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Music</span> <span class="variable">music</span> <span class="operator">=</span>musicService.queryById(musicId);</span><br><span class="line">        String musicName=music.getMusicName();</span><br><span class="line">        String musicPath=music.getMusicPath();</span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        String[] str=musicPath.split(<span class="string">&quot;/&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        String[] s=str[<span class="number">3</span>].split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> musicPath;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">            <span class="comment">// 取得文件的后缀名。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">ext</span> <span class="operator">=</span> path.substring(path.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>).toLowerCase();</span><br><span class="line">            <span class="comment">//文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pdfName</span> <span class="operator">=</span> musicName+<span class="string">&quot;.&quot;</span>+ext;</span><br><span class="line">            <span class="comment">// 获取外部文件流</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(str[<span class="number">0</span>]+<span class="string">&quot;//&quot;</span>+str[<span class="number">2</span>]+<span class="string">&quot;/&quot;</span>+URLEncoder.encode(s[<span class="number">0</span>], <span class="string">&quot;UTF-8&quot;</span>)+<span class="string">&quot;.&quot;</span>+s[<span class="number">1</span>]);</span><br><span class="line">            map.put(<span class="string">&quot;2&quot;</span>,url);</span><br><span class="line">            <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">            conn.setConnectTimeout(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//防止屏蔽程序抓取而返回403错误</span></span><br><span class="line">            conn.setRequestProperty(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;</span>);</span><br><span class="line">            inputStream = conn.getInputStream();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 输出文件到浏览器</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 输出 下载的响应头，如果下载的文件是中文名，文件名需要经过url编码</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/x-download&quot;</span>);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + URLEncoder.encode(pdfName, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">            out = response.getOutputStream();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐项目总结（三）</title>
      <link href="/2022/04/23/%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/04/23/%E9%9F%B3%E4%B9%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>        这一段时间的状态感觉比上周的状态好点了，我也慢慢写了一些接口，虽然进度还不是很快，但很明显有了进步。</p><a id="more"></a><p>        在写项目的时候我们组遇到了好多好多bug，遇到最多次的就是更新仓库的时候出的bug，应该是terget文件和仓库里面的target文件冲突了，我们遇到这个问题的时候都是吧target文件删掉，然后就可以更新了。还有还有就是前端的一些bug，我们组前端的同学给我说他们的代码变了，但是用tomcat运行起来页面却没有变化，当时挺懵逼的，然后就上网查嘛，才发现是浏览器缓存的问题，把缓存清理之后就解决了。这周真的是遇到了好多奇葩的bug啊~</p><p>        这周在写搜索的接口的时候我最开始的想法是输入任何一个字符就可以搜索出来，就像输入“周伦”就可以搜索出来“周杰伦”。但是后来在写动态sql的时候一直搜索不出来，可能是方法有些错误吧。因为前端催接口催的比较急，我就把搜索改的简单一点了，改成了下面的样式。不过我想在后来接口写得差不多的时候回头研究一下这个问题，找一下自己开始的时候在哪出错了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;search&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;project.pojo.Music&quot;</span> &gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;musicPojo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> where</span><br><span class="line">            concat(a.music_name,b.singer_name)</span><br><span class="line">            like &#x27;%$&#123;search&#125;%&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>        上一次写项目的时候我没有用到多对多查询，前一段时间学了一下，网上说可以建一个中间表，用联合主键。</p><p><img src="https://img-blog.csdnimg.cn/a51f7f6e04f245f49e27e0054b05eb75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p> </p><p>        我们组差不多是上周末才开始交互，交互的时候前后端真的是需要好好沟通&gt;_&lt;，发现bug的话可以自己先上网搜索一下，不要一发现bug就去找人帮忙改，要学会自己去解决问题。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目总结(二)</title>
      <link href="/2022/04/17/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
      <url>/2022/04/17/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p>项目总结</p><a id="more"></a><p><strong>学习上：</strong></p><p>        这周是我们写项目的第二周。可能是因为我们两个后端的时间太紧，加上学东西有点慢，我们组后端的进度和其他组比起来是比较慢的，以后需要慢慢加油了。</p><p>        到目前为止，我们项目组还没有进行前后端的交互，原本计划的是今天交互，但是计划赶不上变化，今天课程太多了，就没有交互上。这是我们大一前后端第一次一起写项目，对于前后端怎么交互我们也不是很懂，今天晚上才把交互的细节商量好，明天应该就可以进行交互了。通过这几天写项目我感觉到交流沟通真的非常重要，因为每个人写得代码都不一样，学的东西有时候也有一些不同。就像我们组后端，虽然就两个人，但是我们也出现了一些问题，写sql语句的时候我们两个写在了不同的地方。所以在写项目的时候要多交流沟通，这样就不会到最后了才发现代码写得不一样。</p><p>        经过将近两周的时间，我感觉我们不仅仅是在写项目，也是在不断地学习。因为在写项目的时候我们会遇到很多很多地方需要我们去学习新的知识，就比如我们以前在写controller的时候，总是返回一个视图，但是这次写项目的时候我们发现不能跳转视图，所以我们学习了如何就返回了json数据，还有对于服务器的操作，对于测试文档的操作，这些都需要我们不断地去学习。</p><p><strong>生活上：</strong></p><p>这周也没有发生什么大事，就是这周团支部风采大赛的排练和我们部画展报，还有催各种各样的材料，这些事情让我感觉时间太紧了，每天都要请假，呆在小组的时间少之又少。一个项目我们后端是两个人在做，因为我天天事情太多了，所以配置服务器什么的很多事情都是我们组另一个后端的同学做的，所以感觉挺不好意思的，下周我尽量多卷卷吧，不能拉他们后腿喽。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始项目总结（一）</title>
      <link href="/2022/04/10/%E5%88%9D%E5%A7%8B%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/10/%E5%88%9D%E5%A7%8B%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>第一次写项目</p><a id="more"></a><p><strong>学习上：</strong></p><p>        这周我们开始前后端交互写项目了。项目开始的时候我一直在整合ssm框架，但一直整合不好，浪费了好多时间，项目的进度太慢了。我们这次做的项目也是音乐网站，可能是因为上一次做过类似的项目，所以对于要实现的功能什么的我都有一点点了解，在开始写得时候也有了大致的构思，这也是比较好的一点吧。现在进度还是有点慢的，项目开始几天了，我才把数据库建好，然后我想在项目里面多用一点动态sql语句，但是对于这一方面我掌握的有点差劲，可能要抽时间去补一下了。</p><p>        经过这周和后端其他人的交流，我也发现了自己做的不够好的地方，有一点就是每次学习新东西的时候学的时间太长了，可能是我有时候理解能力比较差劲吧。还有就是对于软件的安装配置什么的，这方面我做的也不好。希望以后可以有所进步吧。</p><p>        这周参加了蓝桥杯比赛。通过这次比赛，我意识到了我的算法学的还是很差，就是才学到一些入门级的东西，还有好多好多知识我还没有接触到。还有就是我在比赛的时候犯了好大一个错误。我在eclipse上写代码的时候类名没有用Main，结果在最后复制代码的时候因为马虎忘记把类名改成Main了，所以我可能只有一道题的类名是正确的，这真的是致命性错误。虽然我才写了三道编程题，但是有的题琢磨了好久终于写出来了，结果却败在没有改类名上。嗯，多少是有点难受的，但是也没有办法了，只能明年注意了。</p><p><strong>生活上：</strong></p><p>        最近遇到了好多问题啊，首先就是篮球训练提前到早上了，这就意味着每天早上我要五点多起。以前写项目的时候我进度也总是太慢，所以有时候就会熬夜去补进度。但是现在每天早上五点多起床，每次一熬夜早上上课就会困得睁不开眼。还有就是有时候心情会很丧，也不知道怎么回事。哎，只能慢慢去调整了。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于算法学习</title>
      <link href="/2022/04/02/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/04/02/%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>        这周我们主要学习了算法。我一直感觉我的算法挺差劲的，所以在假期一直在按照组长的要求写算法，虽然进步了一点点，但是通过这周的学习我还是清楚地意识到了我的算法真的很差。</p><a id="more"></a><p>        超出数据范围是我在这周的学习过程中遇到的比较多的一个问题。有一次写算法的时候我用了long型还是超出数据范围，那个时候我才知道了大数字BigIntegger，当数据很大的时候，用大数就可以解决问题，但是大数的加减乘除和Int型的不太一样：</p><p>        <strong>最常用的构造方法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi = new BigInteger(&quot;5&quot;)；</span><br></pre></td></tr></table></figure><table border="1"><caption>&nbsp; <strong>BigInteger类的常用运算方法</strong></caption><tbody><tr><th>方法名称</th><th>说明</th></tr><tr><td>add(BigInteger val)</td><td>做加法运算</td></tr><tr><td>subtract(BigInteger val)</td><td>做减法运算</td></tr><tr><td>multiply(BigInteger val)</td><td>做乘法运算</td></tr><tr><td>divide(BigInteger val)</td><td>做除法运算</td></tr><tr><td>remainder(BigInteger val)</td><td>做取余数运算</td></tr><tr><td>divideAndRemainder(BigInteger val)</td><td>做除法运算，返回数组的第一个值为商，第二个值为余数</td></tr><tr><td>pow(int exponent)</td><td>做参数的 exponent 次方运算</td></tr><tr><td>negate()</td><td>取相反数</td></tr><tr><td>shiftLeft(int n)</td><td>将数字左移 n 位，如果 n 为负数，则做右移操作</td></tr><tr><td>shiftRight(int n)</td><td>将数字右移 n 位，如果 n 为负数，则做左移操作</td></tr><tr><td>and(BigInteger val)</td><td>做与运算</td></tr><tr><td>or(BigInteger val)</td><td>做或运算</td></tr><tr><td>compareTo(BigInteger val)</td><td>做数字的比较运算</td></tr><tr><td>equals(Object obj)</td><td>当参数 obj 是 Biglnteger 类型的数字并且数值相等时返回 true,&nbsp;其他返回 false</td></tr><tr><td>min(BigInteger val)</td><td>返回较小的数值</td></tr><tr><td>max(BigInteger val)</td><td>返回较大的数值</td></tr></tbody></table><p>         除了超出数据范围之外还有超出时间限制。超出时间限制主要是因为我的代码运行起来太麻烦。我想了想，应该是我写的题太少了，掌握的解题方法什么的都不是很多，当遇到一个算法题的时候我第一时间想到的方法往往都很麻烦，所以我觉得我以后还是要多刷一点题，看一些题解，多学习一些解题方法。</p><p>        还有就是对于链表我掌握的不多，这几天的任务中布置有关于链表的题，最近要加油补一下关于链表的知识点了。</p><p>        总之就是好好加油吧，多刷点题，遇到不会的题研究一下题解，学习一下别人的解题思路，努力提升自己，加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2022/03/26/SpringMVC/"/>
      <url>/2022/03/26/SpringMVC/</url>
      
        <content type="html"><![CDATA[<p>        在第四阶段学习过程中我的进度有点慢，学习任务结束的时候我还在整合ssm，主要是前面学习的时候没有怎么注意时间，再加上课有点多，进度就跟不上了。</p><a id="more"></a><p>记录一下这个星期学习的关于SpringMVC的一些知识：</p><p><strong>1.SpringMVC</strong></p><p>M：即model模型是指模型表示业务规则。Model：Bean，Dao，Service等</p><p>V：即View视图是指用户看到并与之交互的界面。View：Html，jsp等</p><p>C：即controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。Controller</p><p><strong>2.工作流程(理解原理)</strong></p><p>（1）web.xml</p><p>Dispatcher：这是SpringMVC的核心 请求分发器 前端控制器</p><p>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;:启动级别：1和服务器一起启动</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  **配置Dispatcher**  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  Dispatcher要绑定Spring的配置文件  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  /只匹配所有请求，不匹配jsp页面</span></span><br><span class="line"><span class="comment">      /*匹配所有的请求，包括jsp页面</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（2）springmvc-servlet </span><br><span class="line"></span><br><span class="line">处理映射器和处理适配器可以不配置，这里是为了更好的理解  </span><br><span class="line">\&lt;mvc:annotation-driven/&gt; ：  </span><br><span class="line">支持mvc注解驱动：  </span><br><span class="line">                        在spring中一般采用\@RequestMapping注解来完成映射关系， 必须向上下文中注册DefaultAnnotationHandlerMapping和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理，而annotation-driven配置帮助我们自动完成上述两个实例的注入 。</span><br><span class="line"></span><br><span class="line">```XML</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">  https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  处理器映射器  --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;</span><br><span class="line">&lt;!--  处理适配器  --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  视图解析器 :模板引擎Thymeleaf Freemarker --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;/hello&quot; class=&quot;nice.controller.HelloController&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>（3）HelloController.java </p><p>平时使用@Controller注解，这里继承Controller类是为了更好地理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nice.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="comment">//业务代码</span></span><br><span class="line">        String result=<span class="string">&quot;HelloSpringMVC&quot;</span>;</span><br><span class="line">        mv.addObject(<span class="string">&quot;msg&quot;</span>,result);</span><br><span class="line">        <span class="comment">//视图跳转</span></span><br><span class="line">        mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于Maven的一个网站:</p><p>        <a href="https://mvnrepository.com/" title="Maven Repository: Search/Browse/Explore (mvnrepository.com)">Maven Repository: Search/Browse/Explore (mvnrepository.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四阶段学习总结</title>
      <link href="/2022/03/18/%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/18/%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="这周学习的关于AOP的知识点总结："><a href="#这周学习的关于AOP的知识点总结：" class="headerlink" title="这周学习的关于AOP的知识点总结："></a>这周学习的关于AOP的知识点总结：</h1><a id="more"></a><h3 id="1-AOP概念（Aspect-Oriented-Programming）"><a href="#1-AOP概念（Aspect-Oriented-Programming）" class="headerlink" title="1.AOP概念（Aspect Oriented Programming）"></a><strong>1.AOP概念</strong>（Aspect Oriented Programming）</h3><p>        （1）面向切面编程（面向方面编程），利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑的各部分之间的耦合度降低，提高程序的可重性，同时提高了开发的效率。</p><p>        （2）不通过修改源代码，在主干功能里面添加新功能。</p><h3 id="2-AOP底层原理"><a href="#2-AOP底层原理" class="headerlink" title="2.AOP底层原理"></a><strong>2.AOP底层原理</strong></h3><p>        （1） AOP底层使用动态代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;1&gt;有两种情况动态代理</span><br><span class="line"></span><br><span class="line"> 第一种有接口，使用JDK动态代理（创建接口实现类的代理对象，增强类的方法）</span><br><span class="line"></span><br><span class="line"> 第二种没有接口，使用CGLIB动态代理（创建当前子类的代理对象，增强类的方法）</span><br></pre></td></tr></table></figure><h3 id="3-AOP-JDK动态代理"><a href="#3-AOP-JDK动态代理" class="headerlink" title="3.AOP(JDK动态代理)"></a><strong>3.AOP(JDK动态代理)</strong></h3><p>        （1）使用JDK动态代理，使用Proxy类里面的方法创建动态对象</p><p><img src="https://img-blog.csdnimg.cn/9b1c9ef07b6a4269acd5463c6897b41a.png"></p><p>        调用newProxyInstance方法</p><p><img src="https://img-blog.csdnimg.cn/d2055f57f9df432f95243e90bb408a19.png"></p><p>方法有三个参数：</p><p>        （类加载器）</p><p>        （增强方法所在的类，这个类实现的接口，支持多个接口）</p><p>        （实现这个接口InvocationHandler，创建代理对象，写增强方法）</p><p>（2）编写JDK动态代理代码</p><p>        （创建接口，定义方法）</p><p>        （创建接口实现类，实现方法）</p><p>        （使用Proxy类创建接口代理对象）</p><h3 id="4-通知（增强）：实际增强的逻辑部分就叫通知（增强）"><a href="#4-通知（增强）：实际增强的逻辑部分就叫通知（增强）" class="headerlink" title="4.通知（增强）：实际增强的逻辑部分就叫通知（增强）"></a>4.通知（增强）：实际增强的逻辑部分就叫通知（增强）</h3><p>        （前置通知）（@Before）</p><p>        （后置通知）（@AfterReturning)</p><p>        （环绕通知）（@Around）</p><p>        （异常通知）（@AfterThrowing）</p><p>        （最终通知）finally（@After）</p><h3 id="5-AOP操作（准备）"><a href="#5-AOP操作（准备）" class="headerlink" title="5.AOP操作（准备）"></a><strong>5.AOP操作（准备）</strong></h3><p>（1）在Spring框架中一般都是基于AspectJ实现AOP操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AspectJ不是Spring组成部分，独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作。</span><br></pre></td></tr></table></figure><p>（2）基于AspectJ实现AOP操作</p><p>        （基于xml配置文件实现）</p><p>        （基于注解方式实现）</p><p>（3）在项目工程中引入AOP相关依赖</p><p><img src="https://img-blog.csdnimg.cn/d919d07110f94d39b3f55bd889044f77.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_19,color_FFFFFF,t_70,g_se,x_16"></p><p>· </p><p>（4）切入点表达式</p><p>        （语法结构）</p><p>        execution （[权限修饰符] [返回类型] [类全路径] [方法名称] ([参数列表])）</p><h3 id="6-AOP操作（AspectJ注解）"><a href="#6-AOP操作（AspectJ注解）" class="headerlink" title="6.AOP操作（AspectJ注解）"></a><strong>6.AOP操作（AspectJ注解）</strong></h3><p>（1）创建类，在类里面定义方法</p><p>（2）创建增强类</p><p>           在增强类里面创建方法，不同的方法代表不同的类型通知</p><p>（3）进行通知的配置</p><p>           （在Spring配置文件中开启注解扫描）</p><p>          （使用注解创建User和UserProxy对象）<br>​<br>          （在增强类上面添加注解@Aspect）<br>​<br>            (在Spring配置中开启生成代理对象)</p><p><img src="https://img-blog.csdnimg.cn/625f75ec77404b1d95d8d6c98bb5802f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>（4）配置不同类型的通知</p><p>         在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</p><p><img src="https://img-blog.csdnimg.cn/bea6447bd0f04d42bd202536c2f05a47.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>（5）相同切入点抽取</p><p><img src="https://img-blog.csdnimg.cn/6a16b5caa35146d89d7097d986fa4b6e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>（6）设置增强类的优先级</p><p>        （在增强类的上面添加注解@Order（数字类型值），数字越小，优先级越高）</p><p><strong>两个可以找jar包和依赖的网站：</strong><br><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p><p><a href="https://developer.aliyun.com/mvn/search" title="仓库服务">仓库服务</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐网站考核总结（二）</title>
      <link href="/2022/03/13/%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/03/13/%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="学习上："><a href="#学习上：" class="headerlink" title="学习上："></a>学习上：</h2><h3 id="这次考核考的有点差劲，学长让我们再把内容完善一下，在完善的过程中我也学到了很多知识点："><a href="#这次考核考的有点差劲，学长让我们再把内容完善一下，在完善的过程中我也学到了很多知识点：" class="headerlink" title="这次考核考的有点差劲，学长让我们再把内容完善一下，在完善的过程中我也学到了很多知识点："></a><strong>这次考核考的有点差劲，学长让我们再把内容完善一下，在完善的过程中我也学到了很多知识点：</strong></h3><a id="more"></a><h3 id="（1）在过滤器中要想调用getSession（）方法，要先对request进行类型转换，否则不能直接调用getSession（）方法。"><a href="#（1）在过滤器中要想调用getSession（）方法，要先对request进行类型转换，否则不能直接调用getSession（）方法。" class="headerlink" title="** （1）在过滤器中要想调用getSession（）方法，要先对request进行类型转换，否则不能直接调用getSession（）方法。**"></a>** （1）在过滤器中要想调用getSession（）方法，要先对request进行类型转换，否则不能直接调用getSession（）方法。**</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest req= (HttpServletRequest) request;</span><br><span class="line">Object user=req.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="（2）联表查询："><a href="#（2）联表查询：" class="headerlink" title="**   （2）联表查询：**"></a>**   （2）联表查询：**</h3><p>                                内连接（等值内联，非等值内联，自连接）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T1.name, T2.name <span class="keyword">FROM</span> T1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> T2 <span class="keyword">ON</span> T1.id <span class="operator">=</span> T2.id</span><br></pre></td></tr></table></figure><p>                                           外连接（左外连接，右外连接，全外连接）</p><p>                左外连接：将左表内容全部显示，在右表没有找到相应的数据则记录为NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM T1 LEFT JOIN T2 ON T1.id = T2.id</span><br></pre></td></tr></table></figure><p>                  右外连接：将右表内容全部显示，在左表没有找到相应的记录为NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM T1 RIGHT JOIN T2 ON T1.id = T2.id;</span><br></pre></td></tr></table></figure><p>           </p><h3 id="考核过后，新的学习任务也发布下来了，希望这一阶段我能够好好学，不能再像上一阶段一样学的那么差劲了。"><a href="#考核过后，新的学习任务也发布下来了，希望这一阶段我能够好好学，不能再像上一阶段一样学的那么差劲了。" class="headerlink" title="考核过后，新的学习任务也发布下来了，希望这一阶段我能够好好学，不能再像上一阶段一样学的那么差劲了。"></a><strong>考核过后，新的学习任务也发布下来了，希望这一阶段我能够好好学，不能再像上一阶段一样学的那么差劲了。</strong></h3><h2 id="生活中："><a href="#生活中：" class="headerlink" title="生活中："></a>生活中：</h2><h3 id="这个星期感觉压力有点大。因为最近这学期课有点多，又加上我以前参加的东西比较多，就有点协调不过来的感觉。其实这一段时间挺迷茫的，以前总是想尝试更多的东西，导致我时间分配的太满了，就会有一种很累的感觉。希望以后我可以慢慢调整自己的时间安排，将时间规划好。"><a href="#这个星期感觉压力有点大。因为最近这学期课有点多，又加上我以前参加的东西比较多，就有点协调不过来的感觉。其实这一段时间挺迷茫的，以前总是想尝试更多的东西，导致我时间分配的太满了，就会有一种很累的感觉。希望以后我可以慢慢调整自己的时间安排，将时间规划好。" class="headerlink" title="这个星期感觉压力有点大。因为最近这学期课有点多，又加上我以前参加的东西比较多，就有点协调不过来的感觉。其实这一段时间挺迷茫的，以前总是想尝试更多的东西，导致我时间分配的太满了，就会有一种很累的感觉。希望以后我可以慢慢调整自己的时间安排，将时间规划好。"></a><strong>这个星期感觉压力有点大。因为最近这学期课有点多，又加上我以前参加的东西比较多，就有点协调不过来的感觉。其实这一段时间挺迷茫的，以前总是想尝试更多的东西，导致我时间分配的太满了，就会有一种很累的感觉。希望以后我可以慢慢调整自己的时间安排，将时间规划好。</strong></h3>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【音乐网站考核总结】</title>
      <link href="/2022/03/06/%E3%80%90%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>/2022/03/06/%E3%80%90%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99%E8%80%83%E6%A0%B8%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>        这次考核对于我来讲难度好像有点大，可能是我在假期太放松的原因吧。在这次考核中我遇到了好多好多问题：</p><a id="more"></a><p>        首先就是上传文件时，原本我获取表单项的时候都用“request.getParameter(“xxx”)”方法，但是“request.getParameter(“xxx”)”方法在enctype=”multipart/form-data”时就已经失效，它永远返回null。所以在上传文件的时候用getString（）方法获取普通表单项。</p><p>        上一次考核的时候我把所有代码都放在一个类里面了，代码看起来很乱，这次我把相似功能的类和接口放在一个包里面，看起来效果好了很多。</p><p><img src="https://img-blog.csdnimg.cn/aa4459358b5d46c58cc9be1a468cd9e8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_14,color_FFFFFF,t_70,g_se,x_16"></p><p> </p><p>        还有考核的时候学长提示的，要使用过滤器，因为要是不使用过滤器的话有的网站不登录也可以通过修改地址访问，用过滤器还可以简化很多代码。在用户修改用户信息的时候账户不能从客户端传到服务端，因为通过修改地址用户也可以修改其他用户的信息，这点是我以前没有想到的。还有就是请求重定向和请求转发，我都用的请求转发，对于请求重定向我不是很了解，学过之后就没有再用过了，学长说用请求重定向比较好，所以这部分的知识我要去好好了解一下了。</p><p>        通过这次考核，我学到了好多好多知识点，上传文件，播放音乐······总体来讲进步很大。但这次我做的还有好多好多不足的地方，很多功能都没有实现，数据库建了好多好多，但是没有用到，充vip，订单，浏览历史······害，还是要好好学习基础的知识，这样才可以把考核任务做的又快又好。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每周总结】</title>
      <link href="/2022/02/26/%E3%80%90%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>/2022/02/26/%E3%80%90%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>        这周一直在做考核任务，因为假期学习效率太低，知识掌握的就很不牢固，所以我在做考核任务的时候就很难受，有点做不出来。而且我写的代码还总是出错，写网站的速度就很慢，这是我一直烦恼的一点。</p><a id="more"></a><p>        在做项目的时候因为我参考了视频，所以也学到了很多的知识点，比如我开始的时候写的类和接口就很多，几乎是一个方法就要写一个Servlet类，后来学会把几个方法整合到一个类中，我的代码看起来就没有以前那么乱了。还有就是上一次写系统的时候我啥都不懂，就写了一个主类，然后我的代码就看起来很长很长。这次比上次有点进步，学会把类和接口放在不同的包中，这样我的代码有的地方出错了我也能够很快地去修改。还有就是因为我写的代码经常报错，所以我就需要经常上网查找资料，在这个过程中我对我所写的代码也加深了理解。所以我感觉代码总是出错也不是一件很坏的事情吧。</p><p>        在这一周的学习过程中我有了一些进步，但同时也发现了自己好多好多做的很差劲的地方，希望我以后在学习的时候不要再那么马马虎虎的，要静下心把知识学好，学透彻。继续加油吧！rty=”userHeadshotUrl” column=”children_user_headshot”/&gt;<br>            <result property="objectId" column="children_object_id"/><br>            <result property="objectName" column="children_user_name"/><br>            <result property="commentContent" column="children_comment_content"/><br>            <result property="commentTime" column="children_comment_time"/><br>        </collection><br></resultMap></p><select id="viewComment" resultMap="postCommentPojo" parameterType="java.lang.Integer">        select a.post_comment_id,               a.user_id,               b.user_name,               b.user_headshot_url,               a.object_id,               a.comment_content,               a.comment_time,               c.post_comment_id as children_id,               c.user_id as children_user_id,               d.user_name as children_user_name,               d.user_headshot_url as children_user_headshot,               c.object_id as children_object_id,               d.user_name as children_user_name,               c.comment_content as children_comment_content,               c.comment_time as children_comment_time        from post_comment as a        inner join user as b on a.user_id = b.user_id        left join post_comment as c on a.post_comment_id = c.object_id        inner join user as d on c.user_id = d.user_id        where a.object_id = #{postId} and a.comment_state = '0' and c.comment_state = '1'</select><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">         这一段时间我的接口也写的差不多了，就剩下登录没有写好。在接下来的时间我准备把重心放在完善接口和回顾基础知识上面。</span><br><span class="line"></span><br><span class="line">---ngBuilder.append(0);</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuilder.append(hv);</span><br><span class="line">        &#125;</span><br><span class="line">        return stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>        这一段时间也一直在进行对算法的练习，真的感觉算法好难，有时候题解我都看不懂，一个算法解很长时间也解不对也是常有的事情。虽然有时候真的对算法很崩溃，但是不得不承认的一点是每次弄懂一道算法题真的会学到很多知识。]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【寒假总结】（三）</title>
      <link href="/2022/02/20/%E3%80%90%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93%E3%80%91%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/02/20/%E3%80%90%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93%E3%80%91%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>配置程序</p><a id="more"></a><p>        这周在学习的过程中我遇到了一个问题，我的Tomcat突然启动不了了，一直闪退。事实上开始的时候我没有配置Tomcat的环境变量，但是软件却可以启动。但这周在idea上创建web项目的时候一直弹不出网页，看了报错才知道是服务器拒绝连接。我去启动Tomcat，才发现Tomcat出问题了，然后我去DOS窗口看运行Tomcat时报错，嗯······没有报错(⊙_⊙）。我上网查了查，网上说可能是在配置环境变量的时候多配置了JRE_HOME，因为JDK11.0之后手动生成jre，jre已经在jdk内部了，所以不需要在设置一个JRE_HOME。但是我根本没有配置JRE_HOME。然后我去问了同学，他问我是不是环境变量弄错了，我就按照他的环境变量去配置了一下我的，但是还是没有解决。后来我去查了端口是不是被占用了，是不是在把Tomcat整合到idea上的时候配置出了问题······但还是没有解决好。最后去问了组长，然后我把Tomcat重装了一下。在卸载Tomcat的时候也出现了好多问题，不过最后还是被我解决了。重装Tomcat之后就可以启动了，问题大部分都解决了，但是我比较迷的一点是我还没有配置环境变量呢，它怎么就可以正常运行了？？？(。_。)虽然我没有找到Tomcat出错的原因，但我感觉我在解决问题的过程中也学到了很多了，最后问题也解决了，也算有了很大的收获吧，嘿嘿嘿~</p><p>        快开学了，假期里面学习的太差劲了，希望到学校了可以好好学吧。</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【寒假总结】（二）</title>
      <link href="/2022/02/13/%E3%80%90%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/02/13/%E3%80%90%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>        前一段时间放了十四天的假。嗯······假期的生活真的很快乐，可以和好久不见的朋友一起出去聚聚，和好久没有一起玩的朋友一起打游戏。但事实证明，我真的是一个没有丝毫自制力的孩子，假期过后我的学习进度更跟不上了，学习状态一直调整不过来。</p><a id="more"></a><p>        这一段时间在学习servlet的相关知识，感觉学习过程中遇到了好多好多问题，还有就是有时候会有点迷茫，不知道怎么去学习新的知识，因为在网上找到的资料我很多时候都理解不了，可能是我理解能力有点差劲了，总感觉网上那些文字好抽象，好难去理解（╥﹏╥）。还有每次新安装一个软件我都要耗费好多好多的时间去配置，去学习它是怎么使用的（这一方面我也总是弄不好，学的比较慢）。</p><p>        再讲一下算法上面的问题吧。感觉好久没有写算法了，前几天去写算法的时候我竟然连一些特别特别基础的知识都忘记了o(TヘTo)，本来我的算法就不好，现在······哎，看来以后还是要多加练习啊。</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【寒假总结】</title>
      <link href="/2022/01/23/%E3%80%90%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>/2022/01/23/%E3%80%90%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>        这周我们开始了新一阶段的学习任务，这一阶段有好多重要的知识要进行学习。但是在家的时候学习效率比较低，我就一直跟不上学习计划，进度可慢，就只能在接下来的学习过程中慢慢赶进度了。</p><a id="more"></a><p>        上一阶段的学习我都是看着Java书进行学习的，这一阶段我开始是准备视频和书结合着学习的，书上的知识有点难理解，我觉得有时候看视频会对那些知识理解的更深刻点。但是有时候书上和视频里面讲的知识侧重点不一样，就像书上几页的知识，看视频却要好长好长时间，有时候视频里面几分钟概况的知识，书上却用了几页去讲解。所以有一段时间我就可迷，不知道是看书好还是看视频好，不过后来慢慢就可以把两者协调好了，现在学习还是以书为主的。</p><p>        还有就是算法题的问题，力扣上一道简单的算法题我就要做好久，就离谱。还有就是写的时候可以通过示例，但是一提交就错，准确率有点低。希望我可以在以后的算法练习中谨慎一点，确定无误之后再提交，提高自己的准确率。</p><p>        至于假期在家的生活就很平淡，上周我有时候会和朋友出去玩，这周几乎都在家里面没有出去过。就挺无聊的。。<img src="https://img-blog.csdnimg.cn/3469cbc9217548fb90aea6172e08b390.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我总结（五）</title>
      <link href="/2022/01/16/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2022/01/16/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>        这个星期我们开始了在假期的学习。通过一个星期的学习，我明显感觉到了在家学习的弊端。我的自制力比较差，没有了在学校的约束，学习效率是真的下降了许多。不过到后来的几天我也注意了一下这个问题，对此慢慢做出了一些改变，现在的学习效率比才放假的时候提高了一些，也算是一种进步吧。</p><p>        这一周一直在做考核的系统。因为在前几次学习阶段我并没有很好的去完成学习计划，导致我在开始做管理系统的时候发现我对于集合这一方面的知识掌握的非常差劲。所以在考核的前两天我一直在复习关于集合的知识，考核的系统做的也就比较慢。还有就是虽然我在期末考试前将异常处理和io流学的差不多了，但由于当时学的比较快，对那一部分的知识掌握的不是很牢固，再加上长时间的不复习，导致我考核的时候也要回过头去复习io流的一些知识。希望我以后可以吸取这一次的教训，注意一下及时复习的问题。</p><p>        在假期的时候我们会在力扣上练习算法题。哎，我算法不好这一点我一直都知道。这几天我也是一直按照计划在练习。在力扣上做题的时候，我也学到了我以前没有掌握的一些知识，也是收获了很多吧。希望我在假期可以好好地练一下我的算法，至少不要再那么差劲了*~*。</p><p><img src="https://img-blog.csdnimg.cn/e4ca1c0f05c24a329752faf6d4b7ca18.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我总结（四）</title>
      <link href="/2021/12/18/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2021/12/18/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>        这周我们又开始了新的学习任务，异常处理和IO流。感觉这一部分没有那么难理解，虽然我有时候还是会遇到一些想不通的地方。这段时间我学的还是比较快的，以前学java的时候总是跟不上小组的学习计划，这一次感觉还可以，但是学习计划前面安排复习面向对象和集合的那一部分我没有复习。我知道我那一部分学的很差劲，但是我想等到我把新的内容学完在回头去复习，这样如果复习的时间长的话我还可以把新学的内容复习一下。我怕我要是先复习的话后面的学习任务又会学不完······所以我就选择了先学习新的内容，最后再一起进行复习。</p><p>        虽然我这次学习的比较快，不至于像以前那样到考核的时间了，还是有大把的内容没有学习，但在最近的学习过程中我也发现了学的太快的弊端–学的快，忘得也贼快！嗯······记性不好，我也没有其他办法了，只能在学后面的内容的时候和前面的学习内容串一下了，这样可能会好点。到最后我再复习一下子，应该就差不多了吧？？？</p><p>        临近期末了，C语言的老师又告诉了我们一个不幸的消息，我们班好像安排在17周实训了。这感觉有点不太妙，17周要是实训的话我们复习的时间就非常非常少了。而且我们高数考试好像安排到了第一场，愁苦······<img src="https://img-blog.csdnimg.cn/20f69ccd8c8646a5adb77de79310b44f.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我总结（三）</title>
      <link href="/2021/12/12/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2021/12/12/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>分方向</p><a id="more"></a><p>        前端的考核结束了，现在要分前后端了。对于前后端，可能是我才接触的原因，感觉都挺有意思的。学长说前端前面学着比较简单，后面就比较难。而后端，我看组长给我发的那个图片，那是劝退的图片吧？？？一遍看下来，全是难！难！难！痛苦ing（*—*）。但是前端的话，我也不知道我学的怎么样，这段时间在做考核页面，感觉学的还可以，至少不像当初学习Java时候那么迷茫了（Java是真的难）。但至于具体选择哪个方向，还是看这次前端考的怎么样吧，看看我前后端哪个学的更好一点，比较适合哪个。</p><p>        在其他方面，嗯······这周举行了新生万米越野，特别快乐。事实上在举办之前我还在想怎么办，跑那么多圈我会累死的吧。但是在比赛完，虽然被学长学姐说我严重划水，但是那满满一兜的零食就是我的快乐源泉&amp;-&amp;。</p><p>        还有就是过几周就考试了，我的高数和c语言学的不是很好，怨我以前上课的时候总是划水。还有几周时间，希望我可以在这方面多用点心，别把不会的知识一直累积到复习周去解决。 </p><p><img src="https://img-blog.csdnimg.cn/98488768524a4bb7bd1d9d8cc0a3fcf2.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ISR55Oc5ZGG5ZGG,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>·自我总结·</title>
      <link href="/2021/12/05/%C2%B7%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%C2%B7/"/>
      <url>/2021/12/05/%C2%B7%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%C2%B7/</url>
      
        <content type="html"><![CDATA[<p>前端</p><a id="more"></a><p>        这一周过的好快啊，现在我们已经开始了前端的考核。在刚开始接触前端的时候，感觉学的还可以······但在开始考核的时候我才发现我需要学的知识还有好多好多。开始看视频的时候我确实是拉下了不少进度，所以后来我就加快了速度，但后面学习的内容是比较重要的，特别是解决高度坍塌那一块。当时看视频的时候因为在赶进度，所以也没有上手实践，就只是看看视频。在后面做考核页面的时候就发现我这方面的知识几乎没有记住，然后就只能边学习边做页面······我看有的同学做页面做的真的非常快，我连框架都没有构建好，他已经把大致的页面快做完了，所以有时候就会觉得有那么一丢丢小烦。但我知道急也没有用，哎，只能在接下来的时间好好努力了。</p><p>        还有就是在接下来的学习中我希望我可以利用好自己的空闲时间，顺便就是调整好自己的状态，因为最近看视频总是瞌睡······就可困······可能是太无聊？？？我觉得我以后要注意一下这个问题了，及时把它改正过来······</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客^-^</title>
      <link href="/2021/11/28/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%5E-%5E/"/>
      <url>/2021/11/28/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%5E-%5E/</url>
      
        <content type="html"><![CDATA[<p>        不知不觉中，我进入大学已经有一段时间了。记得才进入大学时的我，懵懵懂懂，内心对于大学充满了幻想。到现在，我发现我当初对于大学的想象确实是幻想······</p><a id="more"></a><p>        进入大学后我真的改变了很多，开始去尝试各种新的事物，感觉自己收获了挺多的。就比如打篮球。我感觉我可能真的不是很适合这个运动，但当时为了躲避早操（真的很累），然后就跟着朋友加入了女篮。开始训练的时候，表现得真的是非常非常差劲，特别是在练习胯下运球的时候，球就一直不听指挥（≧ ﹏ ≦）。但经过了一段时间的练习，我感觉我真的进步了。前几天篮球队进行了考核，在通过考核的时候，我突然就有了一种付出就会有回报的感觉（虽然我还是不会胯下运球，考核成绩也不是很好~-~）。</p><p>        还有就是在小组的学习因为加入了小组，平时的休息时间就变得很少，我以为我这样懒散的性子可能会有些不适应，但后来看来是我想多了。在最开始学习Java的时候真的是非常痛苦&gt;_&lt;，那是真的学不会啊，一直都跟不上进度。有一段时间我还一直请假（直接请假请到不好意思）。但是当时我感觉Java挺有意思的······现在我们在学习前端，我们主要是通过看视频学习的，我看视频的速度可能是有点慢了（虽然我前面一直都用二倍速看），所以我觉得我在接下来的学习中要加快速度了，总是跟不上进度可不行。而且我感觉我对于学习的积极性可能有点差，我都要被别人卷死了······希望我以后可以慢慢做出改变吧。</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
